<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mark-Inscribed Monster</title>
    <style>
        :root {
            --fire-color: #FF7B7B; --water-color: #7B8CFF;
            --wind-color: #7BFFB8; --earth-color: #C19A6B;
            --card-width: 63px; --card-height: 91px;
            --accent: #FFCC00;
        }
        body { background-color: #3D3D3D; color: #F0F0F0; font-family: sans-serif; margin: 0; overflow: hidden; }
        
        .screen { display: none; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .menu-btn { width: 260px; padding: 15px; margin: 10px; background: #444; border: 2px solid #666; color: white; cursor: pointer; border-radius: 10px; font-weight: bold; text-align: center; font-size: 1.1em; }
        .menu-btn:hover { border-color: var(--accent); background: #555; transform: scale(1.02); }
        .game-button { padding: 8px 16px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; }
        .game-button:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }

        .game-container { width: 100%; max-width: 1000px; display: flex; flex-direction: column; height: 100vh; position: relative; }
        
        .field { 
            display: grid; 
            grid-template-areas: "slot0 slot1 slot2" "slot5 slot4 slot3"; 
            gap: 10px; padding: 15px; justify-content: center; background: rgba(0,0,0,0.2);
        }
        .field.opponent-field-layout {
            grid-template-areas: "slot3 slot4 slot5" "slot2 slot1 slot0";
        }

        .card-slot { width: var(--card-width); height: var(--card-height); background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; position: relative; border: 1px dashed rgba(255,255,255,0.2); }
        .card { width: var(--card-width); height: var(--card-height); border-radius: 8px; color: #333; cursor: pointer; position: relative; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; padding: 5px; font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 0.7em; }
        .card.fire { background-color: #FFFFFF; }
        .card.water { background-color: #FFFFFF; }
        .card.wind { background-color: #FFFFFF; }
        .card.earth { background-color: #FFFFFF; }
        .card.special { background-color: #FFFFFF; }
        /* Thematic Colors for Cards */
        .color-light { background-color: #FFFF00; } /* Yellow */
        .color-dark { background-color: #333333; } /* Black */
        .color-fire { background-color: #FF0000; } /* Red */
        .color-water { background-color: #0000FF; } /* Blue */
        .color-land { background-color: #8B4513; } /* Brown */
        .color-wind { background-color: #00FF00; } /* Green */
        .color-metal { background-color: #C0C0C0; } /* Silver */
        .color-magic { background-color: #FFFFFF; } /* White */
        .color-melody { background-color: #FFC0CB; } /* Pink */
        .color-mountain { background-color: #2F4F4F; } /* Dark Green */
        .color-nether { background-color: #800080; } /* Red-purple (Purple) */
        .color-abandoned { background-color: #F5F5DC; } /* Beige */
        .color-poison { background-color: #800080; } /* Purple (same as Nether for now) */
        .color-ice { background-color: #ADD8E6; } /* Light Blue */
        .color-paralysis { background-color: #ADFF2F; } /* Yellow-green */
        .color-illness { background-color: #ADFF2F; } /* Greenish Yellow (same as paralysis for now) */
        .color-acid { background-color: #7CFC00; } /* Lime Green */

        /* Two-color/pattern */
        .color-crystal { background: linear-gradient(45deg, #FFFFFF, #0000FF); } /* White and Blue */
        .color-dirty { background: linear-gradient(45deg, #333333, #8B4513); } /* Black and Brown */
        .color-blood { background: linear-gradient(45deg, #FF0000, #333333); } /* Red and Black */
        .color-chie { background: linear-gradient(45deg, #FFFFFF, #FFFF00); } /* White and Yellow */
        .color-plant { background: linear-gradient(45deg, #8B4513, #00FF00); } /* Brown and Green */

        /* Special categories */
        .color-star { background-color: #FFD700; } /* Gold for Star mark placeholder */
        .color-emotion { background-color: #FF69B4; } /* Hot Pink for Emotion mark placeholder */
        .color-support { background-color: #FFFFFF; } /* White for Support cards */
        
        /* Fallback */
        .color-default { background-color: #666; } /* Default gray */
        .card.back { background-color: #666; border: 2px solid #444; }
        .card.selected { outline: 3px solid yellow; z-index: 10; }
        .card.attacked { filter: grayscale(0.9) brightness(0.7); cursor: default; }
        .hp-badge { position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.6); color: white; padding: 1px 3px; border-radius: 3px; font-size: 0.7em; }
        .card-name-display {
            /* font-size will be set dynamically by JS, but a default can be useful */
            font-size: 1em; /* Initial value, will be overridden */
            line-height: 1.1;
            word-break: break-word; /* Allow long words to break */
            overflow: hidden; /* Hide overflowing text before JS adjusts */
            max-height: 100%; /* Prevent name from taking too much vertical space */
        }
        .player-hand, .opponent-hand-area { height: 110px; display: flex; justify-content: center; align-items: center; gap: 5px; background: rgba(0,0,0,0.4); }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 15px; background: #222; font-size: 0.85em; border-top: 1px solid #444; border-bottom: 1px solid #444; }
        .card-pile-slot { width: 50px; height: 70px; background: #666; border: 2px solid #444; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: white; }
        .control-lane { display: flex; justify-content: space-around; align-items: center; background: #222; padding: 10px; }
        .center-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .score-display { font-size: 4em; font-weight: bold; min-width: 120px; text-align: center; }
        .score-display.opponent-score { color: #FF7B7B; }
        .score-display.player-score { color: #7B8CFF; }
        .log-area { position: absolute; left: 10px; top: 10px; width: 220px; height: 150px; background: rgba(0,0,0,0.85); font-size: 11px; overflow-y: auto; padding: 10px; z-index: 100; border: 1px solid #555; line-height: 1.4; color: #EEE; }
        
        #roulette-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 2000; font-size: 3em; color: #FFF; font-weight: bold; }

        .grid-container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; max-height: 70vh; overflow-y: auto; padding: 20px; background: rgba(0,0,0,0.5); border-radius: 15px; width: 80%; }
        
        /* „Ç®„Éá„Ç£„ÇøÁî®„ÅÆËøΩÂä†„Çπ„Çø„Ç§„É´ */
        .slot { background: #444; border: 2px solid #666; padding: 10px; border-radius: 8px; cursor: pointer; text-align: center; }
        .slot:hover { border-color: var(--accent); }
        .editor-layout { display: flex; gap: 20px; width: 95%; height: 75vh; }
        .scroll-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 10px; overflow-y: auto; flex-grow: 1; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; }
        /* „Éû„Éº„ÇØ„ÅÆÂÖ±ÈÄöË®≠ÂÆö */
        .common-mark { width: 100%; height: 100%; background: #666; position: absolute; }

        /* Êòü„ÅÆÂΩ¢ÔºàÁ∞°ÊòìÁâàÔºâ */
        .star-mark { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); background: #FFD700; }

        /* ‰∏∏„ÅÆÂΩ¢ */
        .circle-mark { border-radius: 50%; background: #FF7B7B; }

        /* ‰∏âËßí„ÅÆÂΩ¢ */
        .triangle-mark { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); background: #7BFFB8; }

        /* ÂõõËßí„ÅÆÂΩ¢ */
        .square-mark { border-radius: 4px; background: #7B8CFF; }

        /* Ê®°ÊßòÔºà„ÉÅ„Çß„ÉÉ„ÇØ„Å™„Å©Ôºâ„ÅÆ‰æã */
        .pattern-mark { background: #ccc; border: 2px dashed #333; }
    </style>
</head>
<body>

<div id="coin-flip-screen" class="screen" style="flex-direction: column; background: rgba(0,0,0,0.9); font-weight: bold; color: #FFF; text-align: center;">
    <div id="coin-flip-title" style="font-size: 3em; margin-bottom: 20px;"></div>
    <div id="cointoss-result" style="font-size: 4em; font-weight: bold; color: yellow; height: 80px;"></div>
    <button id="cointoss-btn" class="game-button" style="padding: 15px 30px; font-size: 1.5em; background:#4CAF50" onclick="handleCoinTossButtonClick()">„Ç≥„Ç§„É≥„Éà„ÇπÔºÅ</button>
</div>

<div id="title-screen" class="screen active">
    <h1 style="font-size: 3em; color:var(--accent); text-shadow: 2px 2px 10px rgba(0,0,0,0.5);">Mark-Inscribed Monster</h1>
    <div class="menu-btn" data-lang-key="adventure_battle" onclick="showScreen('mode-screen')">ADVENTURE / BATTLE</div>
    <div class="menu-btn" data-lang-key="deck_editor" onclick="openDeckList('edit')">DECK EDITOR (100 Slots)</div>
    <div class="menu-btn" data-lang-key="card_collection" onclick="showScreen('collection-screen')">CARD COLLECTION</div>
    <div class="menu-btn" data-lang-key="game_settings" onclick="showScreen('settings-screen')">GAME SETTINGS</div>
</div>

<div id="editor-screen" class="screen">
    <h2 id="editor-title" data-lang-key="deck_editor_title">DECK EDITOR</h2>
    <div class="editor-layout">
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3 data-lang-key="card_pool">CARD POOL</h3>
            <div style="margin-bottom: 10px; display:flex; gap: 5px; align-items:center;">
                <input type="text" id="editor-name-search-input" placeholder="ÂêçÁß∞..." style="padding: 6px; font-size: 0.9em; width: 120px;">
                <input type="text" id="editor-power-search-input" placeholder="„Éë„ÉØ„ÉºÂêç..." style="padding: 6px; font-size: 0.9em; width: 120px;">
                <button class="game-button" style="padding: 6px 10px;" onclick="filterEditorPool()">Ê§úÁ¥¢</button>
            </div>
            <div id="pool-grid" class="scroll-grid"></div>
        </div>
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3><span data-lang-key="deck_count_label">DECK</span> (<span id="deck-count">0</span>/30)</h3>
            <div id="current-deck-grid" class="scroll-grid"></div>
        </div>
    </div>
    <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="game-button" data-lang-key="save_exit" onclick="saveDeck()">SAVE & EXIT</button>
        <button class="game-button" data-lang-key="cancel" style="background:#666" onclick="openDeckList('edit')">CANCEL</button>
    </div>
</div>

<div id="mode-screen" class="screen">
    <h2 data-lang-key="select_challenge">SELECT YOUR CHALLENGE</h2>
    <div class="menu-btn" data-lang-key="vs_random_ai" style="background:#4CAF50" onclick="initBattle()">VS RANDOM AI</div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK TO TITLE</div>
</div>

<div id="settings-screen" class="screen">
    <h2 data-lang-key="settings">SETTINGS</h2>
    <div class="menu-btn" data-lang-key="language_toggle" onclick="toggleLanguage()">LANGUAGE: Êó•Êú¨Ë™û</div>
    <div class="menu-btn" data-lang-key="sound_settings" onclick="alert('Sound Settings')">BGM / SE</div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="collection-screen" class="screen">
    <h2 data-lang-key="collection">COLLECTION</h2>
    <div style="margin-bottom: 15px; display:flex; gap: 10px; align-items:center;">
        <input type="text" id="name-search-input" placeholder="ÂêçÁß∞„ÅßÊ§úÁ¥¢..." style="padding: 8px; font-size: 1em; width: 200px;">
        <input type="text" id="power-search-input" placeholder="„Éë„ÉØ„ÉºÂêç„ÅßÊ§úÁ¥¢..." style="padding: 8px; font-size: 1em; width: 200px;">
        <button class="game-button" onclick="filterCollection()">Ê§úÁ¥¢</button>
    </div>
    <button class="game-button" onclick="addMonsterCardsToCollection()">„Åï„Çâ„Å´„É¢„É≥„Çπ„Çø„Éº„Ç´„Éº„Éâ„ÇíÁîüÊàê</button>
    <div id="coll-grid" class="grid-container" style="grid-template-columns: repeat(7, 1fr);"></div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="deck-list-screen" class="screen">
    <h2 data-lang-key="choose_deck_slot">CHOOSE DECK SLOT</h2>
    <div id="deck-grid" class="grid-container"></div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="game-screen" class="screen">
    <div class="game-container">
        <div id="log-area" class="log-area"><strong>„Äê„Ç≤„Éº„É†„É≠„Ç∞„Äë</strong></div>
        <div id="opponent-hand" class="opponent-hand-area"></div>
        <div class="opponent-area"><div id="opponent-field" class="field opponent-field-layout"></div></div>
        <div class="info-row">
            <div class="info-item">ÊâãÊú≠: <span id="opp-hand-count">0</span></div>
            <div class="info-item">Â¢ìÂú∞: <div id="opp-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">Â±±Êú≠: <div id="opp-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item" style="color:gold">„Éë„ÉØ„Éº: <span id="opp-power-display">5</span></div>
        </div>
        <div class="control-lane">
            <div class="score-display opponent-score" id="opp-hp">20</div>
            <div class="center-controls">
                <div id="status-text" style="color:yellow; font-weight:bold; font-size:0.9em;">...</div>
                <button id="ok-btn" class="game-button" style="display:none;" onclick="confirmPlacement()">ÈÖçÁΩÆ„ÇíÂÆå‰∫Ü„Åô„Çã</button>
                <div id="battle-controls" style="display:none; flex-direction: column; gap: 10px; align-items: center;">
                    <button id="power-btn" class="game-button" style="background:#ccac00" onclick="handlePowerInject()">„Éë„ÉØ„Éº„ÇíÊ≥®ÂÖ•</button>
                    <button id="end-turn-btn" class="game-button" onclick="handleEndTurn()">„Çø„Éº„É≥ÁµÇ‰∫Ü</button>
                </div>
            </div>
            <div class="score-display player-score" id="ply-hp">20</div>
        </div>
        <div class="info-row">
            <div class="info-item" style="color:gold">„Éë„ÉØ„Éº: <span id="ply-power-display">5</span></div>
            <div class="info-item">Â±±Êú≠: <div id="ply-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item">Â¢ìÂú∞: <div id="ply-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">ÊâãÊú≠: <span id="ply-hand-count">0</span></div>
        </div>
        <div class="player-area"><div id="player-field" class="field"></div></div>
        <div id="player-hand" class="player-hand"></div>
    </div>

    <!-- Attack Menu Overlay -->
    <div id="attack-menu" style="display:none; position:absolute; background:rgba(0,0,0,0.8); border:1px solid yellow; padding:10px; border-radius:5px; flex-direction:column; gap:5px; z-index:1000;">
        <button class="game-button" id="menu-attack-btn" style="background:#ccac00;">ÊîªÊíÉ</button>
        <button class="game-button" id="menu-special-btn" style="background:#4CAF50;">ÁâπÊÆäËÉΩÂäõ</button>
        <button class="game-button" id="menu-cancel-btn" style="background:#888;">„Ç≠„É£„É≥„Çª„É´</button>
    </div>
</div>


<div id="game-over-screen" class="screen">
    <h1 id="game-result-text" style="font-size: 4em; color:var(--accent);"></h1>
    <div id="game-over-log" style="width: 80%; max-width: 600px; height: 300px; background: rgba(0,0,0,0.7); border: 1px solid #555; overflow-y: auto; padding: 10px; margin-bottom: 20px; font-size: 12px; line-height: 1.5;"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">„Çø„Ç§„Éà„É´„Å∏Êàª„Çã</div>
</div>

<script>
// --- ÂêçÂâç„ÅÆÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ ---
const sizes = [
    "„Éü„Éã", "„Éé„Éº„Éû„É´", "„Ç∏„É£„Ç§„Ç¢„É≥„Éà", "„Éè„Ç§„Éü„Éã", "„Éè„Ç§„Éé„Éº„Éû„É´", "„Éè„Ç§„Ç∏„É£„Ç§„Ç¢„É≥„Éà",
    "‰ºùË™¨„ÅÆ„Éü„Éã", "‰ºùË™¨„ÅÆ„Éé„Éº„Éû„É´", "‰ºùË™¨„ÅÆ„Ç∏„É£„Ç§„Ç¢„É≥„Éà", "„É≠„Éú„Éü„Éã", "„É≠„Éú„Éé„Éº„Éû„É´", "„É≠„Éú„Ç∏„É£„Ç§„Ç¢„É≥„Éà",
    "È¨º„Éü„Éã", "È¨º„Éé„Éº„Éû„É´", "È¨º„Ç∏„É£„Ç§„Ç¢„É≥„Éà", "Ë¶öÈÜí„É¢„Éº„Éâ„Éü„Éã", "Ë¶öÈÜí„É¢„Éº„Éâ„Éé„Éº„Éû„É´", "Ë¶öÈÜí„É¢„Éº„Éâ„Ç∏„É£„Ç§„Ç¢„É≥„Éà"
];
// For accurate prefix matching, sort sizes by length descending
const sortedSizes = [...sizes].sort((a, b) => b.length - a.length);

const powers = [
    "„É©„Ç§„Éà", "„ÉÄ„Éº„ÇØ", "„Éï„Ç°„Ç§„É§„Éº", "„Ç¶„Ç©„Éº„Çø„Éº", "„É©„É≥„Éâ", "„Ç¶„Ç£„É≥„Éâ", "„É°„Çø„É´", "„ÇØ„É™„Çπ„Çø„É´", "„Éû„Ç∏„ÉÉ„ÇØ",
    "„ÇØ„É™„Ç¢", "„É°„É≠„Éá„Ç£„Éº", "„Éû„Ç¶„É≥„ÉÜ„É≥", "„Éù„Ç§„Ç∫„É≥", "„ÉÄ„Éº„ÉÜ„Ç£", "„Éñ„É©„ÉÉ„Éâ", "„Ç¢„Ç§„Çπ", "„Éë„É©„É™„Ç∑„Çπ",
    "„Ç§„É´„Éç„Çπ", "„Ç¢„Ç∑„ÉÉ„Éâ", "„Çø„Ç§„É§„Éº„Éâ", "„Éí„Éº„É´", "„ÉÅ„É£„Éº„É†", "„Ç§„Éü„ÉÜ„Ç§„Éà", "„ÉÅ„Çß„É≥„Ç∏", "„Éó„É¨„Ç§", "„Ç∞„É´„Éº„Éó",
    "„Çπ„É™„Éº„Éó", "„Ç§„É¨„Ç§„Çπ", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà", "„Éï„Çß„Ç§„ÇØ", "„Ç™„Éº„É´", "„Ç¢„É≥„Ç∞„É™„Éº", "„Ç∏„Éß„Ç§", "„ÇΩ„É≠„Éº",
    "„Éó„É¨„Ç∑„É£„Éº", "„É©„Éñ", "„Éò„Ç§„Éà", "„Éï„Ç£„Ç¢„Éº", "„Çµ„Éó„É©„Ç§„Ç∫", "„Ç¶„Ç©„É≥„Éà", "„Éó„É©„É≥„Éà", "„ÉÅ„Çß„ÉÉ„ÇØ", "„Éâ„ÉÉ„Éà",
    "„ÉØ„Éº„É´„Éó„Éº„É´", "„Éç„Ç∂„Éº", "„Ç¢„Éê„É≥„ÉÄ„É≥„Éâ", "„ÉÅ„Ç®"
];

const species = [
    "„Çπ„É©„Ç§„É†", "„É©„Éì", "„Ç¶„É´„Éï", "„Éï„É≠„ÉÉ„Ç∞", "„Ç≠„É£„ÉÉ„Éà", "„Ç§„Éº„Çø„Éº", "„Éô„Ç¢", "„Ç¥„Éº„É¨„É†", "„ÉØ„Éº„É†",
    "„Éâ„É©„Ç¥„É≥", "„Éû„É≥", "„Çπ„Éî„É™„ÉÉ„Éà", "„Éï„Çß„Ç¢„É™„Éº", "„Éá„Éº„É¢„É≥"
];
// For accurate suffix matching, sort species by length descending
const sortedSpecies = [...species].sort((a, b) => b.length - a.length);

const trumpNames = ["„Ç®„Éº„Çπ", "„Ç≠„É≥„Ç∞", "„ÇØ„Ç§„Éº„É≥", "„Ç∏„É£„ÉÉ„ÇØ", "„Ç∏„Éß„Éº„Ç´„Éº", "„Éè„Éº„Éà", "„Çπ„Éö„Éº„Éâ", "„ÉÄ„Ç§„É§", "„ÇØ„É©„Éñ"];

function getRandomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function generateHuntingName() {
    const size = getRandomElement(sizes);
    const power = getRandomElement(powers);
    const specie = getRandomElement(species);
    return `${size}${power}${specie}`;
}

function extractMonsterParts(monsterName) {
    let sizeName = null;
    let powerName = null;
    let raceName = null;
    let remainingName = monsterName;

    // Extract sizeName (longest prefix match)
    for (const size of sortedSizes) {
        if (remainingName.startsWith(size)) {
            sizeName = size;
            remainingName = remainingName.substring(size.length);
            break;
        }
    }

    // Extract raceName (longest suffix match from remainingName)
    for (const specie of sortedSpecies) {
        if (remainingName.endsWith(specie)) {
            raceName = specie;
            remainingName = remainingName.substring(0, remainingName.length - specie.length);
            break;
        }
    }

    // What's left is the powerName
    powerName = remainingName || null;

    return { sizeName, powerName, raceName };
}

function generateTrumpName() {
    return getRandomElement(trumpNames);
}
// --- „Åì„Åì„Åæ„ÅßÂêçÂâç„ÅÆÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ ---

function getInitialism(powerName) {
    const mapping = {
        "„Éí„Éº„É´": "H", "„ÉÅ„É£„Éº„É†": "Ch", "„Ç§„Éü„ÉÜ„Ç§„Éà": "Im", "„ÉÅ„Çß„É≥„Ç∏": "Cg", "„Éó„É¨„Ç§": "P",
        "„Ç∞„É´„Éº„Éó": "G", "„Çπ„É™„Éº„Éó": "Sl", "„Ç§„É¨„Ç§„Çπ": "Er", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà": "En", "„Éï„Çß„Ç§„ÇØ": "Fk",
        "„Ç™„Éº„É´": "Al", "„Éç„Ç∂„Éº": "N", "„ÉÅ„Ç®": "Ce", "„Ç≥„Éî„Éº": "Cp",
        "„Ç¢„É≥„Ç∞„É™„Éº": "Ag", "„Ç∏„Éß„Ç§": "J", "„ÇΩ„É≠„Éº": "Sr", "„Éó„É¨„Ç∑„É£„Éº": "Ps", "„É©„Éñ": "L",
        "„Éò„Ç§„Éà": "Ht", "„Éï„Ç£„Ç¢„Éº": "Fr", "„Çµ„Éó„É©„Ç§„Ç∫": "Sp", "„Ç¶„Ç©„É≥„Éà": "Wt", "„Ç¢„Éê„É≥„ÉÄ„É≥„Éâ": "Ab",
        "„Éù„Ç§„Ç∫„É≥": "Po", "„ÉÄ„Éº„ÉÜ„Ç£": "Di", "„Éñ„É©„ÉÉ„Éâ": "Bl", "„Éë„É©„É™„Ç∑„Çπ": "Pl", "„Ç§„É´„Éç„Çπ": "Il",
        "„Ç¢„Ç∑„ÉÉ„Éâ": "Ac", "„Çø„Ç§„É§„Éº„Éâ": "Ti",
        "„ÉÅ„Çß„ÉÉ„ÇØ": "Ck", "„Éâ„ÉÉ„Éà": "Do", "„ÉØ„Éº„É´„Éó„Éº„É´": "Wp", "„É°„É≠„Éá„Ç£„Éº": "Me",
        "„Éï„Ç°„Ç§„É§„Éº": "F", "„Ç¶„Ç©„Éº„Çø„Éº": "W", "„Ç¶„Ç£„É≥„Éâ": "Wd", "„É©„É≥„Éâ": "Ld",
        "„Éû„Ç¶„É≥„ÉÜ„É≥": "Mt",
        "„Çπ„Çø„Éº": "St",
        "„Ç®„É¢„Éº„Ç∑„Éß„É≥": "Em",
        "„Éû„Ç§„Éä„Çπ": "Mn",
        "„Çπ„É™„Éº„Éó": "Sl"
    };
    return mapping[powerName] || powerName;
}

// Êñ∞Ë¶èÔºöÁä∂ÊÖãÁï∞Â∏∏„Çí„Ç´„Éº„Éâ„Å´ÈÅ©Áî®„Åô„ÇãÔºàÊ∞∏Á∂öÁâàÔºâ
function applyStatusEffect(targetCard, effectName) {
    if (!targetCard) return;

    // „Åô„Åß„Å´Âêå„ÅòÂäπÊûú„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
    const existingEffect = targetCard.statusEffects.find(e => e.name === effectName);
    
    // „Åæ„Å†„Åã„Åã„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞ËøΩÂä†„Åô„Çã„Å¥„Çá„ÇìÔºÅ
    // „Çø„Éº„É≥Êï∞„ÅÆ„Ç´„Ç¶„É≥„ÉàÔºàdurationÔºâ„Å™„Å©„ÅØÊåÅ„Åü„Åõ„Å™„ÅÑ„Åì„Å®„ÅßÊ∞∏Á∂ö„Å´„Åô„Çã„Å¥„Çá„Çì„ÄÇ
    if (!existingEffect) {
        targetCard.statusEffects.push({ name: effectName });
        addLog(getFormattedText('log_status_applied', { effect: effectName, rank: targetCard.rank }));
    }
}

// Êñ∞Ë¶èÔºö„Çø„Éº„É≥ÁµÇ‰∫ÜÊôÇ„Å´Áä∂ÊÖãÁï∞Â∏∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã
// „Çø„Éº„É≥ÁµÇ‰∫ÜÊôÇ„Å´Áä∂ÊÖãÁï∞Â∏∏„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„ÇãÔºàËß£Èô§Âá¶ÁêÜ„Å™„Åó„ÉªÂ¢ìÂú∞ÈÄÅ„Çä„Åæ„ÅßÁ∂ôÁ∂öÔºâ
function stateCheck(callback) {
    addLog("‚ñº Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØÔºàÊ∞∏Á∂ö„Éë„ÉØ„ÉºÁô∫Âãï‰∏≠ÔºÅÔºâ ‚ñº");

    const allCards = [...state.player.field, ...state.opponent.field].filter(c => c);
    state.sleepCheckQueue = allCards.filter(c => c && c.isSleeping);

    if (state.sleepCheckQueue.length > 0) {
        processSleepCheckQueue(callback);
    } else {
        finishStateCheck(callback);
    }
}

function processSleepCheckQueue(callback) {
    if (state.sleepCheckQueue.length === 0) {
        finishStateCheck(callback);
        return;
    }

    const card = state.sleepCheckQueue.shift();
    const cardOwner = getCardOwner(card);

    showScreen('coin-flip-screen'); // Always show the coin flip screen
    const title = document.getElementById('coin-flip-title');
    title.textContent = `${card.rank}„ÅÆ„Çπ„É™„Éº„Éó„ÉÅ„Çß„ÉÉ„ÇØÔºÅ`;
    const cointossBtn = document.getElementById('cointoss-btn');
    const resultDiv = document.getElementById('cointoss-result');
    resultDiv.textContent = ''; // Clear previous result

    if (cardOwner === "player") {
        cointossBtn.style.display = 'inline-block'; // Show button for player
        state.currentCoinTossHandler = () => handleSleepCoinToss(card, callback);
    } else if (cardOwner === "opponent") {
        cointossBtn.style.display = 'none'; // Hide button for opponent
        state.currentCoinTossHandler = null; // No manual click needed
        
        // Automate opponent's coin toss after a delay
        setTimeout(() => {
            performAutomatedSleepCoinToss(card, callback);
        }, 1500); // 1.5 second delay for suspense
    } else {
        // Fallback for cards not found on any field
        // Still show screen, but might not have interactive elements if no owner
        cointossBtn.style.display = 'none';
        state.currentCoinTossHandler = null;
        setTimeout(() => {
            processSleepCheckQueue(callback);
        }, 500); // Shorter delay for unexpected state
    }
}

function performAutomatedSleepCoinToss(card, callback) {
    if (!card) return;

    const resultDiv = document.getElementById('cointoss-result');
    const isHeads = Math.random() < 0.5;

    if (isHeads) {
        card.isSleeping = false;
        resultDiv.textContent = 'Ë°®ÔºÅ';
        addLog(`${card.rank}„ÅØ„Ç≥„Ç§„É≥„Éà„Çπ„ÅÆÁµêÊûú„ÄÅÁõÆ„ÇíË¶ö„Åæ„Åó„ÅüÔºÅ (Áõ∏Êâã)`);
    } else {
        resultDiv.textContent = 'Ë£è...';
        addLog(`${card.rank}„ÅØ„Ç≥„Ç§„É≥„Éà„Çπ„ÅÆÁµêÊûú„ÄÅ„Åæ„Å†Áú†„Å£„Å¶„ÅÑ„Çã... (Áõ∏Êâã)`);
    }

    setTimeout(() => {
        showScreen('game-screen');
        render();
        processSleepCheckQueue(callback);
    }, 1500);
}

function handleSleepCoinToss(card, callback) {
    if (!card) return;

    const btn = document.getElementById('cointoss-btn');
    btn.style.display = 'none';

    const resultDiv = document.getElementById('cointoss-result');
    const isHeads = Math.random() < 0.5;

    if (isHeads) {
        card.isSleeping = false;
        resultDiv.textContent = 'Ë°®ÔºÅ';
        addLog(`${card.rank}„ÅØ„Ç≥„Ç§„É≥„Éà„Çπ„ÅÆÁµêÊûú„ÄÅÁõÆ„ÇíË¶ö„Åæ„Åó„ÅüÔºÅ`);
    } else {
        resultDiv.textContent = 'Ë£è...';
        addLog(`${card.rank}„ÅØ„Ç≥„Ç§„É≥„Éà„Çπ„ÅÆÁµêÊûú„ÄÅ„Åæ„Å†Áú†„Å£„Å¶„ÅÑ„Çã...`);
    }

    setTimeout(() => {
        state.currentCoinTossHandler = null; // Clear handler
        showScreen('game-screen');
        render();
        // Process the next card in the queue, passing the original callback
        processSleepCheckQueue(callback);
    }, 1500);
}


function finishStateCheck(callback) {
    const allCards = [...state.player.field, ...state.opponent.field].filter(c => c);
    
    allCards.forEach(card => {
        if (!card || card.statusEffects.length === 0) return;

        card.statusEffects.forEach(effect => {
            let damage = 0;
            // „Åì„Åì„ÅßÂêÑ„Éû„Ç§„Éä„Çπ„Éë„ÉØ„Éº„ÅÆ„ÉÄ„É°„Éº„Ç∏Èáè„ÇíÊ±∫„ÇÅ„Çã„Å¥„Çá„Çì
            if (effect.name === '„Ç¢„Ç∑„ÉÉ„Éâ') {
                damage = 1; 
            } else if (effect.name === '„Ç§„É´„Éç„Çπ') {
                damage = 2;
            } else if (effect.name === '„Éù„Ç§„Ç∫„É≥') {
                damage = 1;
            }
            // ‰ªñ„ÅÆÁä∂ÊÖãÁï∞Â∏∏„ÇÇ„ÄÅ„Åì„Åì„Å´„ÉÄ„É°„Éº„Ç∏Ë®≠ÂÆö„ÇíËøΩÂä†„Åß„Åç„Çã„Å¥„Çá„ÇìÔºÅ

            if (damage > 0) {
                card.hp -= damage;
                addLog(getFormattedText('log_status_damage', { rank: card.rank, effect: effect.name, damage: damage }));
            }
        });

        if (card.hp <= 0) {
            if (state.player.field.includes(card)) {
                const idx = state.player.field.indexOf(card);
                state.player.field[idx] = null;
                state.player.grave++;
                state.opponent.points++;
                addLog(getFormattedText('log_player_card_destroyed', { rank: card.rank }));
            } else if (state.opponent.field.includes(card)) {
                const idx = state.opponent.field.indexOf(card);
                state.opponent.field[idx] = null;
                state.opponent.grave++;
                state.player.points++;
                addLog(getFormattedText('log_target_destroyed', { rank: card.rank }));
            }
        }
    });

    addLog("‚ñ≤ Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØÁµÇ‰∫Ü ‚ñ≤");
    render(); 
    checkWin();
    if (callback) {
        callback();
    }
}


const languageData = {
    en: {
        'adventure_battle': 'ADVENTURE / BATTLE',
        'deck_editor': 'DECK EDITOR (100 Slots)',
        'card_collection': 'CARD COLLECTION',
        'game_settings': 'GAME SETTINGS',
        'select_challenge': 'SELECT YOUR CHALLENGE',
        'vs_random_ai': 'VS RANDOM AI',
        'back_to_title': 'BACK TO TITLE',
        'settings': 'SETTINGS',
        'language_toggle': 'LANGUAGE: English',
        'sound_settings': 'BGM / SE',
        'collection': 'COLLECTION',
        'choose_deck_slot': 'CHOOSE DECK SLOT',
        'deck_editor_title': 'DECK EDITOR',
        'card_pool': 'CARD POOL',
        'deck_count_label': 'DECK',
        'save_exit': 'SAVE & EXIT',
        'cancel': 'CANCEL',
        // Alerts & Prompts
        'deck_30_cards_max': 'Deck cannot exceed 30 cards.',
        'same_card_2_max': 'Cannot have more than 2 of the same card.',
        'deck_must_be_30': 'Deck must have exactly 30 cards. Current count: ',
        'deck_not_saved': 'No deck saved in this slot.',
        'deck_not_30': 'This deck does not have 30 cards. (Current: ',
        'prompt_deck_name': 'Name:',
        // Game Over
        'win_message': 'YOU WIN!',
        'lose_message': 'YOU LOSE...',
        'draw_message': 'DRAW',
        // Game Logs
        'log_status_applied': '[${rank}] is now affected by [${effect}]!',
        'log_status_damage': '[${rank}] takes ${damage} damage from [${effect}].',
        'log_status_ended': 'The [${effect}] on [${rank}] has worn off.',
        'log_support_card_not_in_battle': 'Cannot use support cards now.',
        'log_use_2draw': 'Used [2DRAW]! Drew 2 cards!',
        'log_use_3draw': 'Used [3DRAW]! Drew 3 cards!',
        'log_use_4draw': 'Used [4DRAW]! Drew 4 cards!',
        'log_use_handexchange': 'Used [HANDEXCHANGE]! Exchanged hand with deck!',
        'log_use_boostpower': 'Used [BOOSTPOWER]! Choose a friendly front-row monster to boost!',
        'log_select_boost_target': 'Select a friendly front-row monster to boost its power!',
        'log_boost_success': 'Boosted [${rank}]! (+1 Power)',
        'log_boost_max_power': '[${rank}] is already at max power!',
        'log_use_loosepower': 'Used [LOOSEPOWER]! Choose an opponent\'s front-row monster to remove power!',
        'log_select_loose_target': 'Select an opponent\'s front-row monster to remove its power!',
        'log_loose_success': 'Removed 1 power from [${rank}]!',
        'log_use_attackup': 'Used [ATTACKUP]! Your vanguard attack power +3 this turn!',
        'log_use_attackdown': 'Used [ATTACKDOWN]! Opponent\'s vanguard attack power -3 this turn!',
        'log_attack_up_applied': 'Your [${rank}] receives +3 Attack from ATTACKUP!',
        'log_attack_down_applied': 'Opponent\'s [${rank}] receives -3 Attack from ATTACKDOWN!',
        'log_use_opponentcall': 'Used [OPPONENTCALL]! Select an opponent\'s back-row card to move to the front!',
        'log_use_selfmove': 'Used [SELFMOVE]! Select your back-row card to move to the front!',
        'log_front_row_full': 'Front row is full. Cannot use this card.',
        'log_opponentcall_success': 'Opponent\'s [${rank}] moved to the front row!',
        'log_selfmove_success': 'Your [${rank}] moved to the front row!',
        'log_no_back_row_cards': 'No back-row cards to move.',

        'log_deck_empty': 'Deck is empty!',
        'log_use_heal': 'Used [HEAL]! Choose a card to heal!',
        'log_use_skip': 'Used [SKIP]! Skipping opponent\'s turn!',
        'log_support_card_not_on_place': 'Cannot place support cards during placement phase.',
        'log_must_press_attack_button': 'To attack, press the "Attack" button and select a target!',
        'log_select_unit_from_hand': 'Select a unit card from your hand to place.',
        'log_support_card_no_place': 'Support cards cannot be placed on the field.',
        'log_card_placed': 'Placed ${rank}.',
        'log_only_unit_can_be_healed': 'Only unit cards can be healed.',
        'log_heal_success': 'Healed ${rank} for 3 HP! (Current HP: ${hp})',
        'log_card_returned_to_hand': 'Returned ${rank} to hand.',
        'log_power_injected': 'Injected power into ${rank}.',
        'log_select_card_then_attack': 'To start an attack, first select your card and press the "Attack" button!',
        'log_cannot_attack_from_back_row': 'Cannot attack with a card from the back row!',
        'log_invalid_attack_target_position': '[${rank}] is in a position that cannot be attacked!',
        'log_attack_start': 'Attack by [${rank}] begins!',
        'log_attack_fail_no_power': '...Attack failed due to insufficient power.',
        'log_card_already_attacked': '[${rank}] is already tired (has attacked).',
        'log_attack_damage': 'Dealt ${totalA} damage to opponent\'s [${targetRank}]!',
        'log_target_destroyed': 'Shattered [${rank}] with tremendous sound magic!',
        'log_opponent_cards_flipped': 'Opponent\'s cards are revealed!',
        'log_placement_complete_player_turn': 'Placement complete. Your turn begins.',
        'log_placement_complete_opponent_turn': 'Placement complete. Opponent\'s battle turn begins.',
        'log_turn_end': 'Turn ended.',
        'log_score_summary': '--- (You: ${playerScore}/5 | Opp: ${opponentScore}/5) ---',
        'log_opponent_placing_facedown': 'Opponent is placing cards face down.',
        'log_opponent_placement_done': 'Opponent\'s placement is complete. Moving to your placement.',
        'log_skip_effect': 'Opponent\'s turn was skipped due to [SKIP] effect!',
        'log_player_drew_card': 'You drew a card.',
        'log_player_deck_empty': 'Your deck is empty!',
        'log_opponent_turn_end': 'Opponent\'s turn ended. Your turn begins.',
        'log_opponent_turn_start': 'Opponent\'s turn started!',
        'log_opponent_drew_card': 'Opponent drew a card.',
        'log_opponent_deck_empty': 'Opponent\'s deck is empty!',
        'log_opponent_placed_card': 'Opponent placed [${rank}].',
        'log_opponent_did_not_place': 'Opponent did not place a card..',
        'log_opponent_injected_power': 'Opponent injected power into [${rank}]! (Current: ${p_a}/${p_req})',
        'log_opponent_did_not_inject': 'Opponent did not inject power into a card..',
        'log_opponent_attack': 'Opponent\'s [${oppCardRank}] attacks your [${targetCardRank}] for ${totalOppA} damage!',
        'log_player_card_destroyed': 'Your [${rank}] has been defeated!',
        'log_opponent_no_target': 'Opponent\'s [${rank}] had no target to attack!',
        'log_opponent_attack_fail_no_power': 'Opponent\'s [${rank}] could not attack due to insufficient power..',
        'log_field_rotating': 'The field is rotating clockwise.',
        'log_win': '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ YOU WIN! ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ',
        'log_lose': '------- YOU LOSE... -------',
        'log_draw': '======= DRAW =======',
        'log_player_mulligan': 'Your initial hand had no unit cards, so you will redraw.',
        'log_player_mulligan_warning': 'Warning: Player has reached the mulligan limit. Your deck may have too few unit cards.',
        'log_opponent_mulligan': 'Opponent\'s initial hand had no unit cards, so they will redraw.',
        'log_opponent_mulligan_warning': 'Warning: Opponent has reached the mulligan limit. Their deck may have too few unit cards.',
        'log_select_attack_target': 'Select a target to attack with [${rank}]!',
        'log_special_not_implemented': 'Special move is not yet implemented!',
        'log_player_first': 'You are going first.',
        'log_opponent_first': 'The opponent is going first.',
        'log_select_card_to_copy_attack_from': 'Select an opponent\'s front-line card to copy its attack.',
        'log_select_target_for_copied_attack': 'Select a target for the copied attack.',
        'log_copied_attack': 'Karikopi copied ${copiedRank}\'s attack!',
        'log_kariheal_initiate': 'Kari-Heal activated! Select a friendly front-line card to fully heal.',
        'log_kariheal_success': '[${rank}] fully healed by Kari-Heal!',
        'log_kariheal_no_targets': 'There are no damaged friendly front-line monsters to heal.',
        'log_kariheal_target_full_hp': 'This monster is already at full HP.',
        'log_special_already_used': 'This card has already used its special ability this turn.',
    },
    ja: {
        'adventure_battle': 'ADVENTURE / BATTLE',
        'deck_editor': 'DECK EDITOR (100 Slots)',
        'card_collection': 'CARD COLLECTION',
        'game_settings': 'GAME SETTINGS',
        'select_challenge': 'SELECT YOUR CHALLENGE',
        'vs_random_ai': 'VS RANDOM AI',
        'back_to_title': '„Çø„Ç§„Éà„É´„Å∏Êàª„Çã',
        'settings': 'SETTINGS',
        'language_toggle': 'LANGUAGE: Êó•Êú¨Ë™û',
        'sound_settings': 'BGM / SE',
        'collection': 'COLLECTION',
        'choose_deck_slot': 'CHOOSE DECK SLOT',
        'deck_editor_title': 'DECK EDITOR',
        'card_pool': 'CARD POOL',
        'deck_count_label': 'DECK',
        'save_exit': 'SAVE & EXIT',
        'cancel': 'CANCEL',
        // Alerts & Prompts
        'deck_30_cards_max': '„Éá„ÉÉ„Ç≠„ÅØ30Êûö„Åæ„Åß„Åß„Åô„ÄÇ',
        'same_card_2_max': 'Âêå„Åò„Ç´„Éº„Éâ„ÅØ2Êûö„Åæ„Åß„Åó„ÅãÂÖ•„Çå„Çâ„Çå„Åæ„Åõ„Çì„ÄÇ',
        'deck_must_be_30': '„Éá„ÉÉ„Ç≠„ÅØ„Å°„Çá„ÅÜ„Å©30Êûö„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁèæÂú®„ÅÆÊûöÊï∞: ',
        'deck_not_saved': '„Åì„ÅÆ„Çπ„É≠„ÉÉ„Éà„Å´„ÅØ„Éá„ÉÉ„Ç≠„Åå‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ',
        'deck_not_30': '„Åì„ÅÆ„Éá„ÉÉ„Ç≠„ÅØ30Êûö„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ(ÁèæÂú®: ',
        'prompt_deck_name': 'Name:',
        // Game Over
        'win_message': '„ÅÇ„Å™„Åü„ÅÆÂãùÂà©ÔºÅ',
        'lose_message': '„ÅÇ„Å™„Åü„ÅÆÊïóÂåó...',
        'draw_message': 'Âºï„ÅçÂàÜ„Åë',
        // Game Logs
        'log_status_applied': '„Äê${rank}„Äë„ÅØ[${effect}]Áä∂ÊÖã„Å´„Å™„Å£„ÅüÔºÅ',
        'log_status_damage': '„Äê${rank}„Äë„ÅØ[${effect}]„Åß ${damage} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åü„ÄÇ',
        'log_status_ended': '„Äê${effect}„Äë„ÅÆ[${rank}]Áä∂ÊÖã„ÅåËß£Èô§„Åï„Çå„Åü„ÄÇ',
        'log_support_card_not_in_battle': '„Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„Çí‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ',
        'log_use_2draw': '„Äê2DRAW„Äë„Çí‰ΩøÁî®ÔºÅ„Ç´„Éº„Éâ„Çí2ÊûöÂºï„ÅÑ„Åü„ÄÇÔºÅ',
        'log_use_3draw': '„Äê3DRAW„Äë„Çí‰ΩøÁî®ÔºÅ„Ç´„Éº„Éâ„Çí3ÊûöÂºï„ÅÑ„Åü„ÄÇÔºÅ',
        'log_use_4draw': '„Äê4DRAW„Äë„Çí‰ΩøÁî®ÔºÅ„Ç´„Éº„Éâ„Çí4ÊûöÂºï„ÅÑ„Åü„ÄÇÔºÅ',
        'log_use_handexchange': '„ÄêÊâãÊú≠ÂÖ•„ÇåÊõø„Åà„Äë„Çí‰ΩøÁî®ÔºÅÊâãÊú≠„ÇíÂÖ®„Å¶Â±±Êú≠„Å´Êàª„Åó„ÄÅÂºï„ÅçÁõ¥„Åó„Åü„ÄÇÔºÅ',
        'log_use_boostpower': '„Äê„Éñ„Éº„Çπ„Éà„Éë„ÉØ„Éº„Äë„Çí‰ΩøÁî®ÔºÅËá™ÂàÜ„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏„Çì„Åß„Éë„ÉØ„Éº„Çí‰ªò‰∏é„Åó„Å¶„Åª„Åó„ÅÑ„Å¥„Çá„ÇìÔºÅ',
        'log_select_boost_target': '„Éë„ÉØ„Éº„Çí„Éñ„Éº„Çπ„Éà„Åô„ÇãËá™ÂàÜ„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
        'log_boost_success': '„Äê${rank}„Äë„Å´„Éë„ÉØ„Éº„Çí1‰ªò‰∏é„Åó„Åü„Å¥„Çá„ÇìÔºÅ',
        'log_boost_max_power': '„Äê${rank}„Äë„ÅØ„Åô„Åß„Å´ÊúÄÂ§ß„Éë„ÉØ„Éº„Å†„Å¥„Çá„ÇìÔºÅ',
        'log_use_loosepower': '„Äê„É´„Éº„Ç∫„Éë„ÉØ„Éº„Äë„Çí‰ΩøÁî®ÔºÅÁõ∏Êâã„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏„Çì„Åß„Éë„ÉØ„Éº„ÇíÊ∂à„Åó„Å¶„Åª„Åó„ÅÑ„Å¥„Çá„ÇìÔºÅ',
        'log_select_loose_target': '„Éë„ÉØ„Éº„ÇíÊ∂à„ÅôÁõ∏Êâã„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ',
        'log_loose_success': '„Äê${rank}„Äë„ÅÆ„Éë„ÉØ„Éº„Çí1Ê∂à„Åó„Åü„Å¥„Çá„ÇìÔºÅ',
        'log_use_attackup': '„ÄêÊîªÊíÉÂäõÂ¢óÂä†„Äë„Çí‰ΩøÁî®ÔºÅ‰ªä„Çø„Éº„É≥„ÄÅ„ÅÇ„Å™„Åü„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÅÆÊîªÊíÉÂäõ+3ÔºÅ',
        'log_use_attackdown': '„ÄêÊîªÊíÉÂäõÊ∏õÂ∞ë„Äë„Çí‰ΩøÁî®ÔºÅÊ¨°„Çø„Éº„É≥„ÄÅÁõ∏Êâã„ÅÆÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„ÅÆÊîªÊíÉÂäõ-3ÔºÅ',
        'log_attack_up_applied': '„ÅÇ„Å™„Åü„ÅÆ„Äê${rank}„Äë„ÅåÊîªÊíÉÂäõÂ¢óÂä†„Å´„Çà„ÇäÊîªÊíÉÂäõ+3ÔºÅ',
        'log_attack_down_applied': 'Áõ∏Êâã„ÅÆ„Äê${rank}„Äë„ÅåÊîªÊíÉÂäõÊ∏õÂ∞ë„Å´„Çà„ÇäÊîªÊíÉÂäõ-3ÔºÅ',
        'log_use_opponentcall': '„ÄêÁõ∏ÊâãÂëº„Å≥Âá∫„Åó„Äë„Çí‰ΩøÁî®ÔºÅÁõ∏Êâã„ÅÆÂæåË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏„Çì„ÅßÂâçË°õ„Å´ÁßªÂãï„Åï„Åõ„Çã„Å¥„Çá„ÇìÔºÅ',
        'log_use_selfmove': '„ÄêËá™ÂàÜÁßªÂãï„Äë„Çí‰ΩøÁî®ÔºÅËá™ÂàÜ„ÅÆÂæåË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏„Çì„ÅßÂâçË°õ„Å´ÁßªÂãï„Åï„Åõ„Çã„Å¥„Çá„ÇìÔºÅ',
        'log_front_row_full': 'ÂâçË°õ„Åå„ÅÑ„Å£„Å±„ÅÑ„Å™„ÅÆ„Åß„ÄÅ„Åì„ÅÆ„Ç´„Éº„Éâ„ÅØ‰Ωø„Åà„Å™„ÅÑ„Å¥„Çá„Çì„ÄÇ',
        'log_opponentcall_success': 'Áõ∏Êâã„ÅÆ„Äê${rank}„Äë„ÇíÂâçË°õ„Å´ÁßªÂãï„Åï„Åõ„Åü„Å¥„Çá„ÇìÔºÅ',
        'log_selfmove_success': 'Ëá™ÂàÜ„ÅÆ„Äê${rank}„Äë„ÇíÂâçË°õ„Å´ÁßªÂãï„Åï„Åõ„Åü„Å¥„Çá„ÇìÔºÅ',
        'log_no_back_row_cards': 'ÁßªÂãï„Åß„Åç„ÇãÂæåË°õ„Ç´„Éº„Éâ„Åå„Å™„ÅÑ„Å¥„Çá„Çì„ÄÇ',
        'log_deck_empty': 'Â±±Êú≠„ÅåÁ©∫„Å†„ÄÇÔºÅ',
        'log_use_heal': '„ÄêHEAL„Äë„Çí‰ΩøÁî®ÔºÅÂõûÂæ©„Åï„Åõ„ÇãËá™ÂàÜ„ÅÆ„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åª„Åó„ÅÑ„Å¥„Çá„ÇìÔºÅ',
        'log_use_skip': '„ÄêSKIP„Äë„Çí‰ΩøÁî®ÔºÅÁõ∏Êâã„ÅÆ„Çø„Éº„É≥„Çí„Çπ„Ç≠„ÉÉ„Éó„Åô„Çã„ÄÇÔºÅ',
        'log_support_card_not_on_place': 'ÈÖçÁΩÆ‰∏≠„ÅØ„Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„Çí‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ',
        'log_must_press_attack_button': 'ÊîªÊíÉ„Å´„ÅØ„ÄåÊîªÊíÉ„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶ÂØæË±°„ÇíÈÅ∏Êäû„Åô„Çã„ÄÇÔºÅ',
        'log_select_unit_from_hand': 'ÊâãÊú≠„Åã„ÇâÈÖçÁΩÆ„Åó„Åü„ÅÑ„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        'log_support_card_no_place': '„Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„ÅØÂ†¥„Å´Âá∫„Åõ„Åæ„Åõ„Çì„ÄÇ',
        'log_card_placed': '${rank}„ÇíÈÖçÁΩÆ„Åó„Åæ„Åó„Åü„ÄÇ',
        'log_only_unit_can_be_healed': '„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅÆ„ÅøÂõûÂæ©„Åß„Åç„Åæ„Åô„ÄÇ',
        'log_heal_success': '„Äê${rank}„Äë„ÅÆHP„Åå3ÂõûÂæ©„Åó„ÅüÔºÅ (ÁèæÂú®HP: ${hp})',
        'log_card_returned_to_hand': '${rank}„ÇíÊâãÊú≠„Å´Êàª„Åó„Åæ„Åó„Åü„ÄÇ',
        'log_power_injected': '${rank}„Å´„Éë„ÉØ„Éº„ÇíÊ≥®ÂÖ•„ÄÇ',
        'log_select_card_then_attack': 'ÊîªÊíÉ„ÇíÈñãÂßã„Åô„Çã„Å´„ÅØ„ÄÅ„Åæ„ÅöËá™ÂàÜ„ÅÆ„Ç´„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„ÄåÊîªÊíÉ„Äç„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÔºÅ',
        'log_cannot_attack_from_back_row': 'ÂæåÂàó„ÅÆ„Ç´„Éº„Éâ„Åß„ÅØÊîªÊíÉ„Åß„Åç„Åæ„Åõ„ÇìÔºÅ',
        'log_invalid_attack_target_position': '„Äê${rank}„Äë„ÅØÊîªÊíÉ„Åß„Åç„Å™„ÅÑ‰ΩçÁΩÆ„Å†„ÄÇÔºÅ',
        'log_attack_start': '„Äê${rank}„Äë„ÅÆÊîªÊíÉ„ÇíÈñãÂßãÔºÅ',
        'log_attack_fail_no_power': '‚Ä¶‚Ä¶„Éë„ÉØ„Éº‰∏çË∂≥„ÅßÊîªÊíÉ„Åå‰∏çÁô∫„Å´ÁµÇ„Çè„Å£„Åü„ÄÇ„ÄÇ',
        'log_card_already_attacked': '„Äê${rank}„Äë„ÅØ„ÇÇ„ÅÜ„ÅäÁñ≤„Çå„Å†„ÄÇÔºàÊîªÊíÉÊ∏à„ÅøÔºâ„ÄÇ',
        'log_attack_damage': 'Áõ∏Êâã„ÅÆ„Äê${targetRank}„Äë„Å´ ${totalA} „ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Åü„ÄÇÔºÅ',
        'log_target_destroyed': '‚òÖÂáÑ„Åæ„Åò„ÅÑÈü≥È≠îÊ≥ï„Åß„Äê${rank}„Äë„ÇíÁ≤âÁ†ï„Åó„Åü„ÄÇÔºÅ',
        'log_opponent_cards_flipped': 'Áõ∏Êâã„ÅÆ„Ç´„Éº„Éâ„Åå„Ç™„Éº„Éó„É≥„Åï„Çå„ÇãÔºÅ',
        'log_placement_complete_player_turn': 'ÈÖçÁΩÆÂÆå‰∫Ü„ÄÇ„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ',
        'log_placement_complete_opponent_turn': 'ÈÖçÁΩÆÂÆå‰∫Ü„ÄÇÁõ∏Êâã„ÅÆ„Éê„Éà„É´„Çø„Éº„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ',
        'log_turn_end': '„Çø„Éº„É≥ÁµÇ‰∫Ü„ÄÇ',
        'log_score_summary': '--- (Ëá™ÂàÜ: ${playerScore}/5 | Áõ∏Êâã: ${opponentScore}/5) ---',
        'log_opponent_placing_facedown': 'Áõ∏Êâã„Åå„Ç´„Éº„Éâ„ÇíË£èÂêë„Åç„ÅßÈÖçÁΩÆ„Åó„Åæ„Åô„ÄÇ',
        'log_opponent_placement_done': 'Áõ∏Êâã„ÅÆÈÖçÁΩÆÂÆå‰∫Ü„ÄÇ„ÅÇ„Å™„Åü„ÅÆÈÖçÁΩÆ„Å´Áßª„Çä„Åæ„Åô„ÄÇ',
        'log_skip_effect': '„ÄêSKIP„Äë„ÅÆÂäπÊûú„ÅßÁõ∏Êâã„ÅÆ„Çø„Éº„É≥„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„Åü„ÄÇÔºÅ',
        'log_player_drew_card': '„ÅÇ„Å™„Åü„ÅØ„Ç´„Éº„Éâ„Çí1ÊûöÂºï„ÅÑ„Åü„ÄÇ',
        'log_player_deck_empty': '„ÅÇ„Å™„Åü„ÅÆÂ±±Êú≠„ÅØ„ÇÇ„ÅÜ„Å™„ÅÑÔºÅ',
        'log_opponent_turn_end': 'Áõ∏Êâã„ÅÆ„Çø„Éº„É≥ÁµÇ‰∫Ü„ÄÇ„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥ÈñãÂßã„ÄÇ',
        'log_opponent_turn_start': 'Áõ∏Êâã„ÅÆË°åÂãï„ÇíÈñãÂßã„Åó„Åü„ÄÇÔºÅ',
        'log_opponent_drew_card': 'Áõ∏Êâã„ÅØ„Ç´„Éº„Éâ„Çí1ÊûöÂºï„ÅÑ„Åü„ÄÇ',
        'log_opponent_deck_empty': 'Áõ∏Êâã„ÅÆÂ±±Êú≠„ÅØ„ÇÇ„ÅÜ„Å™„ÅÑÔºÅ',
        'log_opponent_placed_card': 'Áõ∏Êâã„ÅØ„Äê${rank}„Äë„ÇíÈÖçÁΩÆ„Åó„Åü„ÄÇÔºÅ',
        'log_opponent_did_not_place': 'Áõ∏Êâã„ÅØ„Ç´„Éº„Éâ„ÇíÈÖçÁΩÆ„Åó„Å™„Åã„Å£„Åü„ÄÇ„ÄÇ',
        'log_opponent_injected_power': 'Áõ∏Êâã„ÅØ„Äê${rank}„Äë„Å´„Éë„ÉØ„Éº„ÇíÊ≥®ÂÖ•„Åó„Åü„ÄÇÔºÅ (ÁèæÂú®: ${p_a}/${p_req})',
        'log_opponent_did_not_inject': 'Áõ∏Êâã„ÅØ„Ç´„Éº„Éâ„Å´„Éë„ÉØ„Éº„ÇíÊ≥®ÂÖ•„Åó„Å™„Åã„Å£„Åü„ÄÇ„ÄÇ',
        'log_opponent_attack': 'Áõ∏Êâã„ÅÆ„Äê${oppCardRank}„Äë„Åå„ÅÇ„Å™„Åü„ÅÆ„Äê${targetCardRank}„Äë„Å´ ${totalOppA} „ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Åü„ÄÇÔºÅ',
        'log_player_card_destroyed': '„ÅÇ„Å™„Åü„ÅÆ„Äê${rank}„Äë„ÅØÊíÉÁ†¥„Åï„Çå„Åü„ÄÇÔºÅ',
        'log_opponent_no_target': 'Áõ∏Êâã„ÅÆ„Äê${rank}„Äë„ÅØÊîªÊíÉÂØæË±°„Åå„ÅÑ„Å™„Åã„Å£„Åü„ÄÇÔºÅ',
        'log_opponent_attack_fail_no_power': 'Áõ∏Êâã„ÅÆ„Äê${rank}„Äë„ÅØ„Éë„ÉØ„Éº„ÅåË∂≥„Çä„Å™„ÅÑ„ÅÆ„ÅßÊîªÊíÉ„Åß„Åç„Å™„Åã„Å£„Åü„ÄÇ„ÄÇ',
        'log_field_rotating': '„Éï„Ç£„Éº„É´„Éâ„ÅåÊôÇË®àÂõû„Çä„Å´ÂõûËª¢„Åó„Åæ„Åô„ÄÇ',
        'log_win': '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ „ÅÇ„Å™„Åü„ÅÆÂãùÂà©„Åß„ÅôÔºÅ ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ',
        'log_lose': '------- „ÅÇ„Å™„Åü„ÅÆÊïóÂåó„Åß„Åô... -------',
        'log_draw': '======= Âºï„ÅçÂàÜ„Åë„Åß„Åô =======',
        'log_player_mulligan': '„ÅÇ„Å™„Åü„ÅÆÂàùÊúüÊâãÊú≠„Å´„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„Åå„Å™„Åã„Å£„Åü„ÅÆ„Åß„ÄÅÂºï„ÅçÁõ¥„Åó„Åæ„Åô„ÄÇ',
        'log_player_mulligan_warning': 'Ë≠¶Âëä: „Éó„É¨„Ç§„É§„Éº„ÅÆ„Éû„É™„Ç¨„É≥‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ„Éá„ÉÉ„Ç≠„Å´„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅåÂ∞ë„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ',
        'log_opponent_mulligan': 'Áõ∏Êâã„ÅÆÂàùÊúüÊâãÊú≠„Å´„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„Åå„Å™„Åã„Å£„Åü„ÅÆ„Åß„ÄÅÂºï„ÅçÁõ¥„Åó„Åæ„Åô„ÄÇ',
        'log_opponent_mulligan_warning': 'Ë≠¶Âëä: Áõ∏Êâã„ÅÆ„Éû„É™„Ç¨„É≥‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ„Éá„ÉÉ„Ç≠„Å´„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅåÂ∞ë„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ',
        'log_select_attack_target': '„Äê${rank}„Äë„ÅßÊîªÊíÉÂØæË±°„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÔºÅ',
        'log_special_not_implemented': 'ÁâπÂà•ÊäÄ„ÅØ„Åæ„Å†ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„ÄÇÔºÅ',
        'log_player_first': '„ÅÇ„Å™„Åü„ÅåÂÖàË°å„Åß„Åô„ÄÇ',
        'log_opponent_first': 'Áõ∏Êâã„ÅåÂÖàË°å„Åß„Åô„ÄÇ',
        'log_select_card_to_copy_attack_from': 'ÊîªÊíÉ„Çí„Ç≥„Éî„Éº„Åô„ÇãÁõ∏Êâã„ÅÆÂâçË°õ„Ç´„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        'log_select_target_for_copied_attack': '„Ç≥„Éî„Éº„Åó„ÅüÊîªÊíÉ„ÅÆÂØæË±°„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        'log_copied_attack': '„Ç´„É™„Ç≥„Éî„Éº„ÅØ${copiedRank}„ÅÆÊîªÊíÉ„Çí„Ç≥„Éî„Éº„Åó„ÅüÔºÅ',
        'log_kariheal_initiate': '„Ç´„É™„Éí„Éº„É´„Çí‰ΩøÁî®ÔºÅÂõûÂæ©„Åï„Åõ„ÇãËá™ÂàÜ„ÅÆÂâçË°õ„Ç´„Éº„Éâ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ',
        'log_kariheal_success': '„Äê${rank}„Äë„Åå„Ç´„É™„Éí„Éº„É´„ÅßÂÖ®ÂõûÂæ©„Åó„ÅüÔºÅ',
        'log_kariheal_no_targets': 'ÂõûÂæ©„Åß„Åç„ÇãÂâçË°õ„É¢„É≥„Çπ„Çø„Éº„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ',
        'log_kariheal_target_full_hp': '„Åì„ÅÆ„É¢„É≥„Çπ„Çø„Éº„ÅØ„Åô„Åß„Å´HP„ÅåÊ∫Ä„Çø„É≥„Åß„Åô„ÄÇ',
        'log_special_already_used': '„Åì„ÅÆ„Ç´„Éº„Éâ„ÅÆÁâπÊÆäËÉΩÂäõ„ÅØ„Åô„Åß„Å´‰ΩøÁî®Ê∏à„Åø„Åß„Åô„ÄÇ',
    }
};

function getText(key) {
    // Default to Japanese if state or language isn't set yet
    const lang = state ? state.language : 'ja';
    return languageData[lang][key] || `(no text for ${key})`;
}

function getFormattedText(key, params = {}) {
    let text = getText(key);
    for (const p_key in params) {
        // Use a regular expression to replace all occurrences of the placeholder
        const regex = new RegExp('\\$\\{' + p_key + '\\}', 'g');
        text = text.replace(regex, params[p_key]);
    }
    return text;
}

function updateUIText() {
    document.querySelectorAll('[data-lang-key]').forEach(el => {
        const key = el.dataset.langKey;
        el.innerHTML = getText(key);
    });
     // Also update dynamic parts if needed, e.g., titles of screens
    document.getElementById('editor-title').textContent = getText('deck_editor_title');
}

function toggleLanguage() {
    state.language = (state.language === 'ja') ? 'en' : 'ja';
    updateUIText();
}

const SUITS = ['fire', 'water', 'wind', 'earth'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const SUPPORTS = ['2DRAW','HEAL','SKIP','3DRAW','4DRAW','HANDEXCHANGE','BOOSTPOWER','LOOSEPOWER','ATTACKUP','ATTACKDOWN','OPPONENTCALL','SELFMOVE'];

const RANK_VALUES = { 
    'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,
    '2DRAW': 0, 'HEAL': 0, 'SKIP': 0, '3DRAW': 0, '4DRAW': 0, 'HANDEXCHANGE': 0, 'BOOSTPOWER': 0, 'LOOSEPOWER': 0 
};

// Helper to extract power from monsterName (displayName)
function getMonsterPowerFromName(monsterName) {
    let power = monsterName;
    // Remove size prefix (using sorted array)
    for (const sizePrefix of sortedSizes) {
        if (power.startsWith(sizePrefix)) {
            power = power.substring(sizePrefix.length);
            break;
        }
    }
    // Remove species suffix (using sorted array)
    for (const specieSuffix of sortedSpecies) {
        if (power.endsWith(specieSuffix)) {
            power = power.substring(0, power.length - specieSuffix.length);
            break;
        }
    }
    return power;
}

const starPowers = ["„Éí„Éº„É´", "„ÉÅ„É£„Éº„É†", "„Ç§„Éü„ÉÜ„Ç§„Éà", "„ÉÅ„Çß„É≥„Ç∏", "„Éó„É¨„Ç§", "„Ç∞„É´„Éº„Éó", "„Çπ„É™„Éº„Éó", "„Ç§„É¨„Ç§„Çπ", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà", "„Éï„Çß„Ç§„ÇØ", "„Ç™„Éº„É´"];
const emotionPowers = ["„Ç¢„É≥„Ç∞„É™„Éº", "„Ç∏„Éß„Ç§", "„ÇΩ„É≠„Éº", "„Éó„É¨„Ç∑„É£„Éº", "„É©„Éñ", "„Éò„Ç§„Éà", "„Éï„Ç£„Ç¢„Éº", "„Çµ„Éó„É©„Ç§„Ç∫", "„Ç¶„Ç©„É≥„Éà"];

const thematicColorMap = {
    // Direct power names
    "„É©„Ç§„Éà": "color-light",
    "„ÉÄ„Éº„ÇØ": "color-dark",
    "„Éï„Ç°„Ç§„É§„Éº": "color-fire",
    "„Ç¶„Ç©„Éº„Çø„Éº": "color-water",
    "„É©„É≥„Éâ": "color-land",
    "„Ç¶„Ç£„É≥„Éâ": "color-wind",
    "„É°„Çø„É´": "color-metal",
    "„Éû„Ç∏„ÉÉ„ÇØ": "color-magic",
    "„É°„É≠„Éá„Ç£„Éº": "color-melody",
    "„Éû„Ç¶„É≥„ÉÜ„É≥": "color-mountain",
    "„Éç„Ç∂„Éº": "color-nether",
    "„Ç¢„Éê„É≥„ÉÄ„É≥„Éâ": "color-abandoned",
    "„Éù„Ç§„Ç∫„É≥": "color-poison",
    "„Ç¢„Ç§„Çπ": "color-ice",
    "„Éë„É©„É™„Ç∑„Çπ": "color-paralysis",
    "„Ç§„É´„Éç„Çπ": "color-illness",
    "„Ç¢„Ç∑„ÉÉ„Éâ": "color-acid",

    // Special categories
    "Star": "color-star", // for "Star" type
    "Emotion": "color-emotion", // for "Emotion" type

    // Two-color/pattern powers
    "„ÇØ„É™„Çπ„Çø„É´": "color-crystal",
    "„ÉÄ„Éº„ÉÜ„Ç£": "color-dirty",
    "„Éñ„É©„ÉÉ„Éâ": "color-blood",
    "„ÉÅ„Ç®": "color-chie",
    "„Éó„É©„É≥„Éà": "color-plant",
    "Support": "color-support" // For standard support cards (white)
    // "Ê®°ÊßòÁ≥ª" is not directly mapped, might be a generic pattern
};

function getThematicColorClass(thematicLabel) {
    return thematicColorMap[thematicLabel] || "color-default"; // Fallback
}

function getThematicSuitLabel(card) {
    if (card.monsterName) { // Monster card
        const monsterPower = getMonsterPowerFromName(card.displayName);
        if (starPowers.includes(monsterPower)) {
            return "Êòü"; // Êòü„Éû„Éº„ÇØ
        }
        if (emotionPowers.includes(monsterPower)) {
            return "üòä"; // „Éã„Ç≥„Éã„Ç≥„Éû„Éº„ÇØ
        }
        return monsterPower; // Other powers
    } else { // Standard (trump or support) card
        if (card.isSupport) {
            return "Support"; // Special label for support cards
        }
        return "Êòü"; // Default for standard trump cards
    }
}

// Helper to determine card owner
function getCardOwner(card) {
    if (!card) return null;
    // Check if the card is in the player's field
    if (state.player.field.some(fieldCard => fieldCard && fieldCard.id === card.id)) {
        return "player";
    }
    // Check if the card is in the opponent's field
    if (state.opponent.field.some(fieldCard => fieldCard && fieldCard.id === card.id)) {
        return "opponent";
    }
    return null; // Card is not on any field
}

// „Éò„É´„Éë„ÉºÈñ¢Êï∞: „É¢„É≥„Çπ„Çø„ÉºÂêç„Åã„ÇâÂøÖË¶Å„Éë„ÉØ„Éº„ÇíË®àÁÆó
function getRequiredPowerFromSize(monsterName) {
    if (monsterName.startsWith("Ë¶öÈÜí„É¢„Éº„Éâ")) return 5;
    if (monsterName.startsWith("„É≠„Éú")) return 4;
    if (monsterName.startsWith("‰ºùË™¨„ÅÆ")) return 3;
    if (monsterName.startsWith("„Éè„Ç§")) return 2;
    // „Éü„Éã„ÄÅ„Éé„Éº„Éû„É´„ÄÅ„Ç∏„É£„Ç§„Ç¢„É≥„Éà
    return 1; 
}

class Card {
    constructor(suit, rank, type = 'unit', monsterName = null, options = {}) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.suit = suit;
        this.rank = rank;
        this.type = type;
        this.monsterName = monsterName; // Preserve original monster name
        this.displayName = monsterName || rank; // Use monsterName if provided, otherwise use rank
        this.isSupport = (type === 'support' || SUPPORTS.includes(rank)); // Determine isSupport first

        this.isTripleType = false;
        this.isDoubleType = false;
        this.sizeName = null;
        this.powerName = null;
        this.raceName = null;
        this.statusEffects = []; // <--- Áä∂ÊÖãÁï∞Â∏∏„ÇíÊ†ºÁ¥ç„Åô„ÇãÈÖçÂàó

        // If it's a special card, its properties are defined entirely by the options.
        // Otherwise, calculate properties based on whether it's a generic monster or a regular trump card.
        if (options && options.specialAbility) {
            // This is a special card. The properties will be applied at the end by Object.assign.
            // We just need to set initial values so they exist.
            this.value = 0;
            this.requiredPower = 0;
        } else if (monsterName) { // Logic for generic monster cards
            const parts = extractMonsterParts(monsterName);
            this.sizeName = parts.sizeName;
            this.powerName = parts.powerName;
            this.raceName = parts.raceName;

            if (this.sizeName && this.powerName && this.raceName) {
                this.isTripleType = true;
                this.displayName = `${this.sizeName}\n${this.powerName}\n${this.raceName}`;
            }

            this.value = Math.floor(Math.random() * 10) + 1; // Random value 1-10
            this.requiredPower = getRequiredPowerFromSize(monsterName); // Calculate based on size
        } else { // Existing logic for regular trump cards
            this.value = RANK_VALUES[rank] || 0;
            this.isDoubleType = true;
            // Assign powerName based on suit
            switch (this.suit) {
                case 'fire': this.powerName = '„Éï„Ç°„Ç§„É§„Éº'; break;
                case 'water': this.powerName = '„Ç¶„Ç©„Éº„Çø„Éº'; break;
                case 'wind': this.powerName = '„Ç¶„Ç£„É≥„Éâ'; break;
                case 'earth': this.powerName = '„É©„É≥„Éâ'; break;
                default: this.powerName = ''; // Fallback for unknown suits
            }
            this.secondaryPowerName = "„Éó„É¨„Ç§";
            this.requiredPower = this.isSupport ? 0 : ((this.value <= 3) ? 1 : (this.value <= 6) ? 2 : (this.value <= 10) ? 3 : 4);
        }
        
        this.hp = this.value; this.maxHp = this.value;
        this.attachedPower = 0;
        
        Object.assign(this, options);
    }
}

let state = getInitialState(); // Initialize state when script loads

// Function to get the initial game state
function getInitialState() {
    return {
        language: 'ja',
        editIdx: 1, 
        editCards: [], 
        player: { hand: [], field: Array(6).fill(null), deck: [], grave: 0, power: 5, points: 0, attackedIds: [], usedSpecialAbilityIds: [], powerInjected: false, attackUpActive: false },
        opponent: { handCount: 5, field: Array(6).fill(null), deck: [], grave: 0, power: 5, points: 0, attackDownActive: false },
        selectedCard: null, 
        turn: 'player', 
        statusText: 'Ê∫ñÂÇôOK',
        canPlaceCard: false, 
        gameOver: false,
        isAttacking: false, // New state to indicate if player is in attack mode
        isOpponentInitialPlacement: false,
        isHealing: false, // New state to indicate if player is choosing a card to heal
        coinTossAttacker: null,
        coinTossTarget: null,
        isCopyingAttack: false,
        isSelectingCopyTarget: false,
        copiedAttackProperties: null,
        isHealingTargetSelection: false,
        isBoosting: false, // New state for Boost Power target selection
        isLoosing: false,  // New state for Loose Power target selection
        isOpponentCalling: false, // New state for Opponent Call target selection
        isSelfMoving: false, // New state for Self Move target selection
        sleepCheckQueue: [],
        isCheckingSleep: false,
        currentCoinTossHandler: null
    };
}

// Universal handler for the coin toss button
function handleCoinTossButtonClick() {
    if (state.currentCoinTossHandler) {
        state.currentCoinTossHandler();
    }
}

function handleKarikoinCoinToss() {
    const attacker = state.coinTossAttacker;
    const target = state.coinTossTarget;
    if (!attacker || !target) return;

    const btn = document.getElementById('cointoss-btn');
    btn.style.display = 'none'; // Hide button after click to prevent multiple clicks

    const resultDiv = document.getElementById('cointoss-result');
    const isHeads = Math.random() < 0.5;
    
    let damage = 0;
    if (isHeads) {
        damage = attacker.value; // value is 10 for Karikoin
        resultDiv.textContent = 'Ë°®ÔºÅ';
        addLog(`„Ç≥„Ç§„É≥„Éà„Çπ„ÅØË°®ÔºÅ ${attacker.rank}„Åå${target.rank}„Å´${damage}„ÉÄ„É°„Éº„Ç∏ÔºÅ`);
        target.hp -= damage;
    } else {
        damage = 0;
        resultDiv.textContent = 'Ë£è...';
        addLog(`„Ç≥„Ç§„É≥„Éà„Çπ„ÅØË£è... ${attacker.rank}„ÅÆÊîªÊíÉ„ÅØÂ§±Êïó„ÄÇ`);
    }

    state.player.attackedIds.push(attacker.id);

    if (target.hp <= 0) {
        const idx = state.opponent.field.indexOf(target);
        if (idx !== -1) {
            state.opponent.field[idx] = null;
            state.opponent.grave++;
            state.player.points++;
        }
        addLog(getFormattedText('log_target_destroyed', { rank: target.rank }));
    }

    // Reset state and UI after a short delay to show the result
    setTimeout(() => {
        state.coinTossAttacker = null;
        state.coinTossTarget = null;
        state.selectedCard = null; // Deselect card
        state.currentCoinTossHandler = null; // Clear handler
        showScreen('game-screen'); // Return to the game screen
        render();
        if (checkWin()) return; // Check for win after the toss is fully resolved
    }, 1500);
}


// --- ÊåáÁ§∫„Åï„Çå„Åü„Éá„ÉÉ„Ç≠„Ç®„Éá„Ç£„Çø„ÅÆÈ≠îÊ≥ï ---

function openDeckList(purpose = 'edit') {
    const grid = document.getElementById('deck-grid'); grid.innerHTML = '';
    for(let i=1; i<=100; i++) {
        const name = localStorage.getItem(`deck_name_${i}`) || `DECK ${i}`;
        const slot = document.createElement('div'); slot.className = 'slot'; slot.style.width="150px";
        slot.innerHTML = `<div>${name}</div><small>Slot ${i}</small>`;
        slot.onclick = () => {
            if (purpose === 'edit') {
                state.editIdx = i;
                enterEditor();
            } else { // purpose === 'battle'
                startGameWithDeck(i);
            }
        };
        grid.appendChild(slot);
    }
    showScreen('deck-list-screen');
}

function enterEditor() {
    const saved = localStorage.getItem(`deck_cards_${state.editIdx}`);
    state.editCards = saved ? JSON.parse(saved).map(d => new Card(d.suit, d.rank, d.type, d.monsterName, { ...d })) : [];

    // Ensure fullCollection is initialized first if it hasn't been already
    if (fullCollection.length === 0) {
        initializeAndRenderCollection(false); // Call without rendering to avoid double-render or screen change
    }

    // Now, populate editorCardPool from fullCollection each time the editor is entered
    // This makes sure newly generated monsters are included
    editorCardPool = [...fullCollection];
    
    document.getElementById('editor-name-search-input').value = '';
    document.getElementById('editor-power-search-input').value = '';

    renderEditorPool(editorCardPool);
    renderEditor(); 
    showScreen('editor-screen');
}

function renderEditorPool(cards) {
    const pool = document.getElementById('pool-grid'); 
    pool.innerHTML = '';
    cards.forEach(c => pool.appendChild(createCardUI(c, true)));
}

function createCardUI(c, isPool) {
    const div = createCardEl(c); // „Éô„Éº„Çπ„ÅÆ„Ç´„Éº„ÉâË°®Á§∫„ÇíÂà©Áî®
    div.onclick = () => {
        if(isPool) {
            if (state.editCards.length >= 30) {
                alert(getText('deck_30_cards_max'));
                return;
            }
            let count;
            if (c.monsterName) { // If it's a monster card, check by monsterName
                count = state.editCards.filter(deckCard => deckCard.monsterName === c.monsterName).length;
            } else { // It's a regular card, check by suit and rank
                count = state.editCards.filter(deckCard => deckCard.suit === c.suit && deckCard.rank === c.rank).length;
            }
            if (count >= 2) {
                alert(getText('same_card_2_max'));
                return;
            }
            // Preserve monsterName if it's a monster card
            const cardData = { ...c };
            delete cardData.id; // Ensure a new ID is generated
            state.editCards.push(new Card(c.suit, c.rank, c.type, c.monsterName, cardData)); 
        } else { 
            // This part is for removing cards from the deck, which is correct.
            // Find the specific card instance to remove.
            const cardIndex = state.editCards.findIndex(deckCard => deckCard.id === c.id);
            if (cardIndex > -1) {
                state.editCards.splice(cardIndex, 1);
            }
        }
        renderEditor();
    };
    return div;
}

function renderEditor() {
    const grid = document.getElementById('current-deck-grid'); grid.innerHTML = '';
    state.editCards.forEach(c => grid.appendChild(createCardUI(c, false)));
    document.getElementById('deck-count').textContent = state.editCards.length;
}

function saveDeck() {
    if (state.editCards.length !== 30) {
        alert(getText('deck_must_be_30') + state.editCards.length);
        return;
    }
    localStorage.setItem(`deck_cards_${state.editIdx}`, JSON.stringify(state.editCards));
    const name = prompt(getText('prompt_deck_name'), localStorage.getItem(`deck_name_${state.editIdx}`) || `DECK ${state.editIdx}`);
    if(name) localStorage.setItem(`deck_name_${state.editIdx}`, name);
    openDeckList('edit');
}

let editorCardPool = [];

function filterEditorPool() {
    const nameTerm = document.getElementById('editor-name-search-input').value.toLowerCase();
    const powerTerm = document.getElementById('editor-power-search-input').value.toLowerCase();

    const filteredCards = editorCardPool.filter(card => {
        const nameMatch = !nameTerm || 
               (card.rank && card.rank.toLowerCase().includes(nameTerm)) ||
               (card.displayName && card.displayName.toLowerCase().includes(nameTerm)) ||
               (card.sizeName && card.sizeName.toLowerCase().includes(nameTerm)) ||
               (card.raceName && card.raceName.toLowerCase().includes(nameTerm));

        const powerMatch = !powerTerm ||
               (card.powerName && card.powerName.toLowerCase().includes(powerTerm)) ||
               (card.secondaryPowerName && card.secondaryPowerName.toLowerCase().includes(powerTerm));

        return nameMatch && powerMatch;
    });

    renderEditorPool(filteredCards);
}


let fullCollection = [];

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    updateUIText(); // Update text every time a screen is shown
    if (id === 'collection-screen') initializeAndRenderCollection(true);
}

function initializeAndRenderCollection(shouldRender = true) {
    if (fullCollection.length === 0) {
        // Display regular cards first
        SUITS.forEach(s => {
            RANKS.forEach(r => fullCollection.push(new Card(s, r)));
            SUPPORTS.forEach(a => fullCollection.push(new Card(s, a, 'support', null, { displayName: getSupportCardDisplayName(a) })));
        });
        // Add initial monster cards
        for (let i = 0; i < 20; i++) {
            fullCollection.push(generateRandomMonsterCard());
        }

        // Add special card 'Karikoin' to fullCollection
        const karikoin = new Card('special', '„Ç´„É™„Ç≥„Ç§„É≥', 'unit', '„Ç´„É™„Ç≥„Ç§„É≥', { 
            hp: 7, 
            maxHp: 7, 
            value: 10, // Base value for display, actual damage is conditional
            requiredPower: 2, 
            powerName: '„Éó„É¨„Ç§', 
            specialAbility: 'cointoss' 
        });
        fullCollection.push(karikoin);

        const kariijou = new Card('special', '„Ç´„É™„Ç§„Ç∏„Éß„Ç¶', 'unit', '„Ç´„É™„Ç§„Ç∏„Éß„Ç¶', {
            hp: 5,
            maxHp: 5,
            value: 5,
            requiredPower: 2,
            powerName: '„Ç¢„Ç∑„ÉÉ„Éâ', // Minus Power
            specialAbility: 'abnormal_state'
        });
        fullCollection.push(kariijou);

        const karikopi = new Card('special', '„Ç´„É™„Ç≥„Éî„Éº', 'unit', '„Ç´„É™„Ç≥„Éî„Éº', {
            hp: 6,
            maxHp: 6,
            value: 4, // Base value, will be changed by copy ability
            requiredPower: 3,
            powerName: '„Ç§„Éü„ÉÜ„Ç§„Éà',
            specialAbility: 'copy'
        });
        fullCollection.push(karikopi);

        // --- New card: Kari-Heal ---
        const kariheal = new Card('special', '„Ç´„É™„Éí„Éº„É´', 'unit', '„Ç´„É™„Éí„Éº„É´', {
            hp: 8,
            maxHp: 8,
            value: 3, // Cannot attack
            requiredPower: 2,
            powerName: '„Éí„Éº„É´', // Heal power
            specialAbility: 'kari_heal'
        });
        fullCollection.push(kariheal);

        // --- New card: Kari-Sleep ---
        const karisleep = new Card('special', '„Ç´„É™„Çπ„É™„Éº„Éó', 'unit', '„Ç´„É™„Çπ„É™„Éº„Éó', {
            hp: 5,
            maxHp: 5,
            value: 3, // Can attack, but for sleep effect
            requiredPower: 3,
            powerName: '„Çπ„É™„Éº„Éó', // Sleep power
            specialAbility: 'kari_sleep'
        });
        fullCollection.push(karisleep);
    }
    if (shouldRender) {
        renderCardGrid(fullCollection);
    }
}

function renderCardGrid(cards) {
    const grid = document.getElementById('coll-grid');
    grid.innerHTML = ''; // Clear previous content
    cards.forEach(card => grid.appendChild(createCardEl(card)));
}

function filterCollection() {
    const nameTerm = document.getElementById('name-search-input').value.toLowerCase();
    const powerTerm = document.getElementById('power-search-input').value.toLowerCase();

    const filteredCards = fullCollection.filter(card => {
        const nameMatch = !nameTerm || 
               (card.rank && card.rank.toLowerCase().includes(nameTerm)) ||
               (card.displayName && card.displayName.toLowerCase().includes(nameTerm)) ||
               (card.sizeName && card.sizeName.toLowerCase().includes(nameTerm)) ||
               (card.raceName && card.raceName.toLowerCase().includes(nameTerm));

        const powerMatch = !powerTerm ||
               (card.powerName && card.powerName.toLowerCase().includes(powerTerm)) ||
               (card.secondaryPowerName && card.secondaryPowerName.toLowerCase().includes(powerTerm));

        return nameMatch && powerMatch;
    });

    renderCardGrid(filteredCards);
}

// „É¢„É≥„Çπ„Çø„Éº„Ç´„Éº„Éâ„Çí„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„Å´ËøΩÂä†„Åô„ÇãÈñ¢Êï∞
function addMonsterCardsToCollection() {
    const numCardsToAdd = 5; // Add 5 for subsequent clicks
    for (let i = 0; i < numCardsToAdd; i++) { // Generate random monster cards
        fullCollection.push(generateRandomMonsterCard());
    }
    filterCollection(); // Re-render the grid respecting the current filter
}

// Helper to get display name for support cards
function getSupportCardDisplayName(rank) {
    switch (rank) {
        case 'BOOSTPOWER': return 'Boost P';
        case 'LOOSEPOWER': return 'Loose P';
        case 'HANDEXCHANGE': return 'Hand Ex';
        case '2DRAW': return '2DRAW';
        case '3DRAW': return '3DRAW';
        case '4DRAW': return '4DRAW';
        case 'HEAL': return 'HEAL';
        case 'SKIP': return 'SKIP';
        case 'ATTACKUP': return 'Atk Up';
        case 'ATTACKDOWN': return 'Atk Down';
        case 'OPPONENTCALL': return 'Opp Call';
        case 'SELFMOVE': return 'Self Move';
    }
}


function addLog(msg) {
    const log = document.getElementById('log-area');
    const div = document.createElement('div'); div.textContent = `> ${msg}`;
    log.appendChild(div); log.scrollTop = log.scrollHeight;
}

function createCardEl(card) {
    const div = document.createElement('div');
    div.className = `card ${card.suit || ''}`;
    div.dataset.cardId = card.id;

    // --- Áä∂ÊÖãÁï∞Â∏∏„ÅÆË°®Á§∫ ---
    if (card.statusEffects && card.statusEffects.length > 0) {
        const statusContainer = document.createElement('div');
        statusContainer.style.position = 'absolute';
        statusContainer.style.top = '25px';
        statusContainer.style.left = '2px';
        statusContainer.style.display = 'flex';
        statusContainer.style.flexDirection = 'column';
        statusContainer.style.gap = '2px';
        card.statusEffects.forEach(effect => {
            const effectBadge = document.createElement('div');
            effectBadge.style.background = 'rgba(200, 50, 50, 0.8)';
            effectBadge.style.color = 'white';
            effectBadge.style.fontSize = '0.5em';
            effectBadge.style.padding = '1px 2px';
            effectBadge.style.borderRadius = '3px';
            effectBadge.style.fontWeight = 'bold';
            const initial = getInitialism(effect.name) || effect.name.substring(0,2);
            effectBadge.textContent = `${initial}`;
            statusContainer.appendChild(effectBadge);
        });
        if (card.isSleeping) {
            const sleepBadge = document.createElement('div');
            sleepBadge.style.background = 'rgba(50, 50, 200, 0.8)';
            sleepBadge.style.color = 'white';
            sleepBadge.style.fontSize = '0.5em';
            sleepBadge.style.padding = '1px 2px';
            sleepBadge.style.borderRadius = '3px';
            sleepBadge.style.fontWeight = 'bold';
            sleepBadge.textContent = 'Sl'; // Initialism for Sleep
            statusContainer.appendChild(sleepBadge);
        }
        div.appendChild(statusContainer);
    }

    if (card.isFaceDown) {
        div.className = 'card back';
        div.innerHTML = `<div style="display:flex; justify-content:center; align-items:center; height:100%; font-size: 2em; color: white;">?</div>`;
    } else if (card.specialAbility === 'cointoss' || card.specialAbility === 'copy' || card.specialAbility === 'abnormal_state' || card.specialAbility === 'kari_heal' || card.specialAbility === 'kari_sleep') {
        const p = card.powerName;
        let shapeClass = "square-mark"; // Default
        let displayPowerName = getInitialism(p);

        const stars = ["„Éí„Éº„É´", "„ÉÅ„É£„Éº„É†", "„Ç§„Éü„ÉÜ„Ç§„Éà", "„ÉÅ„Çß„É≥„Ç∏", "„Éó„É¨„Ç§", "„Ç∞„É´„Éº„Éó", "„Çπ„É™„Éº„Éó", "„Ç§„É¨„Ç§„Çπ", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà", "„Éï„Çß„Ç§„ÇØ", "„Ç™„Éº„É´", "„Éç„Ç∂„Éº", "„ÉÅ„Ç®", "„Ç≥„Éî„Éº"];
        const triangles = ["„Éù„Ç§„Ç∫„É≥", "„ÉÄ„Éº„ÉÜ„Ç£", "„Éñ„É©„ÉÉ„Éâ", "„Éë„É©„É™„Ç∑„Çπ", "„Ç§„É´„Éç„Çπ", "„Ç¢„Ç∑„ÉÉ„Éâ", "„Çø„Ç§„É§„Éº„Éâ"];

        if (stars.includes(p)) {
            shapeClass = "star-mark";
        } else if (triangles.includes(p)) {
            shapeClass = "triangle-mark";
        }

        div.innerHTML = `
            <div class="hp-badge">${card.hp}/${card.maxHp}</div>
            <div style="font-size:0.42em; text-align:center; padding:3px; font-weight:bold; line-height:1.1; word-break:break-all;">${card.displayName}</div>
            <div class="symbol-container" style="position: absolute; top: calc(50% + 15px); left: 5px; transform: translateY(-50%); width: 25px; height: 25px;">
                <div class="common-mark ${shapeClass}"></div>
                <div style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:0.4em; font-weight:bold; color:white; text-shadow:1px 1px 1px black;">
                    ${displayPowerName}
                </div>
            </div>
            <div style="position:absolute; bottom:3px; width:100%; text-align:center; font-size:0.5em; font-weight:bold; color:#333;">
                P:${card.attachedPower}/${card.requiredPower} A:${card.value}
            </div>
        `;
    } else if (card.isSupport && !card.specialAbility) { // NEW: Dedicated display for generic support cards (without special ability)
        div.innerHTML = `
            <div style="font-size:0.9em; text-align:center; padding:3px; font-weight:bold;">${card.displayName}</div>
            <div style="font-size:0.8em; text-align:center; padding-left:3px;">${card.suit}</div>
        `;
    } else if (card.isTripleType) { // Changed condition to isTripleType
        // --- 1. Â±ûÊÄßÔºà„Éë„ÉØ„ÉºÂêçÔºâ„Åã„Çâ„ÄåÂΩ¢„Äç„ÇíÊ±∫„ÇÅ„ÇãÈ≠îÊ≥ï„ÅÆËæûÊõ∏„Å†„Å¥„Çá„ÇìÔºÅ ---
        const p = card.powerName;
        let shapeClass = "square-mark"; // „Åù„ÅÆ‰ªñ„ÅØÂõõËßí
        
        // Êòü„ÅÆÂΩ¢
        const stars = ["„Éí„Éº„É´", "„ÉÅ„É£„Éº„É†", "„Ç§„Éü„ÉÜ„Ç§„Éà", "„ÉÅ„Çß„É≥„Ç∏", "„Éó„É¨„Ç§", "„Ç∞„É´„Éº„Éó", "„Çπ„É™„Éº„Éó", "„Ç§„É¨„Ç§„Çπ", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà", "„Éï„Çß„Ç§„ÇØ", "„Ç™„Éº„É´", "„Éç„Ç∂„Éº", "„ÉÅ„Ç®"];
        // ‰∏∏„ÅÆÂΩ¢
        const circles = ["„Ç¢„É≥„Ç∞„É™„Éº", "„Ç∏„Éß„Ç§", "„ÇΩ„É≠„Éº", "„Éó„É¨„Ç∑„É£„Éº", "„É©„Éñ", "„Éò„Ç§„Éà", "„Éï„Ç£„Ç¢„Éº", "„Çµ„Éó„É©„Ç§„Ç∫", "„Ç¶„Ç©„É≥„Éà", "„Ç¢„Éê„É≥„ÉÄ„É≥„Éâ"];
        // ‰∏âËßí„ÅÆÂΩ¢
        const triangles = ["„Éù„Ç§„Ç∫„É≥", "„ÉÄ„Éº„ÉÜ„Ç£", "„Éñ„É©„ÉÉ„Éâ", "„Éë„É©„É™„Ç∑„Çπ", "„Ç§„É´„Éç„Çπ", "„Ç¢„Ç∑„ÉÉ„Éâ", "„Çø„Ç§„É§„Éº„Éâ"];
        // Ê®°ÊßòÁ≥ª
        const patterns = ["„ÉÅ„Çß„ÉÉ„ÇØ", "„Éâ„ÉÉ„Éà", "„ÉØ„Éº„É´„Éó„Éº„É´", "„É°„É≠„Éá„Ç£„Éº"];

        if (stars.includes(p)) shapeClass = "star-mark";
        else if (circles.includes(p)) shapeClass = "circle-mark";
        else if (triangles.includes(p)) shapeClass = "triangle-mark";
        else if (patterns.includes(p)) shapeClass = `pattern-mark pattern-${p}`;

        let displayPowerName = getInitialism(card.powerName);
        if (shapeClass === "star-mark") {
            // Keep specific initialism
        } else if (shapeClass === "circle-mark") {
            // Keep specific initialism
        } else if (shapeClass === "triangle-mark") {
            // Keep specific initialism
        }

        // --- 2. „Ç´„Éº„Éâ„ÅÆË¶ã„ÅüÁõÆ„Çí‰Ωú„Çã„Å¥„Çá„ÇìÔºÅ ---
        div.innerHTML = `
            <div class="hp-badge">${card.hp}/${card.maxHp}</div>
            
            <div style="position:absolute; top:2px; left:2px; width:45px; text-align:left; font-size:0.42em; line-height:1.1; font-weight:bold; color:#333; word-break:break-all;">
                ${card.sizeName}${card.powerName}${card.raceName}
            </div>

            <div class="symbol-container" style="position:absolute; top:calc(50% + 15px); left:5px; transform:translateY(-50%); width: 25px; height: 25px;">
                <div class="common-mark ${shapeClass}"></div>
                <div style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:0.4em; font-weight:bold; color:white; text-shadow:1px 1px 1px black;">
                    ${displayPowerName}
                </div>
            </div>

            <div style="position:absolute; bottom:3px; width:100%; text-align:center; font-size:0.5em; font-weight:bold; color:#333;">
                P:${card.attachedPower}/${card.requiredPower} A:${card.value}
            </div>
        `;
    } else if (card.isDoubleType) {
        // --- Setup for Power 1 ---
        const p1 = card.powerName;
        let shapeClass1 = "square-mark";
        const stars = ["„Éí„Éº„É´", "„ÉÅ„É£„Éº„É†", "„Ç§„Éü„ÉÜ„Ç§„Éà", "„ÉÅ„Çß„É≥„Ç∏", "„Éó„É¨„Ç§", "„Ç∞„É´„Éº„Éó", "„Çπ„É™„Éº„Éó", "„Ç§„É¨„Ç§„Çπ", "„Ç®„É≥„Éê„Ç§„É≠„É≥„É°„É≥„Éà", "„Éï„Çß„Ç§„ÇØ", "„Ç™„Éº„É´", "„Éç„Ç∂„Éº", "„ÉÅ„Ç®"];
        const circles = ["„Ç¢„É≥„Ç∞„É™„Éº", "„Ç∏„Éß„Ç§", "„ÇΩ„É≠„Éº", "„Éó„É¨„Ç∑„É£„Éº", "„É©„Éñ", "„Éò„Ç§„Éà", "„Éï„Ç£„Ç¢„Éº", "„Çµ„Éó„É©„Ç§„Ç∫", "„Ç¶„Ç©„É≥„Éà", "„Ç¢„Éê„É≥„ÉÄ„É≥„Éâ"];
        const triangles = ["„Éù„Ç§„Ç∫„É≥", "„ÉÄ„Éº„ÉÜ„Ç£", "„Éñ„É©„ÉÉ„Éâ", "„Éë„É©„É™„Ç∑„Çπ", "„Ç§„É´„Éç„Çπ", "„Ç¢„Ç∑„ÉÉ„Éâ", "„Çø„Ç§„É§„Éº„Éâ"];

        if (stars.includes(p1)) shapeClass1 = "star-mark";
        else if (circles.includes(p1)) shapeClass1 = "circle-mark";
        else if (triangles.includes(p1)) shapeClass1 = "triangle-mark";

        let displayPowerName1 = getInitialism(p1);
        if (shapeClass1 === "star-mark") { /* Keep specific initialism */ } 
        else if (shapeClass1 === "circle-mark") { /* Keep specific initialism */ } 
        else if (shapeClass1 === "triangle-mark") { /* Keep specific initialism */ } 

        // --- Setup for Power 2 ---
        const p2 = card.secondaryPowerName;
        let shapeClass2 = "square-mark";
        if (stars.includes(p2)) shapeClass2 = "star-mark";
        else if (circles.includes(p2)) shapeClass2 = "circle-mark";
        else if (triangles.includes(p2)) shapeClass2 = "triangle-mark";
        
        let displayPowerName2 = getInitialism(p2);
        if (shapeClass2 === "star-mark") { /* Keep specific initialism */ } 
        else if (shapeClass2 === "circle-mark") { /* Keep specific initialism */ } 
        else if (shapeClass2 === "triangle-mark") { /* Keep specific initialism */ } 

        div.innerHTML = `
            <div class="hp-badge">${card.hp}/${card.maxHp}</div>
            <div style="font-size:1.2em; text-align:left; padding:3px; font-weight:bold;">${card.rank}</div>
            
            <div style="position:absolute; top:calc(50% + 15px); left:5px; transform:translateY(-50%); width:65px; height:30px;">
                <div class="symbol-container" style="position:absolute; left:0px; top:0px; width: 25px; height: 25px;">
                    <div class="common-mark ${shapeClass1}"></div>
                    <div style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:0.4em; font-weight:bold; color:white; text-shadow:1px 1px 1px black;">
                        ${displayPowerName1}
                    </div>
                </div>
                <div class="symbol-container" style="position:absolute; left:35px; top:0px; width: 25px; height: 25px;"> <!-- 30px + 5px gap = 35px -->
                    <div class="common-mark ${shapeClass2}"></div>
                    <div style="position:absolute; top:0; left:0; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:0.4em; font-weight:bold; color:white; text-shadow:1px 1px 1px black;">
                        ${displayPowerName2}
                    </div>
                </div>
            </div>

            <div style="font-size:0.9em; text-align:left; padding-left:3px;">P:${card.attachedPower}/${card.requiredPower} A:${card.value}</div>
        `;
    } else {
        // „ÄêÊôÆÈÄö„ÅÆ„Éà„É©„É≥„Éó„Äë„Åæ„Åü„ÅØÁâπÊÆäËÉΩÂäõ„ÇíÊåÅ„Åü„Å™„ÅÑ„Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„ÅÆË°®Á§∫
        const displayText = card.isSupport ? card.displayName : card.rank;
        div.innerHTML = `
            <div class="hp-badge">${card.hp}/${card.maxHp}</div>
            <div style="font-size:1.2em; text-align:left; padding:3px; font-weight:bold;">${displayText}</div>
            <div style="font-size:0.8em; text-align:left; padding-left:3px;">${card.suit}</div>
            <div style="font-size:0.9em; text-align:left; padding-left:3px;">P:${card.attachedPower}/${card.requiredPower} A:${card.value}</div>
        `;
    }
    return div;
}

// „É¢„É≥„Çπ„Çø„Éº„Ç´„Éº„Éâ„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
function generateRandomMonsterCard() {
    const monsterName = generateHuntingName();
    const randomSuit = getRandomElement(SUITS);
    // For simplicity, monster cards will have a 'M' rank (or any non-standard rank)
    // and their actual name will be in displayName.
    return new Card(randomSuit, 'M', 'unit', monsterName);
}

// „ÉÜ„Ç≠„Çπ„Éà„ÅåË¶ÅÁ¥†ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíË™øÊï¥„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
function adjustFontSizeToFit(element, maxFontSizeEm = 0.8, minFontSizeEm = 0.6) {
    if (!element || !element.textContent) return;

    let currentFontSizeEm = maxFontSizeEm;
    element.style.fontSize = `${currentFontSizeEm}em`;

    // Ë¶™Ë¶ÅÁ¥†„ÅÆÂπÖ„ÇíÂèñÂæó („Ç´„Éº„Éâ„ÅÆÂπÖ„Å´‰æùÂ≠ò„Åô„Çã„Åü„ÇÅ)
    const parentWidth = element.parentElement ? element.parentElement.offsetWidth : 0;
    const padding = 10; // „Ç´„Éº„Éâ„ÅÆ„Éë„Éá„Ç£„É≥„Ç∞„ÇíËÄÉÊÖÆ
    const availableWidth = parentWidth - padding; // „ÉÜ„Ç≠„Çπ„Éà„ÅåÂà©Áî®„Åß„Åç„ÇãÂπÖ

    // „ÉÜ„Ç≠„Çπ„Éà„Åå„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„Åó„Å¶„ÅÑ„ÇãÈñì„ÄÅ„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíÁ∏ÆÂ∞è
    while (element.scrollWidth > availableWidth && currentFontSizeEm > minFontSizeEm) {
        currentFontSizeEm -= 0.05; // 0.05em„Åö„Å§Á∏ÆÂ∞è
        element.style.fontSize = `${currentFontSizeEm}em`;
    }
    // „ÉÜ„Ç≠„Çπ„Éà„Åå„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„Åó„Å™„Åè„Å¶„ÇÇ„ÄÅÊúÄÂ∞è„Çµ„Ç§„Ç∫„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅØ„ÄÅÊúÄÂ§ß„Çµ„Ç§„Ç∫„Å´„É™„Çª„ÉÉ„Éà„Åô„Çã„Åì„Å®„ÇÇËÄÉÊÖÆ„Åß„Åç„Çã„Åå„ÄÅ
    // ‰ªäÂõû„ÅØÂçòÁ¥î„Å´Âèé„Åæ„Çã„Åæ„ÅßÁ∏ÆÂ∞è„Åô„Çã„ÅÆ„Åø
}


    // Helper to find the DOM element of a card
    function getCardElement(card) {
        if (!card) return null;
        const els = document.querySelectorAll(`[data-card-id="${card.id}"]`); // Use attribute selector for efficiency
        for (const el of els) {
            // Check if this is a player's field card (or hand card, if needed)
            // For menu positioning, we assume it's a field card
            if (el.closest('#player-field') || el.closest('#player-hand')) { // Check if it's in player area
                return el;
            }
        }
        return null;
    }

    function showAttackMenu(card) {
        const attackMenu = document.getElementById('attack-menu');
        const cardEl = getCardElement(card); // Get the actual DOM element for the selected card

        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            // Position to the right of the card, relative to the game-container
            const gameContainerRect = document.querySelector('.game-container').getBoundingClientRect();
            attackMenu.style.left = `${rect.right + 10 - gameContainerRect.left}px`;
            attackMenu.style.top = `${rect.top - gameContainerRect.top}px`;
            attackMenu.style.display = 'flex';
        } else {
            console.error("Could not find DOM element for selected card:", card);
        }
    }

    function hideAttackMenu() {
        document.getElementById('attack-menu').style.display = 'none';
        state.isAttacking = false; // Reset attacking state
    }
    
// Helper function to draw cards
function drawCards(count) {
    for (let i = 0; i < count; i++) {
        if (state.player.deck.length > 0) {
            state.player.hand.push(state.player.deck.shift());
        } else {
            addLog(getText('log_deck_empty'));
            break;
        }
    }
}

// Helper function to shuffle an array (Fisher-Yates algorithm)
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

function useSupportCard(card) {
    if (state.gameOver || state.turn !== 'player') {
        addLog(getText('log_support_card_not_in_battle'));
        return;
    }

    let cardUsed = false;
    switch (card.rank) {
        case '2DRAW':
            addLog(getText('log_use_2draw'));
            drawCards(2);
            cardUsed = true;
            break;
        case '3DRAW':
            addLog(getText('log_use_3draw'));
            drawCards(3);
            cardUsed = true;
            break;
        case '4DRAW':
            addLog(getText('log_use_4draw'));
            drawCards(4);
            cardUsed = true;
            break;
        case 'HEAL':
            addLog(getText('log_use_heal'));
            state.isHealing = true; // „Äå‰ªä„Åã„ÇâÂõûÂæ©„Åô„Çã„Çà„Äç„Å®„ÅÑ„ÅÜ„É¢„Éº„Éâ„Å´„Åô„Çã
            cardUsed = true;
            break;
        case 'SKIP':
            addLog(getText('log_use_skip'));
            state.skipOpponentTurn = true; // Set a flag to skip opponent's turn
            cardUsed = true;
            break;
        case 'HANDEXCHANGE':
            addLog(getText('log_use_handexchange'));
            const cardsInHandCount = state.player.hand.length - 1; // Exclude HANDEXCHANGE itself

            // Return cards from hand to deck
            state.player.hand.forEach(c => {
                if (c !== card) { // Don't return the HANDEXCHANGE card itself
                    state.player.deck.push(c);
                }
            });
            state.player.hand = []; // Clear hand except for the HANDEXCHANGE card

            shuffleArray(state.player.deck); // Shuffle the deck

            // Draw new cards equal to the number of cards returned
            drawCards(cardsInHandCount);
            
            cardUsed = true;
            break;
        case 'BOOSTPOWER':
            addLog(getText('log_use_boostpower'));
            state.isBoosting = true; // Enter boosting mode
            cardUsed = true;
            break;
        case 'LOOSEPOWER':
            addLog(getText('log_use_loosepower'));
            state.isLoosing = true; // Enter loosing mode
            cardUsed = true;
            break;
        case 'ATTACKUP':
            addLog(getText('log_use_attackup'));
            state.player.attackUpActive = true;
            cardUsed = true;
            break;
        case 'ATTACKDOWN':
            addLog(getText('log_use_attackdown'));
            state.opponent.attackDownActive = true;
            cardUsed = true;
            break;
        case 'OPPONENTCALL':
            // Check if opponent's front row is full
            const oppFrontRowFull = state.opponent.field.slice(0, 3).every(slot => slot !== null);
            if (oppFrontRowFull) {
                addLog(getText('log_front_row_full'));
                break;
            }
            const oppBackRowCards = state.opponent.field.slice(3, 6).filter(c => c !== null);
            if (oppBackRowCards.length === 0) {
                addLog(getText('log_no_back_row_cards'));
                break;
            }
            addLog(getText('log_use_opponentcall'));
            state.isOpponentCalling = true;
            cardUsed = true;
            break;
        case 'SELFMOVE':
            // Check if player's front row is full
            const playerFrontRowFull = state.player.field.slice(0, 3).every(slot => slot !== null);
            if (playerFrontRowFull) {
                addLog(getText('log_front_row_full'));
                break;
            }
            const playerBackRowCards = state.player.field.slice(3, 6).filter(c => c !== null);
            if (playerBackRowCards.length === 0) {
                addLog(getText('log_no_back_row_cards'));
                break;
            }
            addLog(getText('log_use_selfmove'));
            state.isSelfMoving = true;
            cardUsed = true;
            break;
    }

    if (cardUsed) {
        // Remove card from hand and move to graveyard
        state.player.hand = state.player.hand.filter(c => c !== card);
        state.player.grave++;
        state.selectedCard = null; // Deselect
        render();
    }
}

function render() {
    renderField('player-field', state.player.field, false);
    renderField('opponent-field', state.opponent.field, true);
    const handEl = document.getElementById('player-hand'); handEl.innerHTML = '';
    state.player.hand.forEach(card => {
        const el = createCardEl(card);
        el.onclick = () => { 
            if(state.gameOver) return;

            if (state.canPlaceCard) { // --- ÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫‰∏≠„ÅÆÂá¶ÁêÜ ---
                if (card.isSupport) {
                    addLog(getText('log_support_card_not_on_place'));
                } else {
                    state.selectedCard = card; // „É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅØÈÅ∏Êäû
                    render();
                }
            } else { // --- „Éê„Éà„É´„Éï„Çß„Éº„Ç∫‰∏≠„ÅÆÂá¶ÁêÜ ---
                if (card.isSupport) {
                    useSupportCard(card); // „Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„ÅØÁõ¥Êé•‰ΩøÁî®
                } else {
                    state.selectedCard = card; // „É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅØÈÅ∏Êäû
                    render(); 
                }
            }
        };
        if (state.selectedCard === card) el.classList.add('selected');
        handEl.appendChild(el);
    });

    // Hide attack menu when rendering if no card is selected
    if (!state.selectedCard) {
        hideAttackMenu(); // Ensure menu is hidden if no card is selected
    }
    
    const oppHandEl = document.getElementById('opponent-hand'); oppHandEl.innerHTML = '';
    for(let i=0; i<state.opponent.handCount; i++) {
        const back = document.createElement('div'); back.className = 'card back';
        oppHandEl.appendChild(back);
    }
    document.getElementById('opp-hp').textContent = `${state.opponent.points}/5`;
    document.getElementById('ply-hp').textContent = `${state.player.points}/5`;
    document.getElementById('opp-power-display').textContent = state.opponent.power;
    document.getElementById('ply-power-display').textContent = state.player.power;
    document.getElementById('opp-hand-count').textContent = state.opponent.handCount;
    document.getElementById('ply-hand-count').textContent = state.player.hand.length;
    document.getElementById('opp-deck').textContent = `${state.opponent.deck.length}/30`;
    document.getElementById('ply-deck').textContent = `${state.player.deck.length}/30`;
    document.getElementById('opp-graveyard').textContent = state.opponent.grave;
    document.getElementById('ply-graveyard').textContent = state.player.grave;
    document.getElementById('ok-btn').style.display = state.canPlaceCard ? 'block' : 'none';
    
    document.getElementById('battle-controls').style.display = !state.canPlaceCard ? 'flex' : 'none';
    
    document.getElementById('power-btn').disabled = state.player.powerInjected || state.turn !== 'player';
}

function renderField(id, field, isOpponent) {
    const el = document.getElementById(id); el.innerHTML = '';
    field.forEach((card, i) => {
        const slot = document.createElement('div'); slot.className = 'card-slot'; slot.style.gridArea = `slot${i}`;
        if (card) {
            const cardEl = createCardEl(card);
            const targetCardIndex = state.opponent.field.indexOf(card); // For opponent cards
            const friendlyCardIndex = state.player.field.indexOf(card); // For player cards

            // Highlight targetable opponent cards when isAttacking is true
            if (state.isAttacking && isOpponent && targetCardIndex < 3) {
                 cardEl.style.outline = '4px solid red'; // Visual cue for targetable
            }
            // Highlight opponent's front-row cards for copying
            if (state.isCopyingAttack && isOpponent && targetCardIndex < 3) {
                cardEl.style.outline = '4px solid cyan'; // Visual cue for copyable
            }
            // Highlight any opponent card for copied attack target
            if (state.isSelectingCopyTarget && isOpponent) {
                cardEl.style.outline = '4px solid purple'; // Visual cue for copied attack target
            }
            // Highlight friendly front-line cards for healing target selection
            if (state.isHealingTargetSelection && !isOpponent && friendlyCardIndex !== -1 && friendlyCardIndex < 3 && card.hp < card.maxHp) {
                cardEl.style.outline = '4px solid lightgreen';
            }
            // NEW: Highlight friendly front-line cards for boosting
            if (state.isBoosting && !isOpponent && friendlyCardIndex !== -1 && friendlyCardIndex < 3 && card.attachedPower < card.requiredPower) {
                cardEl.style.outline = '4px solid gold';
            }
            // NEW: Highlight opponent front-line cards for loosing
            if (state.isLoosing && isOpponent && targetCardIndex !== -1 && targetCardIndex < 3 && card.attachedPower > 0) {
                cardEl.style.outline = '4px solid red';
            }
            // NEW: Highlight opponent back-row cards for Opponent Call
            if (state.isOpponentCalling && isOpponent && (i >= 3 && i <= 5) && card !== null) {
                cardEl.style.outline = '4px solid orange';
            }
            // NEW: Highlight player back-row cards for Self Move
            if (state.isSelfMoving && !isOpponent && (i >= 3 && i <= 5) && card !== null) {
                cardEl.style.outline = '4px solid yellowgreen';
            }

            if (!isOpponent && state.player.attackedIds.includes(card.id)) cardEl.classList.add('attacked');
            if (state.selectedCard === card) cardEl.classList.add('selected');

            cardEl.onclick = (e) => {
                e.stopPropagation();
                if (state.gameOver) return;
                if (isOpponent) {
                    if (state.isCopyingAttack) {
                        handleCopyAttackSelection(card);
                    } else if (state.isSelectingCopyTarget) {
                        handleCopiedAttack(card);
                    } else if (state.isLoosing) { // NEW: Handle Loose Power target selection
                        handleLooseTargetSelection(card, i);
                    }
                     else if (state.isOpponentCalling) { // Handle Opponent Call target selection
                        handleOpponentCallSelection(card, i);
                    }
                     else if (state.isAttacking) { // Only attack if in attacking state
                        handleAttack(card);
                    } else {
                        addLog(getText('log_must_press_attack_button'));
                    }
                    hideAttackMenu(); // Hide menu after any opponent interaction
                } else { // Player's own card clicked
                    if (state.isHealing) { // Healing from a support card
                        healCard(card);
                        return;
                    }
                    if (state.isHealingTargetSelection) { // Healing from Kari-Heal's ability
                        handleHealTargetSelection(card, i); // Pass index if needed for field update
                        return;
                    }
                    if (state.isBoosting) { // NEW: Handle Boost Power target selection
                        handleBoostTargetSelection(card, i);
                        return;
                    }
                    if (state.isSelfMoving) { // Handle Self Move target selection
                        handleSelfMoveSelection(card, i);
                        return;
                    }

                    // If we are in attack mode and click another of our own cards, cancel the attack mode.
                    if (state.isAttacking) {
                        hideAttackMenu();
                    }
                    
                    if (state.selectedCard === card) { // Deselect if already selected
                        state.selectedCard = null;
                        hideAttackMenu(); // Hide menu if deselected
                    } else {
                        state.selectedCard = card;
                        if (!state.gameOver && state.turn === 'player') { // Only show menu if player's turn and not game over
                            showAttackMenu(card); // Show attack menu near the card
                        }
                    }
                }
            };
            slot.appendChild(cardEl);
        } else if ((state.canPlaceCard || state.turn === 'player') && !isOpponent) {
            slot.onclick = () => placeCard(i);
        }
        el.appendChild(slot);
    });
}

function placeCard(i) {
    if (!state.selectedCard) {
        addLog(getText('log_select_unit_from_hand'));
        return;
    }
    // Prevent placing a card that is already on the field
    if (!state.player.hand.includes(state.selectedCard)) {
        return;
    }
    if (state.selectedCard.isSupport) {
        addLog(getText('log_support_card_no_place'));
        return;
    }
    
    const cardToPlace = state.selectedCard;

    state.player.field[i] = cardToPlace;
    state.player.hand = state.player.hand.filter(c => c !== cardToPlace);
    addLog(getFormattedText('log_card_placed', { rank: cardToPlace.rank }));
    state.selectedCard = null;
    hideAttackMenu();
    render();
}

function healCard(targetCard) {
    if (!targetCard || targetCard.isSupport) {
        addLog(getText('log_only_unit_can_be_healed'));
        return;
    }
    targetCard.hp = Math.min(targetCard.maxHp, targetCard.hp + 3);
    addLog(getFormattedText('log_heal_success', { rank: targetCard.rank, hp: targetCard.hp }));
    
    state.isHealing = false; // ÂõûÂæ©„É¢„Éº„Éâ„ÇíÁµÇ‰∫Ü
    render();
}

function handleFieldClick(card, i) {
    if (state.canPlaceCard) {
        state.player.hand.push(card); state.player.field[i] = null;
        addLog(getFormattedText('log_card_returned_to_hand', { rank: card.rank }));
        hideAttackMenu(); // Hide menu if card is moved
    } else { // Battle phase
        if (state.isHealing) { // If in healing mode (from support card), heal the card.
            healCard(card);
            return;
        }
        // NEW: If selecting a target for Kari-Heal
        if (state.isHealingTargetSelection) {
            handleHealTargetSelection(card, i); // Pass index for field context
            return;
        }
        // NEW: If selecting a target for Boost Power
        if (state.isBoosting) {
            handleBoostTargetSelection(card, i);
            return;
        }

        // If we are in attack mode and click another of our own cards, cancel the attack mode.
        if (state.isAttacking) {
            hideAttackMenu();
        }
        
        if (state.selectedCard === card) { // Deselect if already selected
            state.selectedCard = null;
            hideAttackMenu(); // Hide menu if deselected
        } else {
            state.selectedCard = card;
            // OLD KARI-HEAL LOGIC REMOVED FROM HERE
            if (!state.gameOver && state.turn === 'player') { // Only show menu if player's turn and not game over
                showAttackMenu(card); // Show attack menu near the card
            }
        }
    }
    render();
}

function handlePowerInject() {
    const c = state.selectedCard;
    if (c && state.player.field.includes(c) && c.attachedPower < c.requiredPower) {
        c.attachedPower++; state.player.powerInjected = true;
        addLog(getFormattedText('log_power_injected', { rank: c.rank }));
        render();
    }
}

function handleAttack(targetCard) {
    const attacker = state.selectedCard;
    if (!attacker) {
        addLog(getText('log_select_card_then_attack'));
        return;
    }

    const attackerIndex = state.player.field.indexOf(attacker);
    if (attackerIndex === -1 || attackerIndex > 2) {
        addLog(getText('log_cannot_attack_from_back_row'));
        return;
    }

    if (attacker.specialAbility === 'copy') {
        state.isCopyingAttack = true;
        addLog(getText('log_select_card_to_copy_attack_from'));
        render();
        return;
    }

    // For non-copy attacks, a target must be selected
    if (!targetCard) return;

    const targetCardIndex = state.opponent.field.indexOf(targetCard);
    if (targetCardIndex === -1 || targetCardIndex >= 3) {
        addLog(getFormattedText('log_invalid_attack_target_position', { rank: targetCard.rank }));
        return;
    }
    
    addLog(getFormattedText('log_attack_start', { rank: attacker.rank }));

    if (attacker.specialAbility === 'cointoss') {
        state.coinTossAttacker = attacker;
        state.coinTossTarget = targetCard; 
        state.currentCoinTossHandler = handleKarikoinCoinToss; // Set the specific handler
        showScreen('coin-flip-screen');
        const title = document.getElementById('coin-flip-title');
        title.textContent = "„Ç´„É™„Ç≥„Ç§„É≥„Éª„Ç¢„Çø„ÉÉ„ÇØÔºÅ";
        document.getElementById('cointoss-btn').style.display = 'inline-block';
        document.getElementById('cointoss-result').textContent = '';
        return;
    }

    executeNormalAttack(targetCard, attacker);
};

function handleCopyAttackSelection(cardToCopyFrom) {
    const attacker = state.selectedCard;
    if (!attacker || !state.isCopyingAttack) return;

    state.copiedAttackProperties = {
        value: cardToCopyFrom.value,
        specialAbility: cardToCopyFrom.specialAbility,
        // Copy other relevant properties if needed
    };

    addLog(getFormattedText('log_copied_attack', { copiedRank: cardToCopyFrom.rank }));
    
    state.isCopyingAttack = false;
    state.isSelectingCopyTarget = true;
    addLog(getText('log_select_target_for_copied_attack'));
    render();
}

function handleCopiedAttack(targetCard) {
    const attacker = state.selectedCard;
    if (!attacker || !state.isSelectingCopyTarget || !state.copiedAttackProperties) return;

    const targetCardIndex = state.opponent.field.indexOf(targetCard);
    if (targetCardIndex === -1) return;

    // Use a temporary attacker object with copied properties
    const tempAttacker = { ...attacker, ...state.copiedAttackProperties };

    addLog(getFormattedText('log_attack_start', { rank: attacker.rank }));
    executeNormalAttack(targetCard, tempAttacker);

    // Reset state
    state.isSelectingCopyTarget = false;
    state.copiedAttackProperties = null;
    state.selectedCard = null; // Deselect after attack
    render();
}

function handleHealTargetSelection(targetCard, index) {
    const healer = state.selectedCard; // This is Kari-Heal
    if (!healer || !state.isHealingTargetSelection || !targetCard) return;

    // Check if the target is a friendly front-line card
    const friendlyCardIndex = state.player.field.indexOf(targetCard);
    if (friendlyCardIndex === -1 || friendlyCardIndex > 2) {
        addLog(getText('log_only_unit_can_be_healed')); // Reusing this log, but could add a new one
        return;
    }

    if (targetCard.hp >= targetCard.maxHp) {
        addLog(getText('log_kariheal_target_full_hp'));
        return; // Don't heal a full-HP card
    }

    targetCard.hp = targetCard.maxHp; // Fully heal
    addLog(getFormattedText('log_kariheal_success', { rank: targetCard.rank }));

    state.player.usedSpecialAbilityIds.push(healer.id); // Mark Kari-Heal as having used its special ability
    state.isHealingTargetSelection = false;
    state.selectedCard = null;
    hideAttackMenu();
    render();
}

// NEW: Handle selection for Boost Power
function handleBoostTargetSelection(targetCard, index) {
    if (!targetCard) return;

    // Check if target is a friendly front-row card
    const friendlyCardIndex = state.player.field.indexOf(targetCard);
    if (friendlyCardIndex === -1 || friendlyCardIndex > 2) {
        addLog(getText('log_select_boost_target')); // Prompt user to select a valid target
        return;
    }

    if (targetCard.attachedPower >= targetCard.requiredPower) {
        addLog(getFormattedText('log_boost_max_power', { rank: targetCard.rank }));
        return;
    }

    targetCard.attachedPower++;
    addLog(getFormattedText('log_boost_success', { rank: targetCard.rank }));

    state.isBoosting = false; // Exit boosting mode
    state.selectedCard = null;
    hideAttackMenu();
    render();
}

// NEW: Handle selection for Loose Power
function handleLooseTargetSelection(targetCard, index) {
    if (!targetCard) return;

    // Check if target is an opponent front-row card
    const opponentCardIndex = state.opponent.field.indexOf(targetCard);
    if (opponentCardIndex === -1 || opponentCardIndex > 2) {
        addLog(getText('log_select_loose_target')); // Prompt user to select a valid target
        return;
    }

    if (targetCard.attachedPower <= 0) {
        addLog(getFormattedText('log_loose_min_power', { rank: targetCard.rank }));
        return;
    }

    targetCard.attachedPower--;
    addLog(getFormattedText('log_loose_success', { rank: targetCard.rank }));

    state.isLoosing = false; // Exit loosing mode
    state.selectedCard = null;
    hideAttackMenu();
    render();
}

function handleOpponentCallSelection(targetCard, index) {
    if (!targetCard || index < 3 || index > 5) { // Ensure it's a back-row card
        addLog("ÁÑ°Âäπ„Å™ÂØæË±°„Åß„Åô„ÄÇÁõ∏Êâã„ÅÆÂæåË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); // Invalid target. Please select an opponent's back-row monster.
        state.isOpponentCalling = false; // Exit mode on invalid selection
        state.selectedCard = null;
        render();
        return;
    }

    // Find the first empty slot in the opponent's front row
    const emptyFrontRowSlotIndex = state.opponent.field.slice(0, 3).findIndex(slot => slot === null);
    if (emptyFrontRowSlotIndex === -1) {
        addLog(getText('log_front_row_full')); // This should ideally be caught before.
        state.isOpponentCalling = false; // Exit mode
        state.selectedCard = null;
        render();
        return;
    }

    // Move the card
    state.opponent.field[emptyFrontRowSlotIndex] = targetCard;
    state.opponent.field[index] = null; // Clear the old position

    addLog(getFormattedText('log_opponentcall_success', { rank: targetCard.rank }));

    // Reset state
    state.isOpponentCalling = false;
    state.selectedCard = null;
    render();
}

function handleSelfMoveSelection(targetCard, index) {
    if (!targetCard || index < 3 || index > 5) { // Ensure it's a back-row card
        addLog("ÁÑ°Âäπ„Å™ÂØæË±°„Åß„Åô„ÄÇËá™ÂàÜ„ÅÆÂæåË°õ„É¢„É≥„Çπ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); // Invalid target. Please select your back-row monster.
        state.isSelfMoving = false; // Exit mode on invalid selection
        state.selectedCard = null;
        render();
        return;
    }

    // Find the first empty slot in the player's front row
    const emptyFrontRowSlotIndex = state.player.field.slice(0, 3).findIndex(slot => slot === null);
    if (emptyFrontRowSlotIndex === -1) {
        addLog(getText('log_front_row_full')); // This should ideally be caught before.
        state.isSelfMoving = false; // Exit mode
        state.selectedCard = null;
        render();
        return;
    }

    // Move the card
    state.player.field[emptyFrontRowSlotIndex] = targetCard;
    state.player.field[index] = null; // Clear the old position

    addLog(getFormattedText('log_selfmove_success', { rank: targetCard.rank }));

    // Reset state
    state.isSelfMoving = false;
    state.selectedCard = null;
    render();
}



function executeNormalAttack(targetCard, attacker) {
    let effectiveAttack = attacker.value; // Start with base attack
    if (state.player.attackUpActive) {
        effectiveAttack += 3; // Apply buff to effectiveAttack
        addLog(getFormattedText('log_attack_up_applied', { rank: attacker.rank }));
        state.player.attackUpActive = false; // Reset after use
    }
    
    if (attacker.attachedPower < attacker.requiredPower) {
        addLog(getText('log_attack_fail_no_power'));
        return;
    }

    if (attacker.isSleeping) {
        addLog(`${attacker.rank}„ÅØÁú†„Å£„Å¶„ÅÑ„Å¶ÊîªÊíÉ„Åß„Åç„Å™„ÅÑÔºÅ`);
        return;
    }

    if (state.player.attackedIds.includes(attacker.id)) {
        addLog(getFormattedText('log_card_already_attacked', { rank: attacker.rank }));
        return;
    }

    // „Åù„ÅÆ‰ªñ„ÅÆÁâπÊÆäËÉΩÂäõ„ÇÇ„Åì„Åì„ÅßÂá¶ÁêÜ„Åô„Çã„Å¥„Çá„ÇìÔºà„Ç≥„Ç§„É≥„Éà„Çπ„ÅØhandleAttack„ÅßÂá¶ÁêÜÊ∏à„ÅøÔºâ
    if (attacker.specialAbility === 'abnormal_state') {
        const effectName = attacker.powerName; // e.g., '„Ç¢„Ç∑„ÉÉ„Éâ'
        applyStatusEffect(targetCard, effectName); // Apply for 3 turns
        state.player.attackedIds.push(attacker.id); // Mark as attacked
        state.selectedCard = null;
        render();
        return; // Important: Stop execution here, no damage dealt
    }

    if (attacker.specialAbility === 'copy') {
        attacker.value = targetCard.value;
        addLog(`„Äê„Ç≥„Éî„Éº„Äë„ÅÆËÉΩÂäõ„Åß ${attacker.rank} „ÅÆÊîªÊíÉÂäõ„Åå ${attacker.value} „Å´„Å™„Å£„ÅüÔºÅ`);
    }

    if (attacker.specialAbility === 'kari_sleep') {
        targetCard.isSleeping = true;
        addLog(`${targetCard.rank}„ÅØÁú†„Å£„Å¶„Åó„Åæ„Å£„ÅüÔºÅ`);
        state.player.attackedIds.push(attacker.id);
        state.selectedCard = null;
        render();
        return; // End the attack here, no damage dealt
    }
    
    const totalA = effectiveAttack;
    targetCard.hp -= totalA;
    state.player.attackedIds.push(attacker.id);
    
    addLog(getFormattedText('log_attack_damage', { targetRank: targetCard.rank, totalA: totalA }));

    if (targetCard.hp <= 0) {
        const idx = state.opponent.field.indexOf(targetCard);
        if (idx !== -1) {
            state.opponent.field[idx] = null;
            state.opponent.grave++;
            state.player.points++;
        }
        addLog(getFormattedText('log_target_destroyed', { rank: targetCard.rank }));
        if (checkWin()) return;
    }
    
    state.selectedCard = null;
    render();
}

function confirmPlacement() { 
    state.canPlaceCard = false;

    // Flip opponent's face-down cards if any
    let flipped = false;
    state.opponent.field = state.opponent.field.map(card => {
        if (card && card.isFaceDown) {
            flipped = true;
            // Revert to the original card object by removing the face-down flag
            delete card.isFaceDown;
            return card;
        }
        return card;
    });

    if (flipped) {
        addLog(getText('log_opponent_cards_flipped'));
        render(); // Show the flipped cards
    }

    if (state.turn === 'player') {
        // Player's turn to start battle
        document.getElementById('status-text').textContent = "Ëá™„Çø„Éº„É≥";
        addLog(getText('log_placement_complete_player_turn'));
        render();
    } else {
        // Opponent's turn to start battle
        document.getElementById('status-text').textContent = "Áõ∏Êâã„Çø„Éº„É≥";
        addLog(getText('log_placement_complete_opponent_turn'));
        // Use setTimeout to give player a moment to see the flipped cards
        setTimeout(opponentAI, 1000);
    }
}

function handleEndTurn() {
    state.player.powerInjected = false; state.player.attackedIds = []; state.player.usedSpecialAbilityIds = [];
    addLog(getText('log_turn_end'));
    
    stateCheck(() => { // Pass a callback to stateCheck
        if (state.gameOver) return;

        addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
        state.turn = 'opponent'; document.getElementById('status-text').textContent = "Áõ∏Êâã„Çø„Éº„É≥";
        rotateFields();
        render(); 
        setTimeout(opponentAI, 1000);
    });
}

function opponentAI() {
    // Initial placement logic for opponent going first
    if (state.isOpponentInitialPlacement) {
        addLog(getText('log_opponent_placing_facedown'));
        const placeableUnits = state.opponent.hand.filter(card => !card.isSupport);
        if (placeableUnits.length > 0 && state.opponent.field.includes(null)) {
            const cardToPlay = placeableUnits[0];
            const emptySlotIndex = state.opponent.field.indexOf(null);
            if (emptySlotIndex !== -1) {
                // Place face down
                state.opponent.field[emptySlotIndex] = { ...cardToPlay, isFaceDown: true, originalCard: cardToPlay };
                state.opponent.hand = state.opponent.hand.filter(c => c !== cardToPlay);
                state.opponent.handCount = state.opponent.hand.length;
            }
        }
        state.isOpponentInitialPlacement = false;
        // Transition to player's placement phase
        state.canPlaceCard = true;
        state.statusText = "„Ç´„Éº„Éâ„ÇíÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
        addLog(getText('log_opponent_placement_done'));
        render();
        return; // End AI turn here for initial placement
    }

    // --- Regular AI Turn ---
    if (state.skipOpponentTurn) {
        addLog(getText('log_skip_effect'));
        state.skipOpponentTurn = false;
        // „Çø„Éº„É≥„Ç®„É≥„ÉâÂá¶ÁêÜ„ÇíÊ®°ÂÄ£ („É≠„Ç∞„ÄÅÂõûËª¢„ÄÅ„Éâ„É≠„Éº„ÄÅ„Çø„Éº„É≥Â§âÊõ¥)
        addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
        rotateFields();
        if (state.player.deck.length > 0) {
            state.player.hand.push(state.player.deck.shift());
            addLog(getText('log_player_drew_card'));
        } else {
            addLog(getText('log_player_deck_empty'));
        }
        state.turn = 'player';
        document.getElementById('status-text').textContent = "Ëá™„Çø„Éº„É≥";
        addLog(getText('log_opponent_turn_end'));
        render();
        checkWin();
        return; // „Çπ„Ç≠„ÉÉ„ÉóÁµÇ‰∫Ü
    }

    addLog(getText('log_opponent_turn_start'));

    // Opponent draws a card
    if (state.opponent.deck.length > 0) {
        const drawnCard = state.opponent.deck.shift();
        state.opponent.hand.push(drawnCard);
        state.opponent.handCount = state.opponent.hand.length;
        addLog(getText('log_opponent_drew_card'));
    } else {
        addLog(getText('log_opponent_deck_empty'));
    }

    const cardsOnOpponentField = state.opponent.field.filter(c => c !== null);
    let opponentAttackedIds = []; // 1„Çø„Éº„É≥„Å´1ÂõûÊîªÊíÉ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÁî®

    // Opponent tries to play a card from hand
    // „É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„ÅÆ„ÅøÈÖçÁΩÆÂØæË±°„Å®„Åô„Çã („Çµ„Éù„Éº„Éà„Ç´„Éº„Éâ„ÅØÈÖçÁΩÆ„Åó„Å™„ÅÑ)
    const placeableUnits = state.opponent.hand.filter(card => !card.isSupport);

    // ÈÖçÁΩÆ„Åß„Åç„Çã„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„Åå„ÅÇ„Çä„ÄÅ„Åã„Å§Â†¥„Å´Á©∫„Åç„Åå„ÅÇ„ÇãÂ†¥Âêà
    if (placeableUnits.length > 0 && state.opponent.field.includes(null)) {
        const cardToPlay = placeableUnits[0]; // ÊúÄ„ÇÇÂçòÁ¥î„Å´„ÄÅÊâãÊú≠„ÅÆÊúÄÂàù„ÅÆ„É¶„Éã„ÉÉ„Éà„Ç´„Éº„Éâ„Çí„Éó„É¨„Ç§„Åô„Çã
        const emptySlotIndex = state.opponent.field.indexOf(null);

        if (emptySlotIndex !== -1) {
            state.opponent.field[emptySlotIndex] = cardToPlay;
            state.opponent.hand = state.opponent.hand.filter(c => c !== cardToPlay);
            state.opponent.handCount = state.opponent.hand.length;
            addLog(getFormattedText('log_opponent_placed_card', { rank: cardToPlay.rank }));
        }
    } else {
        addLog(getText('log_opponent_did_not_place'));
    }

    // Opponent tries to power up a card
    const cardToPowerUp = cardsOnOpponentField.find(c => c.attachedPower < c.requiredPower && state.opponent.power > 0);
    if (cardToPowerUp) {
        cardToPowerUp.attachedPower++;
        state.opponent.power--;
        addLog(getFormattedText('log_opponent_injected_power', { rank: cardToPowerUp.rank, p_a: cardToPowerUp.attachedPower, p_req: cardToPowerUp.requiredPower }));
    } else if (cardsOnOpponentField.length > 0) {
        addLog(getText('log_opponent_did_not_inject'));
    }

    // Opponent attacks
    cardsOnOpponentField.forEach(oppCard => {
            if (!oppCard || opponentAttackedIds.includes(oppCard.id)) { // ÊîªÊíÉÊ∏à„Åø„ÄÅ„Åæ„Åü„ÅØÁÑ°Âäπ„Å™„Ç´„Éº„Éâ
                return;
            }
            let effectiveOppAttack = oppCard.value; // Start with base attack
            if (state.opponent.attackDownActive) {
                effectiveOppAttack = Math.max(0, effectiveOppAttack - 3); // Apply debuff to effectiveOppAttack
                addLog(getFormattedText('log_attack_down_applied', { rank: oppCard.rank }));
                state.opponent.attackDownActive = false; // Reset after use
            }
            // --- Kari-Sleep: Prevent attacking when asleep ---
            if (oppCard.isSleeping) {
                addLog(`${oppCard.rank}„ÅØÁú†„Å£„Å¶„ÅÑ„Å¶ÊîªÊíÉ„Åß„Åç„Å™„ÅÑÔºÅ`);
                return;
            }

            const oppCardIndex = state.opponent.field.indexOf(oppCard);
            if (oppCardIndex > 2) { // ÂæåÂàó„ÅÆ„Ç´„Éº„Éâ„Åß„ÅØÊîªÊíÉ„Åß„Åç„Å™„ÅÑ„É´„Éº„É´„ÇíÁõ∏Êâã„Å´„ÇÇÈÅ©Áî®
                return;
            }

            if (oppCard.attachedPower >= oppCard.requiredPower) { // Check power requirement
            const totalOppA = effectiveOppAttack; // Use effectiveOppAttack for damage
                const playerFrontRowCards = [state.player.field[0], state.player.field[1], state.player.field[2]].filter(p => p !== null);

                if (playerFrontRowCards.length > 0) {
                    // Attack player's first available front row card
                    const targetCard = playerFrontRowCards[0];
                    targetCard.hp -= totalOppA;
                    addLog(getFormattedText('log_opponent_attack', { oppCardRank: oppCard.rank, targetCardRank: targetCard.rank, totalOppA: totalOppA }));
                    opponentAttackedIds.push(oppCard.id); // ÊîªÊíÉÊ∏à„Åø„Å®„Åó„Å¶ÁôªÈå≤
                    if (targetCard.hp <= 0) {
                        const idx = state.player.field.indexOf(targetCard);
                        if (idx !== -1) {
                            state.player.field[idx] = null;
                            state.player.grave++;
                            state.opponent.points++; // Áõ∏Êâã„ÅÆ„Éù„Ç§„É≥„Éà„ÇíÂ¢ó„ÇÑ„Åô
                            addLog(getFormattedText('log_player_card_destroyed', { rank: targetCard.rank }));
                            if (checkWin()) return; // ‚òÖ‚òÖ‚òÖ Check for win immediately ‚òÖ‚òÖ‚òÖ
                        }
                    }
                } else {
                    addLog(getFormattedText('log_opponent_no_target', { rank: oppCard.rank }));
                }
            } else if (oppCard) { // ÊîªÊíÉÊ∏à„Åø„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆËøΩÂä†
                addLog(getFormattedText('log_opponent_attack_fail_no_power', { rank: oppCard.rank }));
            }
    });

    // End opponent's turn and pass back to player
    state.opponent.power = 5; // Restore opponent's power
    state.player.powerInjectedThisTurn = false; // Reset player's power injection flag
    
    stateCheck(() => { // Now asynchronous
        if (state.gameOver) return;

        addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
        rotateFields();

        // Player draws a card
        if (state.player.deck.length > 0) {
            state.player.hand.push(state.player.deck.shift());
            addLog(getText('log_player_drew_card'));
        } else {
            addLog(getText('log_player_deck_empty'));
        }

        state.turn = 'player';
        document.getElementById('status-text').textContent = "Ëá™„Çø„Éº„É≥";
        addLog(getText('log_opponent_turn_end'));
        render();
        checkWin(); // Check for game over after opponent's turn
    });
}

function rotateFields() {
    addLog(getText('log_field_rotating'));
    // Player's field
    const pField = state.player.field;
    if (!pField.every(c => c === null)) {
        const pLast = pField.pop();
        pField.unshift(pLast);
    }
    // Opponent's field
    const oField = state.opponent.field;
    if (!oField.every(c => c === null)) {
        const oLast = oField.pop();
        oField.unshift(oLast);
    }
}

function showGameOverScreen(result) {
    if (state.gameOver) return;
    state.gameOver = true;

    const resultText = document.getElementById('game-result-text');
    let message = '';
    switch (result) {
        case 'win':
            message = getText('win_message');
            addLog(getText('log_win'));
            break;
        case 'lose':
            message = getText('lose_message');
            addLog(getText('log_lose'));
            break;
        case 'draw':
            message = getText('draw_message');
            addLog(getText('log_draw'));
            break;
    }
    resultText.textContent = message;

    // Display game log on the game over screen
    const gameLog = document.getElementById('log-area').innerHTML;
    document.getElementById('game-over-log').innerHTML = gameLog;

    showScreen('game-over-screen');
}

function checkWin() {
    if (state.gameOver || state.canPlaceCard) return false;

    const playerHasCards = state.player.field.some(c => c !== null);
    const opponentHasCards = state.opponent.field.some(c => c !== null);

    // 1. Field Annihilation Check (takes precedence)
    if (!playerHasCards && !opponentHasCards) {
        showGameOverScreen('draw');
        return true;
    }
    if (!opponentHasCards) {
        showGameOverScreen('win');
        return true;
    }
    if (!playerHasCards) {
        showGameOverScreen('lose');
        return true;
    }

    // 2. Point Victory Check (if no one has been annihilated)
    const playerWinsByPoints = state.player.points >= 5;
    const opponentWinsByPoints = state.opponent.points >= 5;

    if (playerWinsByPoints && opponentWinsByPoints) {
        showGameOverScreen('draw');
        return true;
    }
    if (playerWinsByPoints) {
        showGameOverScreen('win');
        return true;
    }
    if (opponentWinsByPoints) {
        showGameOverScreen('lose');
        return true;
    }

    return false;
}

function startGameWithDeck(deckId) {
    const savedDeck = localStorage.getItem(`deck_cards_${deckId}`);
    if (!savedDeck) {
        alert(getText('deck_not_saved'));
        return;
    }
    const parsedDeck = JSON.parse(savedDeck);
    if (parsedDeck.length !== 30) {
        alert(getText('deck_not_30') + parsedDeck.length + ')');
        return;
    }

    state = getInitialState(); // Reset all state variables

    // 1. Player's deck setup
    let playerDeck = parsedDeck.map(d => {
        const cardData = { ...d };
        delete cardData.id;
        return new Card(d.suit, d.rank, d.type, d.monsterName, cardData);
    });
    // Shuffle player's deck
    for (let i = playerDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [playerDeck[i], playerDeck[j]] = [playerDeck[j], playerDeck[i]];
    }
    state.player.deck = playerDeck;
    state.player.hand = state.player.deck.splice(0, 5); // ÂàùÊúüÊâãÊú≠5Êûö

    // „Éû„É™„Ç¨„É≥Âá¶ÁêÜ („Éó„É¨„Ç§„É§„Éº)
    let playerMulliganCount = 0;
    while (!state.player.hand.some(c => !c.isSupport) && playerMulliganCount < 5) { // ÊúÄÂ§ß5Âõû„Åæ„Åß„Éû„É™„Ç¨„É≥
        addLog(getText('log_player_mulligan'));
        state.player.deck.push(...state.player.hand); // ÊâãÊú≠„Çí„Éá„ÉÉ„Ç≠„Å´Êàª„Åô
        for (let i = state.player.deck.length - 1; i > 0; i--) { // „Éá„ÉÉ„Ç≠„ÇíÂÜç„Ç∑„É£„ÉÉ„Éï„É´
            const j = Math.floor(Math.random() * (i + 1));
            [state.player.deck[i], state.player.deck[j]] = [state.player.deck[j], state.player.deck[i]];
        }
        state.player.hand = state.player.deck.splice(0, 5); // ÂÜçÂ∫¶5ÊûöÂºï„Åè
        playerMulliganCount++;
    }
    if (playerMulliganCount >= 5) {
        addLog(getText('log_player_mulligan_warning'));
    }

    // 2. Opponent's deck setup (Random)
    let opponentFullDeck = [];
    SUITS.forEach(suit => {
        RANKS.forEach(rank => opponentFullDeck.push(new Card(suit, rank)));
        SUPPORTS.forEach(a => opponentFullDeck.push(new Card(suit, a, 'support')));
    });
     for (let i = opponentFullDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [opponentFullDeck[i], opponentFullDeck[j]] = [opponentFullDeck[j], opponentFullDeck[i]];
    }
    state.opponent.deck = opponentFullDeck.slice(0, 30); // Take 30 cards for the deck
    state.opponent.hand = state.opponent.deck.splice(0, 5); // ÂàùÊúüÊâãÊú≠5Êûö

    // „Éû„É™„Ç¨„É≥Âá¶ÁêÜ (Áõ∏Êâã)
    let opponentMulliganCount = 0;
    while (!state.opponent.hand.some(c => !c.isSupport) && opponentMulliganCount < 5) { // ÊúÄÂ§ß5Âõû„Åæ„Åß„Éû„É™„Ç¨„É≥
        addLog(getText('log_opponent_mulligan'));
        state.opponent.deck.push(...state.opponent.hand); // ÊâãÊú≠„Çí„Éá„ÉÉ„Ç≠„Å´Êàª„Åô
        for (let i = state.opponent.deck.length - 1; i > 0; i--) { // „Éá„ÉÉ„Ç≠„ÇíÂÜç„Ç∑„É£„ÉÉ„Éï„É´
            const j = Math.floor(Math.random() * (i + 1));
            [state.opponent.deck[i], state.opponent.deck[j]] = [state.opponent.deck[j], state.opponent.deck[i]];
        }
        state.opponent.hand = state.opponent.deck.splice(0, 5); // ÂÜçÂ∫¶5ÊûöÂºï„Åè
        opponentMulliganCount++;
    }
    if (opponentMulliganCount >= 5) {
        addLog(getText('log_opponent_mulligan_warning'));
    }

    // 3. Start Game
    showScreen('game-screen');
    startRoulette();
}

function initBattle() {
    openDeckList('battle');
}

// Event listeners for attack menu buttons
document.getElementById('menu-attack-btn').onclick = () => {
    if (state.selectedCard) {
        state.isAttacking = true;
        addLog(getFormattedText('log_select_attack_target', { rank: state.selectedCard.rank }));
        render(); // Rerender to show potential target highlights
    }
};

document.getElementById('menu-special-btn').onclick = () => {
    if (state.selectedCard && state.selectedCard.specialAbility === 'kari_heal') {
        if (state.player.usedSpecialAbilityIds.includes(state.selectedCard.id)) {
            addLog(getText('log_special_already_used'));
            hideAttackMenu();
            state.selectedCard = null;
            render();
            return;
        }
        const healableTargets = state.player.field.slice(0, 3).filter(c => c && c.hp < c.maxHp);
        if (healableTargets.length === 0) {
            addLog(getText('log_kariheal_no_targets'));
            hideAttackMenu();
            state.selectedCard = null;
            render();
            return;
        }
        state.isHealingTargetSelection = true;
        addLog(getText('log_kariheal_initiate'));
        hideAttackMenu();
        render();
    } else {
        addLog(getText('log_special_not_implemented'));
        hideAttackMenu();
        state.selectedCard = null;
        render();
    }
};

document.getElementById('menu-cancel-btn').onclick = () => {
    hideAttackMenu();
    state.selectedCard = null;
    render();
};

function startRoulette() {
    showScreen('coin-flip-screen');
    const title = document.getElementById('coin-flip-title');
    const result = document.getElementById('cointoss-result');
    const btn = document.getElementById('cointoss-btn');
    
    title.textContent = "ÂÖàÊîªÊ±∫ÂÆö";
    result.textContent = "";
    btn.style.display = 'none';

    let count = 0;
    const interval = setInterval(() => {
        title.textContent = count % 2 === 0 ? "„Éó„É¨„Ç§„É§„ÉºÂÖàÊîªÔºü" : "Áõ∏ÊâãÂÖàÊîªÔºü";
        if (++count > 10) {
            clearInterval(interval);
            const isPlayer = Math.random() > 0.5;
            state.turn = isPlayer ? 'player' : 'opponent';
            title.textContent = isPlayer ? "„Éó„É¨„Ç§„É§„ÉºÂÖàÊîª" : "Áõ∏ÊâãÂÖàÊîª";
            setTimeout(() => {
                showScreen('game-screen');
                // ÂÖàË°å„ÉªÂæåÊîª„Å´Èñ¢„Çè„Çâ„Åö„ÄÅ„Åæ„ÅöÁõ∏Êâã„ÅÆË£èÂêë„ÅçÂàùÊúüÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫„Å∏
                state.isOpponentInitialPlacement = true; // Áõ∏Êâã„ÅÆÁâπÊÆäÂàùÊúüÈÖçÁΩÆ„É¢„Éº„Éâ„ÇíON
                state.canPlaceCard = false; // „Éó„É¨„Ç§„É§„Éº„ÅØ„Åæ„Å†ÈÖçÁΩÆ„Åß„Åç„Å™„ÅÑ
                state.statusText = "Áõ∏Êâã„ÅåÈÖçÁΩÆ„Åó„Å¶„ÅÑ„Åæ„Åô...";
                addLog(getText(state.turn === 'player' ? 'log_player_first' : 'log_opponent_first'));
                render();
                // Áõ∏Êâã„ÅÆÁâπÊÆäÂàùÊúüÈÖçÁΩÆAI„ÇíÂëº„Å∂ (opponentAIÈñ¢Êï∞ÂÜÖ„Åß„Éó„É¨„Ç§„É§„Éº„ÅÆÈÖçÁΩÆ„Éï„Çß„Éº„Ç∫„Å´ÈÅ∑Áßª„Åô„Çã)
                setTimeout(opponentAI, 1000);
            }, 1000);
        }
    }, 100);
}
</script>
</body>
</html>