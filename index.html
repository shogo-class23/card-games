<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Roen Card Game - Restored Version</title>
    <style>
        :root {
            --fire-color: #FF7B7B; --water-color: #7B8CFF;
            --wind-color: #7BFFB8; --earth-color: #C19A6B;
            --card-width: 63px; /* 90 * 0.7 */
            --card-height: 91px; /* 130 * 0.7 */
        }
        body { background-color: #3D3D3D; color: #F0F0F0; font-family: sans-serif; display: flex; justify-content: center; margin: 0; overflow: hidden; }
        .game-container { width: 100%; max-width: 1000px; display: flex; flex-direction: column; height: 100vh; position: relative; }
        
        /* 654 / 321 のグリッド配置 */
        .field { 
            display: grid; 
            grid-template-areas: "slot0 slot1 slot2" "slot5 slot4 slot3"; 
            gap: 10px; padding: 15px; justify-content: center; background: rgba(0,0,0,0.2);
        }
        .field.opponent-field-layout {
            grid-template-areas: "slot3 slot4 slot5" "slot2 slot1 slot0";
        }
        .card-slot { width: var(--card-width); height: var(--card-height); background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; position: relative; border: 1px dashed rgba(255,255,255,0.2); }
        
        /* カードデザインの復元 */
        .card { 
            width: 100%; height: 100%; border-radius: 8px; color: #333; cursor: pointer; 
            position: relative; box-sizing: border-box; display: flex; flex-direction: column;
            justify-content: space-between; padding: 5px; font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .card.fire { background-color: var(--fire-color); }
        .card.water { background-color: var(--water-color); }
        .card.wind { background-color: var(--wind-color); }
        .card.earth { background-color: var(--earth-color); }
        .card.back { background-color: #666; border: 2px solid #444; } /* 相手の手札用 */

        .card.selected { outline: 4px solid yellow; z-index: 10; }
        .card.attacked { filter: grayscale(0.9) brightness(0.7); cursor: default; }

        .rank-top { font-size: 1.2em; text-align: left; }
        .suit-center { background: rgba(255,255,255,0.4); padding: 2px 8px; border-radius: 4px; align-self: center; font-size: 0.8em; }
        .stats-bottom { font-size: 0.8em; display: flex; flex-direction: column; align-items: flex-start; }
        .hp-badge { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.6); color: white; padding: 1px 4px; border-radius: 4px; font-size: 0.7em; }

        .player-hand, .opponent-hand-area { height: calc(var(--card-height) + 20px); display: flex; justify-content: center; align-items: center; gap: 8px; background: rgba(0,0,0,0.4); }
        .player-hand .card { width: var(--card-width); height: var(--card-height); } /* Revert to smaller size */
        .opponent-hand-area .card { width: var(--card-width); height: var(--card-height); }
        .card-pile-slot { 
            width: var(--card-width); 
            height: var(--card-height); 
            background: rgba(255,255,255,0.08); /* Slightly different background */
            border-radius: 8px; 
            border: 1px dashed rgba(255,255,255,0.2); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            position: relative; 
            font-size: 0.9em; 
            font-weight: bold; 
            color: #F0F0F0;
            overflow: hidden; /* Hide overflow of potential card backs */
        }
        .card-pile-slot.empty::before {
            content: "0"; /* Display 0 when empty */
            color: rgba(255,255,255,0.4);
        }
        .card-pile-slot.has-cards::before {
            content: attr(data-count); /* Display count from data attribute */
            color: #F0F0F0;
            position: absolute;
            z-index: 2; /* Above card back if any */
        }
        .card-pile-slot.deck-back {
            background-color: #666; /* Card back color */
            border: 2px solid #444;
            display: flex; /* Ensure content is centered even if it's just a count */
            justify-content: center;
            align-items: center;
        }
        .log-area { position: absolute; left: 10px; top: 10px; width: 200px; height: 150px; background: rgba(0,0,0,0.8); font-size: 10px; overflow-y: auto; padding: 10px; border-radius: 5px; border: 1px solid #555; z-index: 100; }
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 15px;
            background: #222;
            color: #F0F0F0;
            font-size: 0.9em;
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
        }
        .info-row.opponent-info-row {
            flex-direction: row-reverse; /* Mirror effect */
        }
        .info-row .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .info-row .info-item.power-display {
            color: #FFD700;
            font-weight: bold;
            font-size: 1.1em;
        }

        .boundary-line {
            height: 2px;
            background: #555;
            margin: 0;
        }

        .control-lane {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: #222;
            padding: 10px;
            flex-grow: 0; /* Prevents it from taking extra space vertically */
        }
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .status-text {
            color: yellow;
            font-weight: bold;
            font-size: 0.9em;
            text-align: center;
            min-height: 1.2em; /* Ensure space even when empty */
        }
        .score-display {
            font-size: 4em; /* Huge score */
            font-weight: bold;
            color: #F0F0F0;
            min-width: 80px; /* Ensure consistent width */
            text-align: center;
        }
        .score-display.opponent-score {
            color: #FF7B7B; /* Reddish for opponent */
        }
        .score-display.player-score {
            color: #7B8CFF; /* Bluish for player */
        }
        .game-button { padding: 8px 16px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; }
        .power-display { color: #FFD700; font-weight: bold; }
    </style>
</head>
<body>

<div class="game-container">
    <div id="log-area" class="log-area"><strong>ゲームログ</strong></div>
    
    <div id="opponent-hand" class="opponent-hand-area"></div>
    <div class="opponent-area"><div id="opponent-field" class="field opponent-field-layout"></div></div>

    <div id="opponent-info-row" class="info-row opponent-info-row">
        <div class="info-item">手札: <span id="opp-hand-count">5</span></div>
        <div class="info-item">墓地: <div id="opp-graveyard" class="card-pile-slot"></div></div>
        <div class="info-item">山札: <div id="opp-deck" class="card-pile-slot"></div></div>
        <div class="info-item power-display">パワー: <span id="opp-power-display">0</span></div>
    </div>

    <div class="boundary-line"></div>

    <div class="control-lane">
        <div class="score-display opponent-score" id="opp-score-display">HP: <span id="opp-hp-value">0</span></div>
        <div class="center-controls">
            <div id="status-text" class="status-text">準備OK</div>
            <div id="controls">
                <button id="ok-btn" class="game-button">配置OK</button>
                <div id="battle-controls" style="display:none; flex-direction: column; gap: 10px; align-items: center;">
                    <button id="power-btn" class="game-button" style="background:#ccac00">パワー注入</button>
                    <button id="end-turn-btn" class="game-button">ターン終了</button>
                </div>
            </div>
            <div id="game-status" class="game-status"></div>
        </div>
        <div class="score-display player-score" id="ply-score-display">HP: <span id="ply-hp-value">0</span></div>
    </div>

    <div class="boundary-line"></div>

    <div id="player-info-row" class="info-row player-info-row">
        <div class="info-item power-display">パワー: <span id="ply-power-display">5</span></div>
        <div class="info-item">山札: <div id="ply-deck" class="card-pile-slot"></div></div>
        <div class="info-item">墓地: <div id="ply-graveyard" class="card-pile-slot"></div></div>
        <div class="info-item">手札: <span id="ply-hand-count">0</span></div>
    </div>

    <div class="player-area"><div id="player-field" class="field"></div></div>
    <div id="player-hand" class="player-hand"></div>
</div>

<script>
const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10, '9': 9, '8': 8, '7': 7, '6': 6, '4': 4, '3': 3 };

class Card {
    constructor(suit, rank) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.suit = suit;
        this.rank = rank;
        this.value = RANK_VALUES[rank];
        this.hp = this.value;
        this.maxHp = this.value;
        this.attachedPower = 0;
        // 画像に基づき、ランクが高いほど必要パワーを多く設定
        this.requiredPower = this.value >= 13 ? 3 : this.value >= 9 ? 2 : 1;
    }
}

const state = {
    player: { hand: [], field: Array(6).fill(null), attackedIds: [], power: 5, hp: 20, deck: [], graveyard: [] },
    opponent: { handCount: 5, field: Array(6).fill(null), power: 5, hp: 20, deck: [], graveyard: [] },
    selectedCard: null,
    turn: 'player',
    statusText: '準備OK',
    canPlaceCard: true // New state to manage card placement phase
};

function addLog(msg) {
    const log = document.getElementById('log-area');
    log.innerHTML += `<div>> ${msg}</div>`;
    log.scrollTop = log.scrollHeight;
}

function render() {
    renderField('player-field', state.player.field, false);
    renderField('opponent-field', state.opponent.field, true);
    
    const handEl = document.getElementById('player-hand');
    handEl.innerHTML = '';
    state.player.hand.forEach(card => {
        const el = createCardEl(card);
        el.onclick = () => { state.selectedCard = card; render(); };
        if (state.selectedCard === card) el.classList.add('selected');
        handEl.appendChild(el);
    });

    const oppHandEl = document.getElementById('opponent-hand');
    oppHandEl.innerHTML = '';
    for(let i=0; i<state.opponent.handCount; i++) {
        const back = document.createElement('div');
        back.className = 'card back';
        oppHandEl.appendChild(back);
    }

    // Update new UI elements for info rows
    document.getElementById('opp-hand-count').textContent = state.opponent.handCount;
    // Graveyard
    const oppGraveyardEl = document.getElementById('opp-graveyard');
    oppGraveyardEl.dataset.count = state.opponent.graveyard.length;
    if (state.opponent.graveyard.length > 0) {
        oppGraveyardEl.classList.add('has-cards');
        oppGraveyardEl.classList.remove('empty');
    } else {
        oppGraveyardEl.classList.remove('has-cards');
        oppGraveyardEl.classList.add('empty');
    }
    // Deck
    const oppDeckEl = document.getElementById('opp-deck');
    oppDeckEl.dataset.count = `${state.opponent.deck.length}/30`;
    oppDeckEl.classList.add('deck-back'); // Always show deck back
    if (state.opponent.deck.length > 0) {
        oppDeckEl.classList.add('has-cards');
        oppDeckEl.classList.remove('empty');
    } else {
        oppDeckEl.classList.remove('has-cards');
        oppDeckEl.classList.add('empty');
    }
    document.getElementById('opp-power-display').textContent = state.opponent.power;

    document.getElementById('ply-hand-count').textContent = state.player.hand.length;
    // Graveyard
    const plyGraveyardEl = document.getElementById('ply-graveyard');
    plyGraveyardEl.dataset.count = state.player.graveyard.length;
    if (state.player.graveyard.length > 0) {
        plyGraveyardEl.classList.add('has-cards');
        plyGraveyardEl.classList.remove('empty');
    } else {
        plyGraveyardEl.classList.remove('has-cards');
        plyGraveyardEl.classList.add('empty');
    }
    // Deck
    const plyDeckEl = document.getElementById('ply-deck');
    plyDeckEl.dataset.count = `${state.player.deck.length}/30`;
    plyDeckEl.classList.add('deck-back'); // Always show deck back
    if (state.player.deck.length > 0) {
        plyDeckEl.classList.add('has-cards');
        plyDeckEl.classList.remove('empty');
    } else {
        plyDeckEl.classList.remove('has-cards');
        plyDeckEl.classList.add('empty');
    }
    document.getElementById('ply-power-display').textContent = state.player.power;

    document.getElementById('status-text').textContent = state.statusText;

    document.getElementById('opp-hp-value').textContent = state.opponent.hp;
    document.getElementById('ply-hp-value').textContent = state.player.hp;

    // Show/hide OK button and battle controls
    if (state.canPlaceCard) {
        document.getElementById('ok-btn').style.display = 'block';
        document.getElementById('battle-controls').style.display = 'none';
    } else {
        document.getElementById('ok-btn').style.display = 'none';
        document.getElementById('battle-controls').style.display = 'flex'; // This is now a column
    }
}

function renderField(id, field, isOpponent) {
    const el = document.getElementById(id);
    el.innerHTML = '';
    field.forEach((card, i) => {
        const slot = document.createElement('div');
        slot.className = 'card-slot';
        
        slot.style.gridArea = `slot${i}`;
        
        if (card) {
            const cardEl = createCardEl(card);
            if (!isOpponent && state.player.attackedIds.includes(card.id)) cardEl.classList.add('attacked');
            if (state.selectedCard === card) cardEl.classList.add('selected');

            cardEl.onclick = (e) => {
                e.stopPropagation();
                if (isOpponent) handleAttack(card);
                else handleFieldClick(card, i);
            };
            slot.appendChild(cardEl);
        } else {
            slot.innerHTML = `<span style="opacity:0.2">${i + 1}</span>`;
            if (state.canPlaceCard && !isOpponent) { // Only allow placing cards during placement phase
                slot.onclick = () => placeCard(i);
            } else {
                slot.onclick = null; // Disable click if not in placement phase
            }
        }
        el.appendChild(slot);
    });
}

function createCardEl(card) {
    const div = document.createElement('div');
    div.className = `card ${card.suit}`;
    div.innerHTML = `
        <div class="hp-badge">${card.hp}/${card.maxHp}</div>
        <div class="rank-top">${card.rank}</div>
        <div class="suit-center">${card.suit}</div>
        <div class="stats-bottom">
            <div>Power: ${card.attachedPower}/${card.requiredPower}</div>
            <div>ATK: ${card.value + card.attachedPower}</div>
        </div>
    `;
    return div;
}

function placeCard(index) {
    if (!state.canPlaceCard || !state.selectedCard) return; // Use canPlaceCard
    const cardIdx = state.player.hand.indexOf(state.selectedCard);
    if (cardIdx > -1) {
        state.player.field[index] = state.selectedCard;
        state.player.hand.splice(cardIdx, 1);
        state.selectedCard = null;
        state.statusText = `${state.player.field[index].rank}を配置しました。`;
        render();
    }
}

function handleFieldClick(card, index) {
    if (state.canPlaceCard) { // Use canPlaceCard
        state.player.field[index] = null;
        state.player.hand.push(card);
        state.statusText = `${card.rank}を手札に戻しました。`;
    } else {
        state.selectedCard = card;
    }
    render();
}

document.getElementById('power-btn').onclick = () => {
    if (!state.selectedCard || state.player.power <= 0 || state.canPlaceCard) return; // Prevent power injection during placement
    const card = state.selectedCard;
    if (state.player.field.includes(card) && card.attachedPower < card.requiredPower) {
        card.attachedPower++;
        state.player.power--;
        state.statusText = `パワー更新: ${card.rank} (K:${card.attachedPower}/${card.requiredPower})`;
        render();
    }
};

function handleAttack(targetCard) {
    if (state.canPlaceCard || !state.selectedCard) return; // Prevent attack during placement
    const attacker = state.selectedCard;
    if (state.player.attackedIds.includes(attacker.id)) {
        state.statusText = `${attacker.rank}は既に攻撃済みです。`;
        render();
        return;
    }
    
    const totalAtk = attacker.value + attacker.attachedPower;
    targetCard.hp -= totalAtk;
    state.player.attackedIds.push(attacker.id);
    
    state.statusText = `${attacker.rank}の攻撃: ${totalAtk}ダメージ`;
    if (targetCard.hp <= 0) {
        const idx = state.opponent.field.indexOf(targetCard);
        if (idx !== -1) {
            state.opponent.field[idx] = null;
            state.opponent.graveyard.push(targetCard); // Move to graveyard
        }
        state.statusText += ` ${targetCard.rank}を撃破`;
    }
    state.selectedCard = null;
    render();
}

function init() {
    const suits = ['fire', 'water', 'wind', 'earth'];
    const ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7']; // Expanded ranks to ensure enough cards for a 30-card deck
    const totalDeckSize = 30; // Desired total deck size

    let fullDeck = [];
    suits.forEach(suit => {
        ranks.forEach(rank => {
            fullDeck.push(new Card(suit, rank));
        });
    });

    // Trim the deck to totalDeckSize if it's larger
    fullDeck = fullDeck.slice(0, totalDeckSize);

    // Shuffle the deck
    for (let i = fullDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [fullDeck[i], fullDeck[j]] = [fullDeck[j], fullDeck[i]];
    }

    // Deal initial hands
    state.player.hand = fullDeck.splice(0, 5); // Player gets 5 cards
    state.opponent.hand = fullDeck.splice(0, 3); // Opponent gets 3 cards
    state.opponent.handCount = state.opponent.hand.length; // Update opponent's hand count

    // Remaining cards go into respective decks (for simplicity, split evenly)
    state.player.deck = fullDeck.splice(0, Math.floor(fullDeck.length / 2));
    state.opponent.deck = fullDeck; // Whatever remains for opponent

    // Place some initial cards for opponent on field for testing purposes
    for(let i=0; i<3; i++) {
        if (state.opponent.deck.length > 0) {
            const oppCard = state.opponent.deck.shift(); // Take from deck
            state.opponent.field[i] = oppCard;
        }
    }

    console.log("--- Initial Card Distribution ---");
    console.log("Player Hand:", state.player.hand.length);
    console.log("Player Field:", state.player.field.filter(c => c !== null).length);
    console.log("Player Deck:", state.player.deck.length);
    console.log("Opponent Hand:", state.opponent.hand.length);
    console.log("Opponent Field:", state.opponent.field.filter(c => c !== null).length);
    console.log("Opponent Deck:", state.opponent.deck.length);
    console.log("---------------------------------");
    
    render();
}

document.getElementById('ok-btn').onclick = () => {
    state.canPlaceCard = false; // End card placement phase
    state.statusText = "バトル開始！";
    addLog("配置フェーズ終了。バトル開始。");
    render();
};

document.getElementById('end-turn-btn').onclick = () => {
    state.player.attackedIds = [];
    state.player.power = 5; // Restore power
    state.statusText = "ターン終了。パワーを回復しました。";
    addLog("ターン終了/パワー回復");
    render();
};

init();
</script>
</body>
</html>