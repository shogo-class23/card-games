<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roen Card Game</title>
    <style>
        :root {
            --fire-color: #FF7B7B;
            --water-color: #7B8CFF;
            --wind-color: #7BFFB8;
            --earth-color: #C19A6B;
            --border-color: #555;
            --field-bg: rgba(0, 0, 0, 0.2);
            --hand-bg: rgba(0, 0, 0, 0.3);
            --card-width: 90px;
            --card-height: 130px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #3D3D3D;
            color: #F0F0F0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            border: 2px solid var(--border-color);
            background: #4A4A4A;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Top and Bottom Areas */
        .opponent-area, .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .player-area {
            flex-direction: column-reverse;
        }

        /* Info Bars */
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 20px;
            background: rgba(0, 0, 0, 0.2);
        }
        .deck-info, .graveyard-info {
            display: flex;
            align-items: center;
        }
        .deck-info .deck, .graveyard-info .graveyard {
            width: calc(var(--card-width) * 0.7);
            height: calc(var(--card-height) * 0.7);
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            background: #666;
            margin: 0 10px;
        }
        .deck-info span, .graveyard-info span {
            font-size: 14px;
        }
        .opponent-area .deck { order: 1; }
        .opponent-area .deck-label { order: 2; }


        /* Fields */
        .field {
            display: grid;
            grid-template-columns: repeat(3, var(--card-width));
            justify-content: center; /* Center the grid of cards */
            gap: 0px;
            padding: 0px;
            background: var(--field-bg);
            flex-grow: 1;
            /* Remove align-items and justify-items to make cards fill grid cell */
        }

        /* Center Area */
        .center-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 40px;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        .score {
            font-size: 48px;
            font-weight: bold;
        }
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #action-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            margin-top: 10px;
        }
        #action-panel h4 {
            margin: 0;
            color: white;
            font-size: 16px;
        }
        .game-button {
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
        }
        .game-button:hover {
            background-color: #45a049;
        }
        .turn-display {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700; /* Gold */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        /* Player Hand */
        .player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 10px; /* Adjusted padding to move hand up */
            min-height: calc(var(--card-height) + 20px);
            background: var(--hand-bg);
        }
        .player-hand .card {
            margin: 0; /* No overlap for full visibility */
            transition: transform 0.2s ease, margin 0.2s ease;
        }
        .player-hand .card:hover {
            transform: translateY(-20px) scale(1.1);
            margin: 0 10px;
            z-index: 100;
        }

        /* Card Styling */
        .card-slot {
            width: var(--card-width);
            height: var(--card-height);
            border: none; /* No border for complete adjacency */
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        }
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border: none; /* No border for complete adjacency */
            border-radius: 8px;
            background-color: #ddd;
            color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            position: relative;
            user-select: none;
        }
        .card.fire { border-color: var(--fire-color); }
        .card.water { border-color: var(--water-color); }
        .card.wind { border-color: var(--wind-color); }
        .card.earth { border-color: var(--earth-color); }

        .card-header, .card-footer {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            font-size: 18px;
        }
        .card-body {
            text-align: center;
            font-size: 14px;
        }
        .card-body .attribute {
             font-size: 12px;
             padding: 2px 4px;
             border-radius: 4px;
             color: white;
        }
        .fire .attribute { background-color: var(--fire-color); }
        .water .attribute { background-color: var(--water-color); }
        .wind .attribute { background-color: var(--wind-color); }
        .earth .attribute { background-color: var(--earth-color); }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 15px;
            background-color: #555;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background-color: #32CD32; /* Green */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        
        .card.selected {
            transform: scale(1.1);
            border-color: yellow;
            box-shadow: 0 0 15px yellow;
        }
        .hp-display {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        /* Log Area */
        .log-area {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
        }
        .log-area h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #888;
        }
        .log-area p {
            margin: 0 0 5px 0;
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Log Area -->
    <div id="log-area" class="log-area">
        <h3>ゲームログ</h3>
    </div>

    <!-- Opponent's Area -->
    <div class="opponent-area">
        <div id="opponent-field" class="field"></div>
        <div class="info-bar">
            <div id="opponent-graveyard" class="graveyard-info">
                <span class="graveyard-label">墓地: 0</span>
                <div class="graveyard"></div>
            </div>
            <div id="opponent-deck" class="deck-info">
                <div class="deck"></div>
                <span class="deck-label">デッキ: 18/30</span>
            </div>
        </div>
    </div>

    <!-- Center Area -->
    <div class="center-area">
        <div id="opponent-score" class="score">0</div>
        <div class="center-controls">
            <button id="placement-ok-button" class="game-button">配置OK</button>
            <button id="end-turn-button" class="game-button" style="display:none;">ターン終了</button>
            <div id="current-turn-display" class="turn-display"></div>
        </div>
        <div id="player-score" class="score">0</div>
    </div>

    <!-- Player's Area -->
    <div class="player-area">
        <div id="player-hand" class="player-hand"></div>
        <div id="player-field" class="field"></div>
        <div class="info-bar">
            <div id="player-deck" class="deck-info">
                 <span class="deck-label">デッキ: 17/30</span>
                <div class="deck"></div>
            </div>
            <div id="player-graveyard" class="graveyard-info">
                <div class="graveyard"></div>
                <span class="graveyard-label">墓地: 0</span>
            </div>
        </div>
    </div>
</div>

    <div id="action-panel" style="display:none;">
        <h4 id="attacking-card-info"></h4>
        <button id="attack-button" class="game-button">攻撃</button>
        <button id="special-attack-button" class="game-button" disabled>特別技 (選択不可)</button>
        <button id="cancel-attack-button" class="game-button">キャンセル</button>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {    const SUITS = ['fire', 'water', 'wind', 'earth'];
    const RANKS = ['A', 'K', 'Q', 'J', '9', '8', '6', '4', '3'];
    const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '9': 9, '8': 8, '6': 6, '4': 4, '3': 3 };

    class Card {
        constructor(suit, rank) {
            this.id = `${suit}-${rank}-${Math.random()}`;
            this.suit = suit;
            this.rank = rank;
            this.value = RANK_VALUES[rank];
            this.hp = this.value;
            this.maxHp = this.value;
        }
    }

    const state = {
        player: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 17,
            totalDeck: 30,
        },
        opponent: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 18,
            totalDeck: 30,
        },
        selectedCard: null,
        gameStarted: false,
        turn: null, // Track current player: 'player' or 'opponent'
        turnCount: 0, // Track the number of turns
        attackingCardId: null, // ID of the card currently selected to attack
        attackCountThisTurn: 0, // Number of attacks made this turn
    };

    function createDeck() {
        const deck = [];
        // A full deck would be 30 cards, but for this demo, we just create some examples.
        for (let i = 0; i < 30; i++) {
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            deck.push(new Card(suit, rank));
        }
        return deck;
    }

    function createCardElement(card, isFaceDown = false) {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${card.suit}`;
        cardEl.dataset.cardId = card.id;

        if (isFaceDown) {
            cardEl.innerHTML = `
                <div class="card-header"></div>
                <div class="card-body" style="font-size: 24px;">?</div>
                <div class="card-footer"></div>
            `;
            cardEl.style.backgroundColor = '#888';
            return cardEl;
        }

        cardEl.innerHTML = `
            <div class="card-header">
                <span>${card.rank}</span>
                <span class="attribute">${card.suit.charAt(0).toUpperCase()}</span>
            </div>
            <div class="hp-display">${card.hp}</div>
            <div class="card-body">
                <span class="attribute">${card.suit}</span>
            </div>
            <div class="card-footer">
                <span>${card.rank}</span>
            </div>
        `;
        return cardEl;
    }

    function addLog(message) {
        const logArea = document.getElementById('log-area');
        const p = document.createElement('p');
        p.textContent = `> ${message}`;
        logArea.appendChild(p);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function updateTurnDisplay() {
        const turnDisplay = document.getElementById('current-turn-display');
        const endTurnButton = document.getElementById('end-turn-button'); // Get button here
        if (state.gameStarted && state.turn) {
            turnDisplay.textContent = `${state.turn === 'player' ? 'あなたの番' : '相手の番'}`;
            if (state.turn === 'player') {
                endTurnButton.style.display = 'block';
            } else {
                endTurnButton.style.display = 'none';
            }
        } else {
            turnDisplay.textContent = '配置準備中';
            endTurnButton.style.display = 'none'; // Ensure button is hidden during setup
        }
    }
    
    function onPlayerCardClick(card, cardEl) { // Renamed from onHandCardClick
        if (!state.gameStarted || state.turn !== 'player') {
            addLog('ゲームが開始していないか、相手の番です。');
            return;
        }

        const actionPanel = document.getElementById('action-panel');
        const attackingCardInfo = document.getElementById('attacking-card-info');

        // If a card is already selected for attack, clicking another player card
        // deselects the current attacking card and selects the new one.
        if (state.attackingCardId) {
            const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
            if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
            if (state.attackingCardId === card.id) { // Clicked the same attacking card
                state.attackingCardId = null;
                actionPanel.style.display = 'none';
                return;
            }
        }
        
        state.attackingCardId = card.id;
        cardEl.classList.add('selected-attack');
        attackingCardInfo.textContent = `選択中のカード: ${card.suit} ${card.rank} (攻撃力: ${card.value})`;
        actionPanel.style.display = 'flex';
        addLog(`自分のカード ${card.suit} ${card.rank} を選択しました。攻撃対象を選んでください。`);
    }

    function onOpponentFieldCardClick(card, cardEl) {
        if (!state.attackingCardId) {
            addLog('まず自分のカードを選択してください。');
            return;
        }
        if (state.attackCountThisTurn >= 3) {
            addLog('今ターンはこれ以上攻撃できません。');
            return;
        }

        const attackingCard = state.player.field.flat().find(c => c && c.id === state.attackingCardId);
        if (!attackingCard) {
            addLog('選択中の攻撃カードが見つかりません。');
            return;
        }

        // Only front row cards can attack/be attacked (simplified for now as all field cards can attack/be attacked)
        // More sophisticated logic would check card position in field[0-2] for front row

        addLog(`${attackingCard.suit} ${attackingCard.rank} が ${card.suit} ${card.rank} を攻撃！`);
        addLog(`${card.suit} ${card.rank} のHPが ${attackingCard.value} 減少！`);

        card.hp -= attackingCard.value;
        state.attackCountThisTurn++;
        
        // Check if opponent card is destroyed
        if (card.hp <= 0) {
            addLog(`${card.suit} ${card.rank} は破壊され、墓地へ送られました。`);
            state.opponent.graveyard.push(card);
            // Remove card from field
            const indexInField = state.opponent.field.findIndex(c => c && c.id === card.id);
            if (indexInField !== -1) {
                state.opponent.field[indexInField] = null;
            }
        } else {
            addLog(`${card.suit} ${card.rank} の残りHP: ${card.hp}/${card.maxHp}`);
        }

        // Deselect attacking card and hide action panel
        const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
        if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
        state.attackingCardId = null;
        document.getElementById('action-panel').style.display = 'none';

        render(); // Re-render to reflect changes
    }

    function render() {
        // Render Player Hand
        const playerHandEl = document.getElementById('player-hand');
        playerHandEl.innerHTML = '';
        state.player.hand.forEach(card => {
            const cardEl = createCardElement(card);
            cardEl.addEventListener('click', () => onPlayerCardClick(card, cardEl));
            playerHandEl.appendChild(cardEl);
        });

        // Render Fields
        renderField('player-field', state.player.field, 'player');
        renderField('opponent-field', state.opponent.field, 'opponent');

        // Update Info Panels (static as per requirement)
        document.querySelector('#player-deck .deck-label').textContent = `デッキ: ${state.player.deckCount}/${state.player.totalDeck}`;
        document.querySelector('#player-graveyard .graveyard-label').textContent = `墓地: ${state.player.graveyard.length}`;
        document.querySelector('#opponent-deck .deck-label').textContent = `デッキ: ${state.opponent.deckCount}/${state.opponent.totalDeck}`;
        document.querySelector('#opponent-graveyard .graveyard-label').textContent = `墓地: ${state.opponent.graveyard.length}`;
        
        updateTurnDisplay(); // Update turn display on render
    }

    function renderField(fieldId, fieldCards, playerType) { // Added playerType parameter
        const fieldEl = document.getElementById(fieldId);
        fieldEl.innerHTML = '';
        fieldCards.forEach((card, index) => {
            if (card) {
                const cardEl = createCardElement(card);
                if (playerType === 'player') {
                    cardEl.addEventListener('click', () => onPlayerCardClick(card, cardEl)); // Player's own field cards
                } else { // Opponent's field cards
                    cardEl.addEventListener('click', () => onOpponentFieldCardClick(card, cardEl));
                }
                fieldEl.appendChild(cardEl);
            } else {
                const slotEl = document.createElement('div');
                slotEl.className = 'card-slot';
                slotEl.dataset.slotIndex = index;
                if (fieldId === 'player-field') {
                    slotEl.addEventListener('click', () => onSlotClick(index));
                }
                fieldEl.appendChild(slotEl);
            }
        });
    }

    function onSlotClick(index) {
        if (state.gameStarted) {
            addLog('ゲーム開始後は配置できません。');
            return;
        }
        if (!state.selectedCard) {
            addLog('先に手札から配置するカードを選択してください。');
            return;
        }
        if (state.player.field[index]) {
            addLog('その場所には既にカードが配置されています。');
            return;
        }

        const cardToPlace = state.selectedCard;
        state.player.hand = state.player.hand.filter(c => c.id !== cardToPlace.id);
        state.player.field[index] = cardToPlace;
        
        state.selectedCard = null;

        addLog(`「${cardToPlace.suit} ${cardToPlace.rank}」をフィールドに配置しました。`);
        render();
    }

    function opponentTurnLogic() {
        addLog("相手のターンです...");
        // Simulate opponent action for a few seconds
        setTimeout(() => {
            // Opponent could draw, place cards, attack, etc.
            // For now, just ends turn
            addLog("相手がターンを終了しました。");
            endTurn();
        }, 3000); // 3 second delay
    }

    function startTurn(player) {
        state.turn = player;
        state.turnCount++;
        addLog(`ターン ${state.turnCount}: ${player === 'player' ? 'あなたの番' : '相手の番'}`);
        updateTurnDisplay();
        render(); // Ensure UI reflects current turn
        if (player === 'opponent') {
            opponentTurnLogic();
        }
    }

    function endTurn() {
        state.attackCountThisTurn = 0; // Reset attack count for the new turn
        const nextPlayer = state.turn === 'player' ? 'opponent' : 'player';
        startTurn(nextPlayer);
    }

    function setupInitialState() {
        addLog("メインフェーズに移行 (準備)");
        
        state.player.hand = [
            new Card('earth', '9'),
            new Card('fire', '6'),
            new Card('fire', '4'),
            new Card('earth', '3'),
            new Card('water', 'Q'),
            new Card('wind', 'K'),
            new Card('water', 'A'),
            new Card('earth', '8'),
        ];
        
        updateTurnDisplay(); // Set initial '配置準備中' text
        render();
    }

    const placementOkButton = document.getElementById('placement-ok-button');
    const endTurnButton = document.getElementById('end-turn-button');

    placementOkButton.addEventListener('click', () => {
        if (state.gameStarted) return;

        placementOkButton.style.display = 'none';

        // Opponent places 3 monsters
        const opponentDeck = createDeck();
        for (let i = 0; i < 3; i++) {
            const randomCard = opponentDeck[Math.floor(Math.random() * opponentDeck.length)];
            let randomSlot;
            do {
                randomSlot = Math.floor(Math.random() * 6);
            } while (state.opponent.field[randomSlot] !== null);
            state.opponent.field[randomSlot] = randomCard;
            opponentDeck.splice(opponentDeck.indexOf(randomCard), 1);
        }
        addLog("相手が3体のモンスターを配置");
        addLog("プレイヤーの配置完了");
        
        addLog("先行決定ルーレット...");
        setTimeout(() => {
            const startingPlayer = Math.random() < 0.5 ? 'player' : 'opponent';
            state.gameStarted = true;
            addLog(`${startingPlayer === 'player' ? 'あなたが先行' : '相手が先行'}です！`);
            startTurn(startingPlayer); // Start the first turn
        }, 2000); // 2 second delay for roulette anticipation
    });
    
    endTurnButton.addEventListener('click', () => {
        if (state.gameStarted && state.turn === 'player') {
            endTurnButton.style.display = 'none'; // Hide button immediately
            endTurn();
        }
    });

    // Attack Action Panel Event Listeners
    const attackButton = document.getElementById('attack-button');
    const specialAttackButton = document.getElementById('special-attack-button');
    const cancelAttackButton = document.getElementById('cancel-attack-button');
    const actionPanel = document.getElementById('action-panel');

    attackButton.addEventListener('click', () => {
        // Attack logic will be triggered by clicking opponent's card after selecting attacker
        addLog('攻撃対象の相手カードを選択してください。');
    });

    specialAttackButton.addEventListener('click', () => {
        addLog('このカードは特別技が選択できません。');
    });

    cancelAttackButton.addEventListener('click', () => {
        // Deselect attacking card
        const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
        if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
        state.attackingCardId = null;
        actionPanel.style.display = 'none';
        addLog('攻撃をキャンセルしました。');
    });

    setupInitialState();
});
</script>

</body>
</html>
