<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mark-Inscribed Monster</title>
    <style>
        :root {
            --fire-color: #FF7B7B; --water-color: #7B8CFF;
            --wind-color: #7BFFB8; --earth-color: #C19A6B;
            --card-width: 63px; --card-height: 91px;
            --accent: #FFCC00;
        }
        body { background-color: #3D3D3D; color: #F0F0F0; font-family: sans-serif; margin: 0; overflow: hidden; }
        
        .screen { display: none; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .menu-btn { width: 260px; padding: 15px; margin: 10px; background: #444; border: 2px solid #666; color: white; cursor: pointer; border-radius: 10px; font-weight: bold; text-align: center; font-size: 1.1em; }
        .menu-btn:hover { border-color: var(--accent); background: #555; transform: scale(1.02); }
        .game-button { padding: 8px 16px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; }
        .game-button:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }

        .game-container { width: 100%; max-width: 1000px; display: flex; flex-direction: column; height: 100vh; position: relative; }
        
        .field { 
            display: grid; 
            grid-template-areas: "slot0 slot1 slot2" "slot5 slot4 slot3"; 
            gap: 10px; padding: 15px; justify-content: center; background: rgba(0,0,0,0.2);
        }
        .field.opponent-field-layout {
            grid-template-areas: "slot3 slot4 slot5" "slot2 slot1 slot0";
        }

        .card-slot { width: var(--card-width); height: var(--card-height); background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; position: relative; border: 1px dashed rgba(255,255,255,0.2); }
        .card { width: var(--card-width); height: var(--card-height); border-radius: 8px; color: #333; cursor: pointer; position: relative; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; padding: 5px; font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 0.7em; }
        .card.fire { background-color: var(--fire-color); }
        .card.water { background-color: var(--water-color); }
        .card.wind { background-color: var(--wind-color); }
        .card.earth { background-color: var(--earth-color); }
        .card.back { background-color: #666; border: 2px solid #444; }
        .card.selected { outline: 3px solid yellow; z-index: 10; }
        .card.attacked { filter: grayscale(0.9) brightness(0.7); cursor: default; }
        .hp-badge { position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.6); color: white; padding: 1px 3px; border-radius: 3px; font-size: 0.7em; }
        .player-hand, .opponent-hand-area { height: 110px; display: flex; justify-content: center; align-items: center; gap: 5px; background: rgba(0,0,0,0.4); }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 15px; background: #222; font-size: 0.85em; border-top: 1px solid #444; border-bottom: 1px solid #444; }
        .card-pile-slot { width: 50px; height: 70px; background: #666; border: 2px solid #444; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: white; }
        .control-lane { display: flex; justify-content: space-around; align-items: center; background: #222; padding: 10px; }
        .center-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .score-display { font-size: 4em; font-weight: bold; min-width: 120px; text-align: center; }
        .score-display.opponent-score { color: #FF7B7B; }
        .score-display.player-score { color: #7B8CFF; }
        .log-area { position: absolute; left: 10px; top: 10px; width: 220px; height: 150px; background: rgba(0,0,0,0.85); font-size: 11px; overflow-y: auto; padding: 10px; z-index: 100; border: 1px solid #555; line-height: 1.4; color: #EEE; }
        
        #roulette-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 2000; font-size: 3em; color: #FFF; font-weight: bold; }

        .grid-container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; max-height: 70vh; overflow-y: auto; padding: 20px; background: rgba(0,0,0,0.5); border-radius: 15px; width: 80%; }
        
        /* エディタ用の追加スタイル */
        .slot { background: #444; border: 2px solid #666; padding: 10px; border-radius: 8px; cursor: pointer; text-align: center; }
        .slot:hover { border-color: var(--accent); }
        .editor-layout { display: flex; gap: 20px; width: 95%; height: 75vh; }
        .scroll-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 10px; overflow-y: auto; flex-grow: 1; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="roulette-overlay">先攻を決定します</div>

<div id="title-screen" class="screen active">
    <h1 style="font-size: 3em; color:var(--accent); text-shadow: 2px 2px 10px rgba(0,0,0,0.5);">Mark-Inscribed Monster</h1>
    <div class="menu-btn" data-lang-key="adventure_battle" onclick="showScreen('mode-screen')">ADVENTURE / BATTLE</div>
    <div class="menu-btn" data-lang-key="deck_editor" onclick="openDeckList('edit')">DECK EDITOR (100 Slots)</div>
    <div class="menu-btn" data-lang-key="card_collection" onclick="showScreen('collection-screen')">CARD COLLECTION</div>
    <div class="menu-btn" data-lang-key="game_settings" onclick="showScreen('settings-screen')">GAME SETTINGS</div>
</div>

<div id="editor-screen" class="screen">
    <h2 id="editor-title" data-lang-key="deck_editor_title">DECK EDITOR</h2>
    <div class="editor-layout">
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3 data-lang-key="card_pool">CARD POOL</h3>
            <div id="pool-grid" class="scroll-grid"></div>
        </div>
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3><span data-lang-key="deck_count_label">DECK</span> (<span id="deck-count">0</span>/30)</h3>
            <div id="current-deck-grid" class="scroll-grid"></div>
        </div>
    </div>
    <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="game-button" data-lang-key="save_exit" onclick="saveDeck()">SAVE & EXIT</button>
        <button class="game-button" data-lang-key="cancel" style="background:#666" onclick="openDeckList('edit')">CANCEL</button>
    </div>
</div>

<div id="mode-screen" class="screen">
    <h2 data-lang-key="select_challenge">SELECT YOUR CHALLENGE</h2>
    <div class="menu-btn" data-lang-key="vs_random_ai" style="background:#4CAF50" onclick="initBattle()">VS RANDOM AI</div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK TO TITLE</div>
</div>

<div id="settings-screen" class="screen">
    <h2 data-lang-key="settings">SETTINGS</h2>
    <div class="menu-btn" data-lang-key="language_toggle" onclick="toggleLanguage()">LANGUAGE: 日本語</div>
    <div class="menu-btn" data-lang-key="sound_settings" onclick="alert('Sound Settings')">BGM / SE</div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="collection-screen" class="screen">
    <h2 data-lang-key="collection">COLLECTION</h2>
    <div id="coll-grid" class="grid-container" style="grid-template-columns: repeat(7, 1fr);"></div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="deck-list-screen" class="screen">
    <h2 data-lang-key="choose_deck_slot">CHOOSE DECK SLOT</h2>
    <div id="deck-grid" class="grid-container"></div>
    <div class="menu-btn" data-lang-key="back_to_title" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="game-screen" class="screen">
    <div class="game-container">
        <div id="log-area" class="log-area"><strong>【ゲームログ】</strong></div>
        <div id="opponent-hand" class="opponent-hand-area"></div>
        <div class="opponent-area"><div id="opponent-field" class="field opponent-field-layout"></div></div>
        <div class="info-row">
            <div class="info-item">手札: <span id="opp-hand-count">0</span></div>
            <div class="info-item">墓地: <div id="opp-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">山札: <div id="opp-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item" style="color:gold">パワー: <span id="opp-power-display">5</span></div>
        </div>
        <div class="control-lane">
            <div class="score-display opponent-score" id="opp-hp">20</div>
            <div class="center-controls">
                <div id="status-text" style="color:yellow; font-weight:bold; font-size:0.9em;">...</div>
                <button id="ok-btn" class="game-button" style="display:none;" onclick="confirmPlacement()">配置を完了する</button>
                <div id="battle-controls" style="display:none; flex-direction: column; gap: 10px; align-items: center;">
                    <button id="power-btn" class="game-button" style="background:#ccac00" onclick="handlePowerInject()">パワーを注入</button>
                    <button id="end-turn-btn" class="game-button" onclick="handleEndTurn()">ターン終了</button>
                </div>
            </div>
            <div class="score-display player-score" id="ply-hp">20</div>
        </div>
        <div class="info-row">
            <div class="info-item" style="color:gold">パワー: <span id="ply-power-display">5</span></div>
            <div class="info-item">山札: <div id="ply-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item">墓地: <div id="ply-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">手札: <span id="ply-hand-count">0</span></div>
        </div>
        <div class="player-area"><div id="player-field" class="field"></div></div>
        <div id="player-hand" class="player-hand"></div>
    </div>

    <!-- Attack Menu Overlay -->
    <div id="attack-menu" style="display:none; position:absolute; background:rgba(0,0,0,0.8); border:1px solid yellow; padding:10px; border-radius:5px; flex-direction:column; gap:5px; z-index:1000;">
        <button class="game-button" id="menu-attack-btn" style="background:#ccac00;">攻撃</button>
        <button class="game-button" id="menu-special-btn" style="background:#4CAF50;">特別技</button>
        <button class="game-button" id="menu-cancel-btn" style="background:#888;">キャンセル</button>
    </div>
</div>


<div id="game-over-screen" class="screen">
    <h1 id="game-result-text" style="font-size: 4em; color:var(--accent);"></h1>
    <div id="game-over-log" style="width: 80%; max-width: 600px; height: 300px; background: rgba(0,0,0,0.7); border: 1px solid #555; overflow-y: auto; padding: 10px; margin-bottom: 20px; font-size: 12px; line-height: 1.5;"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">タイトルへ戻る</div>
</div>

<script>
const languageData = {
    en: {
        'adventure_battle': 'ADVENTURE / BATTLE',
        'deck_editor': 'DECK EDITOR (100 Slots)',
        'card_collection': 'CARD COLLECTION',
        'game_settings': 'GAME SETTINGS',
        'select_challenge': 'SELECT YOUR CHALLENGE',
        'vs_random_ai': 'VS RANDOM AI',
        'back_to_title': 'BACK TO TITLE',
        'settings': 'SETTINGS',
        'language_toggle': 'LANGUAGE: English',
        'sound_settings': 'BGM / SE',
        'collection': 'COLLECTION',
        'choose_deck_slot': 'CHOOSE DECK SLOT',
        'deck_editor_title': 'DECK EDITOR',
        'card_pool': 'CARD POOL',
        'deck_count_label': 'DECK',
        'save_exit': 'SAVE & EXIT',
        'cancel': 'CANCEL',
        // Alerts & Prompts
        'deck_30_cards_max': 'Deck cannot exceed 30 cards.',
        'same_card_2_max': 'Cannot have more than 2 of the same card.',
        'deck_must_be_30': 'Deck must have exactly 30 cards. Current count: ',
        'deck_not_saved': 'No deck saved in this slot.',
        'deck_not_30': 'This deck does not have 30 cards. (Current: ',
        'prompt_deck_name': 'Name:',
        // Game Over
        'win_message': 'YOU WIN!',
        'lose_message': 'YOU LOSE...',
        'draw_message': 'DRAW',
        // Game Logs
        'log_support_card_not_in_battle': 'Cannot use support cards now.',
        'log_use_2draw': 'Used [2DRAW]! Drew 2 cards!',
        'log_deck_empty': 'Deck is empty!',
        'log_use_heal': 'Used [HEAL]! Choose a card to heal!',
        'log_use_skip': 'Used [SKIP]! Skipping opponent\'s turn!',
        'log_support_card_not_on_place': 'Cannot place support cards during placement phase.',
        'log_must_press_attack_button': 'To attack, press the "Attack" button and select a target!',
        'log_select_unit_from_hand': 'Select a unit card from your hand to place.',
        'log_support_card_no_place': 'Support cards cannot be placed on the field.',
        'log_card_placed': 'Placed ${rank}.',
        'log_only_unit_can_be_healed': 'Only unit cards can be healed.',
        'log_heal_success': 'Healed ${rank} for 3 HP! (Current HP: ${hp})',
        'log_card_returned_to_hand': 'Returned ${rank} to hand.',
        'log_power_injected': 'Injected power into ${rank}.',
        'log_select_card_then_attack': 'To start an attack, first select your card and press the "Attack" button!',
        'log_cannot_attack_from_back_row': 'Cannot attack with a card from the back row!',
        'log_invalid_attack_target_position': '[${rank}] is in a position that cannot be attacked!',
        'log_attack_start': 'Attack by [${rank}] begins!',
        'log_attack_fail_no_power': '...Attack failed due to insufficient power.',
        'log_card_already_attacked': '[${rank}] is already tired (has attacked).',
        'log_attack_damage': 'Dealt ${totalAtk} damage to opponent\'s [${targetRank}]!',
        'log_target_destroyed': 'Shattered [${rank}] with tremendous sound magic!',
        'log_opponent_cards_flipped': 'Opponent\'s cards are revealed!',
        'log_placement_complete_player_turn': 'Placement complete. Your turn begins.',
        'log_placement_complete_opponent_turn': 'Placement complete. Opponent\'s battle turn begins.',
        'log_turn_end': 'Turn ended.',
        'log_score_summary': '--- (You: ${playerScore}/5 | Opp: ${opponentScore}/5) ---',
        'log_opponent_placing_facedown': 'Opponent is placing cards face down.',
        'log_opponent_placement_done': 'Opponent\'s placement is complete. Moving to your placement.',
        'log_skip_effect': 'Opponent\'s turn was skipped due to [SKIP] effect!',
        'log_player_drew_card': 'You drew a card.',
        'log_player_deck_empty': 'Your deck is empty!',
        'log_opponent_turn_end': 'Opponent\'s turn ended. Your turn begins.',
        'log_opponent_turn_start': 'Opponent\'s turn started!',
        'log_opponent_drew_card': 'Opponent drew a card.',
        'log_opponent_deck_empty': 'Opponent\'s deck is empty!',
        'log_opponent_placed_card': 'Opponent placed [${rank}].',
        'log_opponent_did_not_place': 'Opponent did not place a card..',
        'log_opponent_injected_power': 'Opponent injected power into [${rank}]! (Current: ${p_atk}/${p_req})',
        'log_opponent_did_not_inject': 'Opponent did not inject power into a card..',
        'log_opponent_attack': 'Opponent\'s [${oppCardRank}] attacks your [${targetCardRank}] for ${totalOppAtk} damage!',
        'log_player_card_destroyed': 'Your [${rank}] has been defeated!',
        'log_opponent_no_target': 'Opponent\'s [${rank}] had no target to attack!',
        'log_opponent_attack_fail_no_power': 'Opponent\'s [${rank}] could not attack due to insufficient power..',
        'log_field_rotating': 'The field is rotating clockwise.',
        'log_win': '★★★★★ YOU WIN! ★★★★★',
        'log_lose': '------- YOU LOSE... -------',
        'log_draw': '======= DRAW ========',
        'log_player_mulligan': 'Your initial hand had no unit cards, so you will redraw.',
        'log_player_mulligan_warning': 'Warning: Player has reached the mulligan limit. Your deck may have too few unit cards.',
        'log_opponent_mulligan': 'Opponent\'s initial hand had no unit cards, so they will redraw.',
        'log_opponent_mulligan_warning': 'Warning: Opponent has reached the mulligan limit. Their deck may have too few unit cards.',
        'log_select_attack_target': 'Select a target to attack with [${rank}]!',
        'log_special_not_implemented': 'Special move is not yet implemented!',
        'log_player_first': 'You are going first.',
        'log_opponent_first': 'The opponent is going first.',
    },
    ja: {
        'adventure_battle': 'ADVENTURE / BATTLE',
        'deck_editor': 'DECK EDITOR (100 Slots)',
        'card_collection': 'CARD COLLECTION',
        'game_settings': 'GAME SETTINGS',
        'select_challenge': 'SELECT YOUR CHALLENGE',
        'vs_random_ai': 'VS RANDOM AI',
        'back_to_title': 'タイトルへ戻る',
        'settings': 'SETTINGS',
        'language_toggle': 'LANGUAGE: 日本語',
        'sound_settings': 'BGM / SE',
        'collection': 'COLLECTION',
        'choose_deck_slot': 'CHOOSE DECK SLOT',
        'deck_editor_title': 'DECK EDITOR',
        'card_pool': 'CARD POOL',
        'deck_count_label': 'DECK',
        'save_exit': 'SAVE & EXIT',
        'cancel': 'CANCEL',
        // Alerts & Prompts
        'deck_30_cards_max': 'デッキは30枚までです。',
        'same_card_2_max': '同じカードは2枚までしか入れられません。',
        'deck_must_be_30': 'デッキはちょうど30枚にしてください。現在の枚数: ',
        'deck_not_saved': 'このスロットにはデッキが保存されていません。',
        'deck_not_30': 'このデッキは30枚ではありません。(現在: ',
        'prompt_deck_name': 'Name:',
        // Game Over
        'win_message': 'あなたの勝利！',
        'lose_message': 'あなたの敗北...',
        'draw_message': '引き分け',
        // Game Logs
        'log_support_card_not_in_battle': 'サポートカードを使用できません。',
        'log_use_2draw': '【2DRAW】を使用！カードを2枚引いた。！',
        'log_deck_empty': '山札が空だ。！',
        'log_use_heal': '【HEAL】を使用！回復させる自分のカードを選んでほしいぴょん！',
        'log_use_skip': '【SKIP】を使用！相手のターンをスキップする。！',
        'log_support_card_not_on_place': '配置中はサポートカードを使用できません。',
        'log_must_press_attack_button': '攻撃には「攻撃」ボタンを押して対象を選択する。！',
        'log_select_unit_from_hand': '手札から配置したいユニットカードを選択してください。',
        'log_support_card_no_place': 'サポートカードは場に出せません。',
        'log_card_placed': '${rank}を配置しました。',
        'log_only_unit_can_be_healed': 'ユニットカードのみ回復できます。',
        'log_heal_success': '【${rank}】のHPが3回復した！ (現在HP: ${hp})',
        'log_card_returned_to_hand': '${rank}を手札に戻しました。',
        'log_power_injected': '${rank}にパワーを注入。',
        'log_select_card_then_attack': '攻撃を開始するには、まず自分のカードを選択して「攻撃」ボタンを押してください。！',
        'log_cannot_attack_from_back_row': '後列のカードでは攻撃できません！',
        'log_invalid_attack_target_position': '【${rank}】は攻撃できない位置だ。！',
        'log_attack_start': '【${rank}】の攻撃を開始！',
        'log_attack_fail_no_power': '……パワー不足で攻撃が不発に終わった。。',
        'log_card_already_attacked': '【${rank}】はもうお疲れだ。（攻撃済み）。',
        'log_attack_damage': '相手の【${targetRank}】に ${totalAtk} ダメージ与えた。！',
        'log_target_destroyed': '★凄まじい音魔法で【${rank}】を粉砕した。！',
        'log_opponent_cards_flipped': '相手のカードがオープンされる！',
        'log_placement_complete_player_turn': '配置完了。あなたのターンを開始します。',
        'log_placement_complete_opponent_turn': '配置完了。相手のバトルターンを開始します。',
        'log_turn_end': 'ターン終了。',
        'log_score_summary': '--- (自分: ${playerScore}/5 | 相手: ${opponentScore}/5) ---',
        'log_opponent_placing_facedown': '相手がカードを裏向きで配置します。',
        'log_opponent_placement_done': '相手の配置完了。あなたの配置に移ります。',
        'log_skip_effect': '【SKIP】の効果で相手のターンはスキップされた。！',
        'log_player_drew_card': 'あなたはカードを1枚引いた。',
        'log_player_deck_empty': 'あなたの山札はもうない！',
        'log_opponent_turn_end': '相手のターン終了。あなたのターン開始。',
        'log_opponent_turn_start': '相手の行動を開始した。！',
        'log_opponent_drew_card': '相手はカードを1枚引いた。',
        'log_opponent_deck_empty': '相手の山札はもうない！',
        'log_opponent_placed_card': '相手は【${rank}】を配置した。！',
        'log_opponent_did_not_place': '相手はカードを配置しなかった。。',
        'log_opponent_injected_power': '相手は【${rank}】にパワーを注入した。！ (現在: ${p_atk}/${p_req})',
        'log_opponent_did_not_inject': '相手はカードにパワーを注入しなかった。。',
        'log_opponent_attack': '相手の【${oppCardRank}】があなたの【${targetCardRank}】に ${totalOppAtk} ダメージ与えた。！',
        'log_player_card_destroyed': 'あなたの【${rank}】は撃破された。！',
        'log_opponent_no_target': '相手の【${rank}】は攻撃対象がいなかった。！',
        'log_opponent_attack_fail_no_power': '相手の【${rank}】はパワーが足りないので攻撃できなかった。。',
        'log_field_rotating': 'フィールドが時計回りに回転します。',
        'log_win': '★★★★★ あなたの勝利です！ ★★★★★',
        'log_lose': '------- あなたの敗北です... -------',
        'log_draw': '======= 引き分けです ========',
        'log_player_mulligan': 'あなたの初期手札にユニットカードがなかったので、引き直します。',
        'log_player_mulligan_warning': '警告: プレイヤーのマリガン上限に達しました。デッキにユニットカードが少ない可能性があります。',
        'log_opponent_mulligan': '相手の初期手札にユニットカードがなかったので、引き直します。',
        'log_opponent_mulligan_warning': '警告: 相手のマリガン上限に達しました。デッキにユニットカードが少ない可能性があります。',
        'log_select_attack_target': '【${rank}】で攻撃対象を選択してください。！',
        'log_special_not_implemented': '特別技はまだ実装されていない。！',
        'log_player_first': 'あなたが先行です。',
        'log_opponent_first': '相手が先行です。',
    }
};

function getText(key) {
    // Default to Japanese if state or language isn't set yet
    const lang = state ? state.language : 'ja';
    return languageData[lang][key] || `(no text for ${key})`;
}

function getFormattedText(key, params = {}) {
    let text = getText(key);
    for (const p_key in params) {
        // Use a regular expression to replace all occurrences of the placeholder
        const regex = new RegExp(`\\$\\{${p_key}\\}`, 'g');
        text = text.replace(regex, params[p_key]);
    }
    return text;
}

function updateUIText() {
    document.querySelectorAll('[data-lang-key]').forEach(el => {
        const key = el.dataset.langKey;
        el.innerHTML = getText(key);
    });
     // Also update dynamic parts if needed, e.g., titles of screens
    document.getElementById('editor-title').textContent = getText('deck_editor_title');
}

function toggleLanguage() {
    state.language = (state.language === 'ja') ? 'en' : 'ja';
    updateUIText();
}

const SUITS = ['fire', 'water', 'wind', 'earth'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const SUPPORTS = ['2DRAW','HEAL','SKIP'];

const RANK_VALUES = { 
    'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,
    '2DRAW': 0, 'HEAL': 0, 'SKIP': 0 
};

class Card {
    constructor(suit, rank, type = 'unit') {
        this.id = Math.random().toString(36).substr(2, 9);
        this.suit = suit; this.rank = rank; this.type = type;
        this.value = RANK_VALUES[rank] || 0;
        this.hp = this.value; this.maxHp = this.value;
        this.attachedPower = 0;
        this.isSupport = (type === 'support' || SUPPORTS.includes(rank));
        this.requiredPower = this.isSupport ? 0 : (this.value <= 3) ? 1 : (this.value <= 6) ? 2 : (this.value <= 10) ? 3 : 4;
    }
}

let state = getInitialState(); // Initialize state when script loads

// Function to get the initial game state
function getInitialState() {
    return {
        language: 'ja',
        editIdx: 1, 
        editCards: [], 
        player: { hand: [], field: Array(6).fill(null), deck: [], grave: 0, power: 5, points: 0, attackedIds: [], powerInjected: false },
        opponent: { handCount: 5, field: Array(6).fill(null), deck: [], grave: 0, power: 5, points: 0 },
        selectedCard: null, 
        turn: 'player', 
        statusText: '準備OK',
        canPlaceCard: false, 
        gameOver: false,
        isAttacking: false, // New state to indicate if player is in attack mode
        isOpponentInitialPlacement: false,
        isHealing: false // New state to indicate if player is choosing a card to heal
    };
}


// --- 指示されたデッキエディタの魔法 ---

function openDeckList(purpose = 'edit') {
    const grid = document.getElementById('deck-grid'); grid.innerHTML = '';
    for(let i=1; i<=100; i++) {
        const name = localStorage.getItem(`deck_name_${i}`) || `DECK ${i}`;
        const slot = document.createElement('div'); slot.className = 'slot'; slot.style.width="150px";
        slot.innerHTML = `<div>${name}</div><small>Slot ${i}</small>`;
        slot.onclick = () => {
            if (purpose === 'edit') {
                state.editIdx = i;
                enterEditor();
            } else { // purpose === 'battle'
                startGameWithDeck(i);
            }
        };
        grid.appendChild(slot);
    }
    showScreen('deck-list-screen');
}

function enterEditor() {
    const saved = localStorage.getItem(`deck_cards_${state.editIdx}`);
    state.editCards = saved ? JSON.parse(saved).map(d => Object.assign(new Card(), d)) : [];
    const pool = document.getElementById('pool-grid'); pool.innerHTML = '';
    SUITS.forEach(s => {
        RANKS.forEach(r => pool.appendChild(createCardUI(new Card(s, r), true)));
        SUPPORTS.forEach(a => pool.appendChild(createCardUI(new Card(s, a, 'support'), true)));
    });
    renderEditor(); showScreen('editor-screen');
}

function createCardUI(c, isPool) {
    const div = createCardEl(c); // ベースのカード表示を利用
    div.onclick = () => {
        if(isPool) {
            if (state.editCards.length >= 30) {
                alert(getText('deck_30_cards_max'));
                return;
            }
            const count = state.editCards.filter(deckCard => deckCard.suit === c.suit && deckCard.rank === c.rank).length;
            if (count >= 2) {
                alert(getText('same_card_2_max'));
                return;
            }
            state.editCards.push(new Card(c.suit, c.rank, c.type)); 
        } else { 
            // This part is for removing cards from the deck, which is correct.
            // Find the specific card instance to remove.
            const cardIndex = state.editCards.findIndex(deckCard => deckCard.id === c.id);
            if (cardIndex > -1) {
                state.editCards.splice(cardIndex, 1);
            }
        }
        renderEditor();
    };
    return div;
}

function renderEditor() {
    const grid = document.getElementById('current-deck-grid'); grid.innerHTML = '';
    state.editCards.forEach(c => grid.appendChild(createCardUI(c, false)));
    document.getElementById('deck-count').textContent = state.editCards.length;
}

function saveDeck() {
    if (state.editCards.length !== 30) {
        alert(getText('deck_must_be_30') + state.editCards.length);
        return;
    }
    localStorage.setItem(`deck_cards_${state.editIdx}`, JSON.stringify(state.editCards));
    const name = prompt(getText('prompt_deck_name'), localStorage.getItem(`deck_name_${state.editIdx}`) || `DECK ${state.editIdx}`);
    if(name) localStorage.setItem(`deck_name_${state.editIdx}`, name);
    openDeckList('edit');
}

// --- 聖域：元のロジックをすべて保持 ---

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    updateUIText(); // Update text every time a screen is shown
    if (id === 'collection-screen') renderCollection();
}

function renderCollection() {
    const grid = document.getElementById('coll-grid'); grid.innerHTML = ''; 
    SUITS.forEach(s => {
        RANKS.forEach(r => grid.appendChild(createCardEl(new Card(s, r))));
        SUPPORTS.forEach(a => grid.appendChild(createCardEl(new Card(s, a, 'support'))));
    });
}

function addLog(msg) {
    const log = document.getElementById('log-area');
    const div = document.createElement('div'); div.textContent = `> ${msg}`;
    log.appendChild(div); log.scrollTop = log.scrollHeight;
}

function createCardEl(card) {
    const div = document.createElement('div'); div.className = `card ${card.suit}`;
    div.dataset.cardId = card.id; // Add data-card-id for easier lookup

    if (card.isFaceDown) {
        div.className = 'card back';
        div.innerHTML = `<div style="display:flex; justify-content:center; align-items:center; height:100%; font-size: 2em; color: white;">?</div>`;
    } else if(card.isSupport) {
        div.innerHTML = `<div class="hp-badge">SP</div><div style="font-size:0.9em">${card.rank}</div><div style="font-size:0.8em">${card.suit}</div>`;
    } else {
        div.innerHTML = `<div class="hp-badge">${card.hp}/${card.maxHp}</div><div style="font-size:1.2em">${card.rank}</div><div style="font-size:0.8em">${card.suit}</div><div style="font-size:0.9em">P:${card.attachedPower}/${card.requiredPower}<br>A:${card.value}</div>`;
    }
    return div;
}

    // Helper to find the DOM element of a card
    function getCardElement(card) {
        if (!card) return null;
        const els = document.querySelectorAll(`[data-card-id="${card.id}"]`); // Use attribute selector for efficiency
        for (const el of els) {
            // Check if this is a player's field card (or hand card, if needed)
            // For menu positioning, we assume it's a field card
            if (el.closest('#player-field') || el.closest('#player-hand')) { // Check if it's in player area
                return el;
            }
        }
        return null;
    }

    // Helper to find the DOM element of a card
    function getCardElement(card) {
        if (!card) return null;
        const els = document.querySelectorAll(`[data-card-id="${card.id}"]`); // Use attribute selector for efficiency
        for (const el of els) {
            // Check if this is a player's field card (or hand card, if needed)
            // For menu positioning, we assume it's a field card
            if (el.closest('#player-field') || el.closest('#player-hand')) { // Check if it's in player area
                return el;
            }
        }
        return null;
    }

    function showAttackMenu(card) {
        const attackMenu = document.getElementById('attack-menu');
        const cardEl = getCardElement(card); // Get the actual DOM element for the selected card

        if (cardEl) {
            const rect = cardEl.getBoundingClientRect();
            // Position to the right of the card, relative to the game-container
            const gameContainerRect = document.querySelector('.game-container').getBoundingClientRect();
            attackMenu.style.left = `${rect.right + 10 - gameContainerRect.left}px`;
            attackMenu.style.top = `${rect.top - gameContainerRect.top}px`;
            attackMenu.style.display = 'flex';
        } else {
            console.error("Could not find DOM element for selected card:", card);
        }
    }

    function hideAttackMenu() {
        document.getElementById('attack-menu').style.display = 'none';
        state.isAttacking = false; // Reset attacking state
    }
    
function useSupportCard(card) {
    if (state.gameOver || state.turn !== 'player') {
        addLog(getText('log_support_card_not_in_battle'));
        return;
    }

    let cardUsed = false;
    switch (card.rank) {
        case '2DRAW':
            addLog(getText('log_use_2draw'));
            for (let i = 0; i < 2; i++) {
                if (state.player.deck.length > 0) {
                    state.player.hand.push(state.player.deck.shift());
                } else {
                    addLog(getText('log_deck_empty'));
                    break;
                }
            }
            cardUsed = true;
            break;
        case 'HEAL':
            addLog(getText('log_use_heal'));
            state.isHealing = true; // 「今から回復するよ」というモードにする
            cardUsed = true;
            break;
        case 'SKIP':
            addLog(getText('log_use_skip'));
            state.skipOpponentTurn = true; // Set a flag to skip opponent's turn
            cardUsed = true;
            break;
    }

    if (cardUsed) {
        // Remove card from hand and move to graveyard
        state.player.hand = state.player.hand.filter(c => c !== card);
        state.player.grave++;
        state.selectedCard = null; // Deselect
        render();
    }
}

function render() {
    renderField('player-field', state.player.field, false);
    renderField('opponent-field', state.opponent.field, true);
    const handEl = document.getElementById('player-hand'); handEl.innerHTML = '';
    state.player.hand.forEach(card => {
        const el = createCardEl(card);
        el.onclick = () => { 
            if(state.gameOver) return;

            if (state.canPlaceCard) { // --- 配置フェーズ中の処理 ---
                if (card.isSupport) {
                    addLog(getText('log_support_card_not_on_place'));
                } else {
                    state.selectedCard = card; // ユニットカードは選択
                    render();
                }
            } else { // --- バトルフェーズ中の処理 ---
                if (card.isSupport) {
                    useSupportCard(card); // サポートカードは直接使用
                } else {
                    state.selectedCard = card; // ユニットカードは選択
                    render(); 
                }
            }
        };
        if (state.selectedCard === card) el.classList.add('selected');
        handEl.appendChild(el);
    });

    // Hide attack menu when rendering if no card is selected
    if (!state.selectedCard) {
        hideAttackMenu(); // Ensure menu is hidden if no card is selected
    }
    
    const oppHandEl = document.getElementById('opponent-hand'); oppHandEl.innerHTML = '';
    for(let i=0; i<state.opponent.handCount; i++) {
        const back = document.createElement('div'); back.className = 'card back';
        oppHandEl.appendChild(back);
    }
    document.getElementById('opp-hp').textContent = `${state.opponent.points}/5`;
    document.getElementById('ply-hp').textContent = `${state.player.points}/5`;
    document.getElementById('opp-power-display').textContent = state.opponent.power;
    document.getElementById('ply-power-display').textContent = state.player.power;
    document.getElementById('opp-hand-count').textContent = state.opponent.handCount;
    document.getElementById('ply-hand-count').textContent = state.player.hand.length;
    document.getElementById('opp-deck').textContent = `${state.opponent.deck.length}/30`;
    document.getElementById('ply-deck').textContent = `${state.player.deck.length}/30`;
    document.getElementById('opp-graveyard').textContent = state.opponent.grave;
    document.getElementById('ply-graveyard').textContent = state.player.grave;
    document.getElementById('ok-btn').style.display = state.canPlaceCard ? 'block' : 'none';
    document.getElementById('battle-controls').style.display = state.canPlaceCard ? 'none' : 'flex';
    document.getElementById('power-btn').disabled = state.player.powerInjected || state.turn !== 'player';
}

function renderField(id, field, isOpponent) {
    const el = document.getElementById(id); el.innerHTML = '';
    field.forEach((card, i) => {
        const slot = document.createElement('div'); slot.className = 'card-slot'; slot.style.gridArea = `slot${i}`;
        if (card) {
            const cardEl = createCardEl(card);
            // Highlight targetable opponent cards when isAttacking is true
            if (state.isAttacking && isOpponent) {
                const targetCardIndex = state.opponent.field.indexOf(card);
                // Opponent field layout is reversed, so "front" to player is opponent's slots 3,4,5
                // which correspond to visual positions 1,2,3 for the opponent.
                if (targetCardIndex !== -1 && targetCardIndex < 3) { // Only highlight back row
                    cardEl.style.outline = '4px solid red'; // Visual cue for targetable
                }
            }
            if (!isOpponent && state.player.attackedIds.includes(card.id)) cardEl.classList.add('attacked');
            if (state.selectedCard === card) cardEl.classList.add('selected');

            cardEl.onclick = (e) => {
                e.stopPropagation();
                if (state.gameOver) return;
                if (isOpponent) {
                    if (state.isAttacking) { // Only attack if in attacking state
                        handleAttack(card);
                        hideAttackMenu(); // Hide menu after attack attempt
                    } else {
                        addLog(getText('log_must_press_attack_button'));
                    }
                } else { // Player's own card clicked
                    if (state.isHealing) {
                        healCard(card); // HEALモードなら回復
                    } else {
                        handleFieldClick(card, i); // 通常はフィールドクリック処理
                    }
                }
            };
            slot.appendChild(cardEl);
        } else if ((state.canPlaceCard || state.turn === 'player') && !isOpponent) {
            slot.onclick = () => placeCard(i);
        }
        el.appendChild(slot);
    });
}

function placeCard(i) {
    if (!state.selectedCard) {
        addLog(getText('log_select_unit_from_hand'));
        return;
    }
    if (state.selectedCard.isSupport) {
        addLog(getText('log_support_card_no_place'));
        return;
    }
    
    const cardToPlace = state.selectedCard;

    state.player.field[i] = cardToPlace;
    state.player.hand = state.player.hand.filter(c => c !== cardToPlace);
    addLog(getFormattedText('log_card_placed', { rank: cardToPlace.rank }));
    state.selectedCard = null;
    hideAttackMenu();
    render();
}

function healCard(targetCard) {
    if (!targetCard || targetCard.isSupport) {
        addLog(getText('log_only_unit_can_be_healed'));
        return;
    }
    targetCard.hp = Math.min(targetCard.maxHp, targetCard.hp + 3);
    addLog(getFormattedText('log_heal_success', { rank: targetCard.rank, hp: targetCard.hp }));
    
    state.isHealing = false; // 回復モードを終了
    render();
}

function handleFieldClick(card, i) {
    if (state.canPlaceCard) {
        state.player.hand.push(card); state.player.field[i] = null;
        addLog(getFormattedText('log_card_returned_to_hand', { rank: card.rank }));
        hideAttackMenu(); // Hide menu if card is moved
    } else { // Battle phase
        if (state.isHealing) { // If in healing mode, heal the card.
            healCard(card);
            return;
        }
        if (state.selectedCard === card) { // Deselect if already selected
            state.selectedCard = null;
            hideAttackMenu(); // Hide menu if deselected
        } else {
            state.selectedCard = card;
            if (!state.gameOver && state.turn === 'player') { // Only show menu if player's turn and not game over
                showAttackMenu(card); // Show attack menu near the card
            }
        }
    }
    render();
}

function handlePowerInject() {
    const c = state.selectedCard;
    if (c && state.player.field.includes(c) && c.attachedPower < c.requiredPower) {
        c.attachedPower++; state.player.powerInjected = true;
        addLog(getFormattedText('log_power_injected', { rank: c.rank }));
        hideAttackMenu(); // Hide menu after power injection
        render();
    }
}

function handleAttack(targetCard) {
    if (state.canPlaceCard || !state.selectedCard || !state.isAttacking) { // Must be in attacking state
        addLog(getText('log_select_card_then_attack'));
        return;
    }
    
    const attacker = state.selectedCard;
    const attackerIndex = state.player.field.indexOf(attacker);

    // 攻撃者が前衛にいるかチェック
    if (attackerIndex === -1 || attackerIndex > 2) {
        addLog(getText('log_cannot_attack_from_back_row'));
        return;
    }

    // Check if the targetCard is in the opponent's back row (slots 0, 1, 2)
    const targetCardIndex = state.opponent.field.indexOf(targetCard);
    if (targetCardIndex === -1 || targetCardIndex >= 3) { // If not found or in opponent's visual front row (slots 3,4,5)
        addLog(getFormattedText('log_invalid_attack_target_position', { rank: targetCard.rank }));
        return;
    }
    
    // 攻撃前のログ
    addLog(getFormattedText('log_attack_start', { rank: attacker.rank }));

    if (attacker.attachedPower < attacker.requiredPower) {
        addLog(getText('log_attack_fail_no_power'));
        return;
    }

    if (state.player.attackedIds.includes(attacker.id)) {
        addLog(getFormattedText('log_card_already_attacked', { rank: attacker.rank }));
        return;
    }
    
    const totalAtk = attacker.value;
    targetCard.hp -= totalAtk;
    state.player.attackedIds.push(attacker.id);
    
    // ダメージのログ（ここが大事！）
    addLog(getFormattedText('log_attack_damage', { targetRank: targetCard.rank, totalAtk: totalAtk }));

    if (targetCard.hp <= 0) {
        const idx = state.opponent.field.indexOf(targetCard);
        if (idx !== -1) {
            state.opponent.field[idx] = null;
            state.opponent.grave++;
            state.player.points++; // プレイヤーのポイントを増やす
        }
        addLog(getFormattedText('log_target_destroyed', { rank: targetCard.rank }));
        if (checkWin()) return; // ★★★ Check for win immediately ★★★
    }
    
    state.selectedCard = null;
    render();
}

function confirmPlacement() { 
    state.canPlaceCard = false;

    // Flip opponent's face-down cards if any
    let flipped = false;
    state.opponent.field = state.opponent.field.map(card => {
        if (card && card.isFaceDown) {
            flipped = true;
            // Revert to the original card object by removing the face-down flag
            delete card.isFaceDown;
            return card;
        }
        return card;
    });

    if (flipped) {
        addLog(getText('log_opponent_cards_flipped'));
        render(); // Show the flipped cards
    }

    if (state.turn === 'player') {
        // Player's turn to start battle
        document.getElementById('status-text').textContent = "自ターン";
        addLog(getText('log_placement_complete_player_turn'));
        render();
    } else {
        // Opponent's turn to start battle
        document.getElementById('status-text').textContent = "相手ターン";
        addLog(getText('log_placement_complete_opponent_turn'));
        // Use setTimeout to give player a moment to see the flipped cards
        setTimeout(opponentAI, 1000);
    }
}

function handleEndTurn() {
    state.player.powerInjected = false; state.player.attackedIds = [];
    addLog(getText('log_turn_end')); 
    addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
    state.turn = 'opponent'; document.getElementById('status-text').textContent = "相手ターン";
    rotateFields();
    render(); 
    setTimeout(opponentAI, 1000);
}

function opponentAI() {
    // Initial placement logic for opponent going first
    if (state.isOpponentInitialPlacement) {
        addLog(getText('log_opponent_placing_facedown'));
        const placeableUnits = state.opponent.hand.filter(card => !card.isSupport);
        if (placeableUnits.length > 0 && state.opponent.field.includes(null)) {
            const cardToPlay = placeableUnits[0];
            const emptySlotIndex = state.opponent.field.indexOf(null);
            if (emptySlotIndex !== -1) {
                // Place face down
                state.opponent.field[emptySlotIndex] = { ...cardToPlay, isFaceDown: true, originalCard: cardToPlay };
                state.opponent.hand = state.opponent.hand.filter(c => c !== cardToPlay);
                state.opponent.handCount = state.opponent.hand.length;
            }
        }
        state.isOpponentInitialPlacement = false;
        // Transition to player's placement phase
        state.canPlaceCard = true;
        state.statusText = "カードを配置してください。";
        addLog(getText('log_opponent_placement_done'));
        render();
        return; // End AI turn here for initial placement
    }

    // --- Regular AI Turn ---
    if (state.skipOpponentTurn) {
        addLog(getText('log_skip_effect'));
        state.skipOpponentTurn = false;
        // ターンエンド処理を模倣 (ログ、回転、ドロー、ターン変更)
        addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
        rotateFields();
        if (state.player.deck.length > 0) {
            state.player.hand.push(state.player.deck.shift());
            addLog(getText('log_player_drew_card'));
        } else {
            addLog(getText('log_player_deck_empty'));
        }
        state.turn = 'player';
        document.getElementById('status-text').textContent = "自ターン";
        addLog(getText('log_opponent_turn_end'));
        render();
        checkWin();
        return; // スキップ終了
    }

    addLog(getText('log_opponent_turn_start'));

    // Opponent draws a card
    if (state.opponent.deck.length > 0) {
        const drawnCard = state.opponent.deck.shift();
        state.opponent.hand.push(drawnCard);
        state.opponent.handCount = state.opponent.hand.length;
        addLog(getText('log_opponent_drew_card'));
    } else {
        addLog(getText('log_opponent_deck_empty'));
    }

    const cardsOnOpponentField = state.opponent.field.filter(c => c !== null);
    let opponentAttackedIds = []; // 1ターンに1回攻撃のチェック用

    // Opponent tries to play a card from hand
    // ユニットカードのみ配置対象とする (サポートカードは配置しない)
    const placeableUnits = state.opponent.hand.filter(card => !card.isSupport);

    // 配置できるユニットカードがあり、かつ場に空きがある場合
    if (placeableUnits.length > 0 && state.opponent.field.includes(null)) {
        const cardToPlay = placeableUnits[0]; // 最も単純に、手札の最初のユニットカードをプレイする
        const emptySlotIndex = state.opponent.field.indexOf(null);

        if (emptySlotIndex !== -1) {
            state.opponent.field[emptySlotIndex] = cardToPlay;
            state.opponent.hand = state.opponent.hand.filter(c => c !== cardToPlay);
            state.opponent.handCount = state.opponent.hand.length;
            addLog(getFormattedText('log_opponent_placed_card', { rank: cardToPlay.rank }));
        }
    } else {
        addLog(getText('log_opponent_did_not_place'));
    }

    // Opponent tries to power up a card
    const cardToPowerUp = cardsOnOpponentField.find(c => c.attachedPower < c.requiredPower && state.opponent.power > 0);
    if (cardToPowerUp) {
        cardToPowerUp.attachedPower++;
        state.opponent.power--;
        addLog(getFormattedText('log_opponent_injected_power', { rank: cardToPowerUp.rank, p_atk: cardToPowerUp.attachedPower, p_req: cardToPowerUp.requiredPower }));
    } else if (cardsOnOpponentField.length > 0) {
        addLog(getText('log_opponent_did_not_inject'));
    }

    // Opponent attacks
    cardsOnOpponentField.forEach(oppCard => {
            if (!oppCard || opponentAttackedIds.includes(oppCard.id)) { // 攻撃済み、または無効なカード
                return;
            }

            if (oppCard.attachedPower >= oppCard.requiredPower) { // Check power requirement
                const totalOppAtk = oppCard.value; // Now only uses card's value for attack
                const playerFrontRowCards = [state.player.field[0], state.player.field[1], state.player.field[2]].filter(p => p !== null);

                if (playerFrontRowCards.length > 0) {
                    // Attack player's first available front row card
                    const targetCard = playerFrontRowCards[0];
                    targetCard.hp -= totalOppAtk;
                    addLog(getFormattedText('log_opponent_attack', { oppCardRank: oppCard.rank, targetCardRank: targetCard.rank, totalOppAtk: totalOppAtk }));
                    opponentAttackedIds.push(oppCard.id); // 攻撃済みとして登録
                    if (targetCard.hp <= 0) {
                        const idx = state.player.field.indexOf(targetCard);
                        if (idx !== -1) {
                            state.player.field[idx] = null;
                            state.player.grave++;
                            state.opponent.points++; // 相手のポイントを増やす
                            addLog(getFormattedText('log_player_card_destroyed', { rank: targetCard.rank }));
                            if (checkWin()) return; // ★★★ Check for win immediately ★★★
                        }
                    }
                } else {
                    addLog(getFormattedText('log_opponent_no_target', { rank: oppCard.rank }));
                }
            } else if (oppCard) { // 攻撃済みチェックの追加
                addLog(getFormattedText('log_opponent_attack_fail_no_power', { rank: oppCard.rank }));
            }
    });

    // End opponent's turn and pass back to player
    state.opponent.power = 5; // Restore opponent's power
    state.player.powerInjectedThisTurn = false; // Reset player's power injection flag
    
    addLog(getFormattedText('log_score_summary', { playerScore: state.player.points, opponentScore: state.opponent.points }));
    rotateFields();

    // Player draws a card
    if (state.player.deck.length > 0) {
        state.player.hand.push(state.player.deck.shift());
        addLog(getText('log_player_drew_card'));
    } else {
        addLog(getText('log_player_deck_empty'));
    }

    state.turn = 'player';
    document.getElementById('status-text').textContent = "自ターン";
    addLog(getText('log_opponent_turn_end'));
    render();
    checkWin(); // Check for game over after opponent's turn
}

function rotateFields() {
    addLog(getText('log_field_rotating'));
    // Player's field
    const pField = state.player.field;
    if (!pField.every(c => c === null)) {
        const pLast = pField.pop();
        pField.unshift(pLast);
    }
    // Opponent's field
    const oField = state.opponent.field;
    if (!oField.every(c => c === null)) {
        const oLast = oField.pop();
        oField.unshift(oLast);
    }
}

function showGameOverScreen(result) {
    if (state.gameOver) return;
    state.gameOver = true;

    const resultText = document.getElementById('game-result-text');
    let message = '';
    switch (result) {
        case 'win':
            message = getText('win_message');
            addLog(getText('log_win'));
            break;
        case 'lose':
            message = getText('lose_message');
            addLog(getText('log_lose'));
            break;
        case 'draw':
            message = getText('draw_message');
            addLog(getText('log_draw'));
            break;
    }
    resultText.textContent = message;

    // Display game log on the game over screen
    const gameLog = document.getElementById('log-area').innerHTML;
    document.getElementById('game-over-log').innerHTML = gameLog;

    showScreen('game-over-screen');
}

function checkWin() {
    if (state.gameOver || state.canPlaceCard) return false; // ゲーム中のみ判定

    const playerHasFieldCards = state.player.field.some(c => c !== null);
    const opponentHasFieldCards = state.opponent.field.some(c => c !== null);

    // 優先1: 場のカードでの決着
    if (!playerHasFieldCards && !opponentHasFieldCards) {
        showGameOverScreen('draw');
        return true;
    }
    if (!opponentHasFieldCards) {
        showGameOverScreen('win');
        return true;
    }
    if (!playerHasFieldCards) {
        showGameOverScreen('lose');
        return true;
    }

    // 優先2: ポイントでの決着
    const playerWinsByPoints = state.player.points >= 5;
    const opponentWinsByPoints = state.opponent.points >= 5;

    if (playerWinsByPoints && opponentWinsByPoints) {
        showGameOverScreen('draw');
        return true;
    }
    if (playerWinsByPoints) {
        showGameOverScreen('win');
        return true;
    }
    if (opponentWinsByPoints) {
        showGameOverScreen('lose');
        return true;
    }
    return false;
}

function startGameWithDeck(deckId) {
    const savedDeck = localStorage.getItem(`deck_cards_${deckId}`);
    if (!savedDeck) {
        alert(getText('deck_not_saved'));
        return;
    }
    const parsedDeck = JSON.parse(savedDeck);
    if (parsedDeck.length !== 30) {
        alert(getText('deck_not_30') + parsedDeck.length + ')');
        return;
    }

    state = getInitialState(); // Reset all state variables

    // 1. Player's deck setup
    let playerDeck = parsedDeck.map(d => Object.assign(new Card(), d));
    // Shuffle player's deck
    for (let i = playerDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [playerDeck[i], playerDeck[j]] = [playerDeck[j], playerDeck[i]];
    }
    state.player.deck = playerDeck;
    state.player.hand = state.player.deck.splice(0, 5); // 初期手札5枚

    // マリガン処理 (プレイヤー)
    let playerMulliganCount = 0;
    while (!state.player.hand.some(c => !c.isSupport) && playerMulliganCount < 5) { // 最大5回までマリガン
        addLog(getText('log_player_mulligan'));
        state.player.deck.push(...state.player.hand); // 手札をデッキに戻す
        for (let i = state.player.deck.length - 1; i > 0; i--) { // デッキを再シャッフル
            const j = Math.floor(Math.random() * (i + 1));
            [state.player.deck[i], state.player.deck[j]] = [state.player.deck[j], state.player.deck[i]];
        }
        state.player.hand = state.player.deck.splice(0, 5); // 再度5枚引く
        playerMulliganCount++;
    }
    if (playerMulliganCount >= 5) {
        addLog(getText('log_player_mulligan_warning'));
    }

    // 2. Opponent's deck setup (Random)
    let opponentFullDeck = [];
    SUITS.forEach(suit => {
        RANKS.forEach(rank => opponentFullDeck.push(new Card(suit, rank)));
        SUPPORTS.forEach(a => opponentFullDeck.push(new Card(suit, a, 'support')));
    });
     for (let i = opponentFullDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [opponentFullDeck[i], opponentFullDeck[j]] = [opponentFullDeck[j], opponentFullDeck[i]];
    }
    state.opponent.deck = opponentFullDeck.slice(0, 30); // Take 30 cards for the deck
    state.opponent.hand = state.opponent.deck.splice(0, 5); // 初期手札5枚

    // マリガン処理 (相手)
    let opponentMulliganCount = 0;
    while (!state.opponent.hand.some(c => !c.isSupport) && opponentMulliganCount < 5) { // 最大5回までマリガン
        addLog(getText('log_opponent_mulligan'));
        state.opponent.deck.push(...state.opponent.hand); // 手札をデッキに戻す
        for (let i = state.opponent.deck.length - 1; i > 0; i--) { // デッキを再シャッフル
            const j = Math.floor(Math.random() * (i + 1));
            [state.opponent.deck[i], state.opponent.deck[j]] = [state.opponent.deck[j], state.opponent.deck[i]];
        }
        state.opponent.hand = state.opponent.deck.splice(0, 5); // 再度5枚引く
        opponentMulliganCount++;
    }
    if (opponentMulliganCount >= 5) {
        addLog(getText('log_opponent_mulligan_warning'));
    }

    // 3. Start Game
    showScreen('game-screen');
    startRoulette();
}

function initBattle() {
    openDeckList('battle');
}

// Event listeners for attack menu buttons
document.getElementById('menu-attack-btn').onclick = () => {
    if (state.selectedCard) {
        state.isAttacking = true;
        addLog(getFormattedText('log_select_attack_target', { rank: state.selectedCard.rank }));
        render(); // Rerender to show potential target highlights
    }
};

document.getElementById('menu-special-btn').onclick = () => {
    addLog(getText('log_special_not_implemented'));
    hideAttackMenu();
    state.selectedCard = null;
    render();
};

document.getElementById('menu-cancel-btn').onclick = () => {
    hideAttackMenu();
    state.selectedCard = null;
    render();
};

function startRoulette() {
    const overlay = document.getElementById('roulette-overlay'); overlay.style.display = 'flex';
    let count = 0;
    const interval = setInterval(() => {
        overlay.textContent = count % 2 === 0 ? "プレイヤー先攻？" : "相手先攻？";
        if (++count > 10) {
            clearInterval(interval);
            const isPlayer = Math.random() > 0.5;
            state.turn = isPlayer ? 'player' : 'opponent';
            overlay.textContent = isPlayer ? "プレイヤー先攻" : "相手先攻";
            setTimeout(() => {
                overlay.style.display = 'none';
                // 先行・後攻に関わらず、まず相手の裏向き初期配置フェーズへ
                state.isOpponentInitialPlacement = true; // 相手の特殊初期配置モードをON
                state.canPlaceCard = false; // プレイヤーはまだ配置できない
                state.statusText = "相手が配置しています...";
                addLog(getText(state.turn === 'player' ? 'log_player_first' : 'log_opponent_first'));
                render();
                // 相手の特殊初期配置AIを呼ぶ (opponentAI関数内でプレイヤーの配置フェーズに遷移する)
                setTimeout(opponentAI, 1000);
            }, 1000);
        }
    }, 100);
}
</script>
</body>
</html>