<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roen Card Game</title>
    <style>
        :root {
            --fire-color: #FF7B7B;
            --water-color: #7B8CFF;
            --wind-color: #7BFFB8;
            --earth-color: #C19A6B;
            --border-color: #555;
            --field-bg: rgba(0, 0, 0, 0.2);
            --hand-bg: rgba(0, 0, 0, 0.3);
            --card-width: 90px;
            --card-height: 130px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #3D3D3D;
            color: #F0F0F0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            border: 2px solid var(--border-color);
            background: #4A4A4A;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Top and Bottom Areas */
        .opponent-area, .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .player-area {
            flex-direction: column-reverse;
        }

        /* Info Bars */
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 20px;
            background: rgba(0, 0, 0, 0.2);
        }
        .deck-info, .graveyard-info, .hand-info {
            display: flex;
            align-items: center;
        }
        .deck-info .deck, .graveyard-info .graveyard, .hand-info .hand {
            width: calc(var(--card-width) * 0.7);
            height: calc(var(--card-height) * 0.7);
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            background: #666;
            margin: 0 10px;
        }
        .deck-info span, .graveyard-info span, .hand-info span {
            font-size: 14px;
        }



        /* Fields */
        .field {
            display: grid;
            grid-template-columns: repeat(3, var(--card-width));
            justify-content: center; /* Center the grid of cards */
            gap: 0px;
            padding: 0px;
            background: var(--field-bg);
            flex-grow: 1;
            /* Remove align-items and justify-items to make cards fill grid cell */
        }

        /* Center Area */
        .center-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 40px;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        .score {
            font-size: 48px;
            font-weight: bold;
        }
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #action-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            margin-top: 10px;
        }
        #action-panel h4 {
            margin: 0;
            color: white;
            font-size: 16px;
        }
        .game-button {
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
        }
        .game-button:hover {
            background-color: #45a049;
        }
        .turn-display {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700; /* Gold */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .card-message {
            font-size: 18px;
            color: #ADD8E6; /* Light Blue */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            margin-top: 5px;
            display: none; /* Hidden by default */
        }

        /* Player Hand */
        .player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 10px; /* Adjusted padding to move hand up */
            min-height: calc(var(--card-height) + 20px);
            background: var(--hand-bg);
        }
        .player-hand .card {
            margin: 0; /* No overlap for full visibility */
            transition: transform 0.2s ease, margin 0.2s ease;
        }
        .player-hand .card:hover {
            transform: translateY(-20px) scale(1.1);
            margin: 0 10px;
            z-index: 100;
        }

        /* Card Styling */
        .card-slot {
            width: var(--card-width);
            height: var(--card-height);
            border: none;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex; /* Make it a flex container to center content */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        .slot-number {
            font-size: 24px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.3); /* Semi-transparent white */
            pointer-events: none; /* Do not interfere with slot click */
        }
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border: none; /* No border for complete adjacency */
            border-radius: 8px;
            background-color: #ddd;
            color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            position: relative;
            user-select: none;
        }
        .card.fire { border-color: var(--fire-color); }
        .card.water { border-color: var(--water-color); }
        .card.wind { border-color: var(--wind-color); }
        .card.earth { border-color: var(--earth-color); }

        .card-header, .card-footer {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            font-size: 18px;
        }
        .card-body {
            text-align: center;
            font-size: 14px;
        }
        .card-body .attribute {
             font-size: 12px;
             padding: 2px 4px;
             border-radius: 4px;
             color: white;
        }
        .fire .attribute { background-color: var(--fire-color); }
        .water .attribute { background-color: var(--water-color); }
        .wind .attribute { background-color: var(--wind-color); }
        .earth .attribute { background-color: var(--earth-color); }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 15px;
            background-color: #555;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background-color: #32CD32; /* Green */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        
        .card.selected {
            transform: scale(1.1);
            border-color: yellow;
            box-shadow: 0 0 15px yellow;
        }
        .hp-display {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        /* Log Area */
        .log-area {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
        }
        .log-area h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #888;
        }
        .log-area p {
            margin: 0 0 5px 0;
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Log Area -->
    <div id="log-area" class="log-area">
        <h3>ゲームログ</h3>
    </div>

    <!-- Opponent's Area -->
    <div class="opponent-area">
        <div id="opponent-field" class="field"></div>
        <div class="info-bar">
            <div id="opponent-hand" class="hand-info">
                <span class="hand-label">手札: 0</span>
                <div class="hand"></div>
            </div>
            <div id="opponent-graveyard" class="graveyard-info">
                <span class="graveyard-label">墓地: 0</span>
                <div class="graveyard"></div>
            </div>
            <div id="opponent-deck" class="deck-info">
                <div class="deck"></div>
                <span class="deck-label">デッキ: 18/30</span>
            </div>
        </div>
    </div>

    <!-- Center Area -->
    <div class="center-area">
        <div id="opponent-score" class="score">0</div>
        <div class="center-controls">
            <button id="placement-ok-button" class="game-button">配置OK</button>
            <button id="end-turn-button" class="game-button" style="display:none;">ターン終了</button>
            <div id="current-turn-display" class="turn-display"></div>
            <div id="card-use-message" class="card-message"></div>
        </div>
        <div id="player-score" class="score">0</div>
    </div>

    <!-- Player's Area -->
    <div class="player-area">
        <div id="player-hand" class="player-hand"></div>
        <div id="player-field" class="field"></div>
        <div class="info-bar">
            <div id="player-deck" class="deck-info">
                 <span class="deck-label">デッキ: 17/30</span>
                <div class="deck"></div>
            </div>
            <div id="player-graveyard" class="graveyard-info">
                <div class="graveyard"></div>
                <span class="graveyard-label">墓地: 0</span>
            </div>
            <div id="player-hand" class="hand-info">
                <div class="hand"></div>
                <span class="hand-label">手札: 0</span>
            </div>
        </div>
    </div>
</div>

    <div id="action-panel" style="display:none;">
        <h4 id="attacking-card-info"></h4>
        <button id="attack-button" class="game-button">攻撃</button>
        <button id="special-attack-button" class="game-button" disabled>特別技 (選択不可)</button>
        <button id="cancel-attack-button" class="game-button">キャンセル</button>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {    const SUITS = ['fire', 'water', 'wind', 'earth'];
    const RANKS = ['A', 'K', 'Q', 'J', '9', '8', '6', '4', '3'];
    const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '9': 9, '8': 8, '6': 6, '4': 4, '3': 3 };

    class Card {
        constructor(suit, rank, type = 'monster', effect = null) {
            this.id = `${suit}-${rank}-${Math.random()}`;
            this.suit = suit;
            this.rank = rank;
            this.value = RANK_VALUES[rank];
            this.hp = this.value;
            this.maxHp = this.value;
            this.type = type; // 'monster' or 'support'
            this.effect = effect; // For support cards, e.g., 'skip_turn', 'draw_2', 'heal_2'
        }
    }

    const state = {
        player: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 17,
            totalDeck: 30,
            attackedCardsThisTurn: [], // New property to track attacked cards
        },
        opponent: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 18,
            totalDeck: 30,
            skipNextTurn: false,
            attackedCardsThisTurn: [], // New property for opponent too (though not implemented yet for opponent)
        },
        selectedCard: null,
        gameStarted: false,
        turn: null, // Track current player: 'player' or 'opponent'
        turnCount: 0, // Track the number of turns
        attackingCardId: null, // ID of the card currently selected to attack
        attackCountThisTurn: 0, // Number of attacks made this turn
    };

    function createDeck() {
        const deck = [];
        const supportCards = [
            { suit: 'none', rank: 'Skip', type: 'support', effect: 'skip_turn' },
            { suit: 'none', rank: 'Draw2', type: 'support', effect: 'draw_2' },
            { suit: 'none', rank: 'Heal2', type: 'support', effect: 'heal_2' },
        ];

        for (let i = 0; i < 30; i++) {
            if (Math.random() < 0.15) { // Approximately 15% chance for a support card
                const supportCardData = supportCards[Math.floor(Math.random() * supportCards.length)];
                deck.push(new Card(supportCardData.suit, supportCardData.rank, supportCardData.type, supportCardData.effect));
            } else {
                const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
                deck.push(new Card(suit, rank));
            }
        }
        // Ensure there are at least some monster cards if random was too low
        while (deck.filter(c => c.type === 'monster').length < 20 && deck.length < 30) {
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            deck.push(new Card(suit, rank));
        }
        while (deck.length < 30) { // Fill up to 30 if needed
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            deck.push(new Card(suit, rank));
        }

        // Shuffle the deck (Fisher-Yates)
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        return deck;
    }

    function createCardElement(card, isFaceDown = false) {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${card.suit}`;
        cardEl.dataset.cardId = card.id;

        if (isFaceDown) {
            cardEl.innerHTML = `
                <div class="card-header"></div>
                <div class="card-body" style="font-size: 24px;">?</div>
                <div class="card-footer"></div>
            `;
            cardEl.style.backgroundColor = '#888';
            return cardEl;
        }

        if (card.type === 'support') {
            cardEl.innerHTML = `
                <div class="card-header">
                    <span>${card.rank}</span>
                    <span class="attribute">SUPPORT</span>
                </div>
                <div class="card-body">
                    <span class="attribute">${card.rank}</span>
                </div>
                <div class="card-footer">
                    <span>${card.rank}</span>
                </div>
            `;
            cardEl.style.backgroundColor = '#999'; // Gray background for support cards
        } else {
            cardEl.innerHTML = `
                <div class="card-header">
                    <span>${card.rank}</span>
                    <span class="attribute">${card.suit.charAt(0).toUpperCase()}</span>
                </div>
                <div class="hp-display">${card.hp}/${card.maxHp}</div>
                <div class="card-body">
                    <span class="attribute">${card.suit}</span>
                </div>
                <div class="card-footer">
                    <span>${card.rank}</span>
                </div>
            `;
        }
        return cardEl;
    }

    function addLog(message) {
        const logArea = document.getElementById('log-area');
        const p = document.createElement('p');
        p.textContent = `> ${message}`;
        logArea.appendChild(p);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function updateTurnDisplay() {
        const turnDisplay = document.getElementById('current-turn-display');
        const endTurnButton = document.getElementById('end-turn-button'); // Get button here
        if (state.gameStarted && state.turn) {
            turnDisplay.textContent = `${state.turn === 'player' ? 'あなたの番' : '相手の番'}`;
            if (state.turn === 'player') {
                endTurnButton.style.display = 'block';
            } else {
                endTurnButton.style.display = 'none';
            }
        } else {
            turnDisplay.textContent = '配置準備中';
            endTurnButton.style.display = 'none'; // Ensure button is hidden during setup
        }
    }
    
    function onPlayerHandCardClick(card, cardEl) {
        if (state.gameStarted && state.turn !== 'player') {
            addLog('相手の番です。');
            return;
        }

                    // --- Support Card Usage ---
                    if (card.type === 'support') {
                        displayCardUseMessage(`${card.rank} を使用しました！`); // Use new display function
                        addLog(`サポートカード ${card.rank} を使用しました！`); // Keep log too
                        // Remove card from hand
                        state.player.hand = state.player.hand.filter(c => c.id !== card.id);
                        state.player.graveyard.push(card); // Move used support card to graveyard
            switch (card.effect) {
                case 'skip_turn':
                    state.opponent.skipNextTurn = true;
                    addLog('相手の次のターンをスキップします。');
                    break;
                case 'draw_2':
                    for (let i = 0; i < 2; i++) {
                        if (state.player.deck.length > 0) {
                            const drawnCard = state.player.deck.shift();
                            state.player.hand.push(drawnCard);
                            state.player.deckCount--;
                            addLog(`山札から ${drawnCard.suit} ${drawnCard.rank} を引きました。`);
                        } else {
                            addLog('山札がありません。追加ドローできませんでした。');
                            break;
                        }
                    }
                    break;
                case 'heal_2':
                    const playerFieldCards = state.player.field.filter(c => c !== null);
                    if (playerFieldCards.length > 0) {
                        const cardToHeal = playerFieldCards[Math.floor(Math.random() * playerFieldCards.length)];
                        cardToHeal.hp = Math.min(cardToHeal.maxHp, cardToHeal.hp + 2);
                        addLog(`${cardToHeal.suit} ${cardToHeal.rank} のHPを2回復しました。現在HP: ${cardToHeal.hp}/${cardToHeal.maxHp}`);
                    } else {
                        addLog('回復するフィールドカードがありません。');
                    }
                    break;
            }
            state.selectedCard = null;
            render();
            return;
        }

        // --- Monster Card Placement ---
        if (card.type === 'monster') {
            if (state.selectedCard && state.selectedCard.id === card.id) {
                state.selectedCard = null;
                cardEl.classList.remove('selected');
            } else {
                const prevSelectedHandCard = document.querySelector('#player-hand .card.selected');
                if (prevSelectedHandCard) prevSelectedHandCard.classList.remove('selected');
                
                state.selectedCard = card;
                cardEl.classList.add('selected');
                addLog(`手札から ${card.suit} ${card.rank} を選択しました。配置する場所を選んでください。`);
            }
            return;
        }
    }

    function onPlayerFieldCardClick(card, cardEl) { // Handles clicks on player's field monster cards
        if (!state.gameStarted || state.turn !== 'player') {
            addLog('ゲームが開始していないか、相手の番です。');
            return;
        }
        if (card.type !== 'monster') { // Only monster cards on field can initiate attack
            addLog('フィールドのモンスターカードのみ攻撃を選択できます。');
            return;
        }
        // Check if the card is in the front row (slots 0, 1, 2)
        const cardIndex = state.player.field.findIndex(c => c && c.id === card.id);
        if (cardIndex === -1 || cardIndex >= 3) { // Front row slots are 0, 1, 2
            addLog('前衛のモンスターカードのみ攻撃を選択できます。');
            return;
        }

        const actionPanel = document.getElementById('action-panel');
        const attackingCardInfo = document.getElementById('attacking-card-info');

        if (state.attackingCardId) {
            const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
            if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
            if (state.attackingCardId === card.id) {
                state.attackingCardId = null;
                actionPanel.style.display = 'none';
                return;
            }
        }
        
        state.attackingCardId = card.id;
        cardEl.classList.add('selected-attack');
        attackingCardInfo.textContent = `選択中のカード: ${card.suit} ${card.rank} (攻撃力: ${card.value})`;
        actionPanel.style.display = 'flex';
        addLog(`自分のカード ${card.suit} ${card.rank} を選択しました。攻撃対象を選んでください。`);
    }

    function onOpponentFieldCardClick(card, cardEl) {
        if (!state.attackingCardId) {
            addLog('まず自分のカードを選択してください。');
            return;
        }
        if (state.attackCountThisTurn >= 3) {
            addLog('今ターンはこれ以上攻撃できません。');
            return;
        }
        // Check if the target card is in the front row (slots 0, 1, 2)
        const targetIndex = state.opponent.field.findIndex(c => c && c.id === card.id);
        if (targetIndex === -1 || targetIndex >= 3) { // Front row slots are 0, 1, 2
            addLog('相手の前衛のモンスターカードのみ攻撃対象にできます。');
            return;
        }

        const attackingCard = state.player.field.flat().find(c => c && c.id === state.attackingCardId);
        if (!attackingCard) {
            addLog('選択中の攻撃カードが見つかりません。');
            return;
        }
        if (state.player.attackedCardsThisTurn.includes(attackingCard.id)) {
            addLog(`${attackingCard.suit} ${attackingCard.rank} はこのターン既に攻撃済みです。`);
            return;
        }

        // Only front row cards can attack/be attacked (simplified for now as all field cards can attack/be attacked)
        // More sophisticated logic would check card position in field[0-2] for front row

        addLog(`${attackingCard.suit} ${attackingCard.rank} が ${card.suit} ${card.rank} を攻撃！`);
        addLog(`${card.suit} ${card.rank} のHPが ${attackingCard.value} 減少！`);

        card.hp -= attackingCard.value;
        state.attackCountThisTurn++;
        state.player.attackedCardsThisTurn.push(attackingCard.id); // Mark card as attacked
        
        // Check if opponent card is destroyed
        if (card.hp <= 0) {
            addLog(`${card.suit} ${card.rank} は破壊され、墓地へ送られました。`);
            state.opponent.graveyard.push(card);
            // Remove card from field
            const indexInField = state.opponent.field.findIndex(c => c && c.id === card.id);
            if (indexInField !== -1) {
                state.opponent.field[indexInField] = null;
            }
        } else {
            addLog(`${card.suit} ${card.rank} の残りHP: ${card.hp}/${card.maxHp}`);
        }

        // Deselect attacking card and hide action panel
        const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
        if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
        state.attackingCardId = null;
        document.getElementById('action-panel').style.display = 'none';

        render(); // Re-render to reflect changes
    }

    function displayCardUseMessage(message) {
        const cardUseMessageEl = document.getElementById('card-use-message');
        cardUseMessageEl.textContent = message;
        cardUseMessageEl.style.display = 'block';
        setTimeout(() => {
            cardUseMessageEl.style.display = 'none';
            cardUseMessageEl.textContent = '';
        }, 2000); // Message disappears after 2 seconds
    }

    function render() {
        // Render Player Hand
        const playerHandEl = document.getElementById('player-hand');
        playerHandEl.innerHTML = '';
        state.player.hand.forEach(card => {
            const cardEl = createCardElement(card);
            cardEl.addEventListener('click', () => onPlayerHandCardClick(card, cardEl)); // Use specific hand click handler
            playerHandEl.appendChild(cardEl);
        });

        // Render Fields
        renderField('player-field', state.player.field, 'player');
        renderField('opponent-field', state.opponent.field, 'opponent');

        // Update Info Panels
        document.querySelector('#player-deck .deck-label').textContent = `デッキ: ${state.player.deckCount}/${state.player.totalDeck}`;
        document.querySelector('#player-graveyard .graveyard-label').textContent = `墓地: ${state.player.graveyard.length}`;
        document.querySelector('#player-hand .hand-label').textContent = `手札: ${state.player.hand.length}`; // New: Player hand count

        document.querySelector('#opponent-deck .deck-label').textContent = `デッキ: ${state.opponent.deckCount}/${state.opponent.totalDeck}`;
        document.querySelector('#opponent-graveyard .graveyard-label').textContent = `墓地: ${state.opponent.graveyard.length}`;
        document.querySelector('#opponent-hand .hand-label').textContent = `手札: ${state.opponent.hand.length}`; // New: Opponent hand count
        
        updateTurnDisplay(); // Update turn display on render
        checkWinCondition(); // Check win/loss conditions
    }

    function renderField(fieldId, fieldCards, playerType) { // Added playerType parameter
        const fieldEl = document.getElementById(fieldId);
        fieldEl.innerHTML = '';
        fieldCards.forEach((card, index) => {
            if (card) {
                const cardEl = createCardElement(card);
                if (playerType === 'player') {
                    cardEl.addEventListener('click', () => onPlayerFieldCardClick(card, cardEl)); // Player's own field cards
                } else { // Opponent's field cards
                    cardEl.addEventListener('click', () => onOpponentFieldCardClick(card, cardEl));
                }
                fieldEl.appendChild(cardEl);
            } else {
                const slotEl = document.createElement('div');
                slotEl.className = 'card-slot';
                slotEl.dataset.slotIndex = index;
                slotEl.innerHTML = `<span class="slot-number">${index + 1}</span>`; // Add slot number
                if (fieldId === 'player-field') {
                    slotEl.addEventListener('click', () => onSlotClick(index));
                }
                fieldEl.appendChild(slotEl);
            }
        });
    }

    function onSlotClick(index) {
        // Allow placement during setup phase OR during player's turn if game started
        if (state.gameStarted && state.turn !== 'player') {
            addLog('相手の番には配置できません。');
            return;
        }
        // If game started, it must be player's turn. If not started, it's placement phase.

        if (!state.selectedCard) {
            addLog('先に手札から配置するカードを選択してください。');
            return;
        }
        if (state.selectedCard.type === 'support') { // Support cards cannot be placed on field
            addLog('サポートカードはフィールドに配置できません。');
            return;
        }
        if (state.player.field[index]) {
            addLog('その場所には既にカードが配置されています。');
            return;
        }

        const cardToPlace = state.selectedCard;
        state.player.hand = state.player.hand.filter(c => c.id !== cardToPlace.id);
        state.player.field[index] = cardToPlace;
        
        state.selectedCard = null;

        addLog(`「${cardToPlace.suit} ${cardToPlace.rank}」をフィールドに配置しました。`);
        // Placement OK button is only relevant during setup phase
        if (!state.gameStarted) {
            placementOkButton.disabled = false;
        }
        render();
    }

    function opponentTurnLogic() {
        addLog("相手のターンです...");
        let opponentAttacksLeft = Math.floor(Math.random() * 3) + 1; // Opponent attacks 1 to 3 times
        
        const performOpponentAttack = () => {
            if (opponentAttacksLeft <= 0 || state.player.field.every(c => c === null)) {
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }

            // Find an opponent card to attack with from the front row
            const availableOpponentCards = state.opponent.field.slice(0, 3).filter(c => c !== null); // Front row only
            if (availableOpponentCards.length === 0) {
                addLog("相手のフィールド前衛に攻撃可能なカードがありません。");
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }
            const attackingOpponentCard = availableOpponentCards[Math.floor(Math.random() * availableOpponentCards.length)];

            // Find a player card to attack from the front row
            const availablePlayerCards = state.player.field.slice(0, 3).filter(c => c !== null); // Front row only
            if (availablePlayerCards.length === 0) {
                addLog("プレイヤーのフィールド前衛にカードがありません。");
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }
            const targetPlayerCard = availablePlayerCards[Math.floor(Math.random() * availablePlayerCards.length)];

            addLog(`相手の ${attackingOpponentCard.suit} ${attackingOpponentCard.rank} があなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} を攻撃！`);
            addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} のHPが ${attackingOpponentCard.value} 減少！`);

            targetPlayerCard.hp -= attackingOpponentCard.value;
            
            if (targetPlayerCard.hp <= 0) {
                addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} は破壊され、墓地へ送られました。`);
                state.player.graveyard.push(targetPlayerCard);
                const indexInField = state.player.field.findIndex(c => c && c.id === targetPlayerCard.id);
                if (indexInField !== -1) {
                    state.player.field[indexInField] = null;
                }
            } else {
                addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} の残りHP: ${targetPlayerCard.hp}/${targetPlayerCard.maxHp}`);
            }

            opponentAttacksLeft--;
            render(); // Re-render after each attack
            setTimeout(performOpponentAttack, 1500); // Delay before next attack
        };

        // Initial delay before first opponent action
        setTimeout(performOpponentAttack, 1500);
    }

    function startTurn(player) {
        state.turn = player;
        state.turnCount++;
        addLog(`ターン ${state.turnCount}: ${player === 'player' ? 'あなたの番' : '相手の番'}`);
        
        if (player === 'player') {
            // Player draws a card at the start of their turn
            if (state.player.deck.length > 0) {
                const drawnCard = state.player.deck.shift(); // Remove from top of deck
                state.player.hand.push(drawnCard); // Add to hand
                state.player.deckCount--;
                addLog(`山札から ${drawnCard.suit} ${drawnCard.rank} を引きました。`);
            } else {
                addLog('山札がありません。カードを引けませんでした。');
            }
        }

        // Check for Skip Turn effect
        if (player === 'opponent' && state.opponent.skipNextTurn) {
            addLog('相手のターンはスキップされます！');
            state.opponent.skipNextTurn = false; // Reset flag
            // Immediately end opponent's turn and start player's turn again
            endTurn(); // This will call startTurn('player')
            return;
        }

        updateTurnDisplay();
        render(); // Ensure UI reflects current turn
        if (player === 'opponent') {
            opponentTurnLogic();
        }
    }

    function endTurn() {
        state.attackCountThisTurn = 0; // Reset attack count for the new turn
        state.player.attackedCardsThisTurn = []; // Reset attacked cards for player
        state.opponent.attackedCardsThisTurn = []; // Reset attacked cards for opponent (even if not used yet)

        // Rotate cards on the field
        state.player.field = rotateField(state.player.field);
        state.opponent.field = rotateField(state.opponent.field);

        const nextPlayer = state.turn === 'player' ? 'opponent' : 'player';
        startTurn(nextPlayer);
    }

    function checkWinCondition() {
        const playerFieldEmpty = state.player.field.every(c => c === null);
        const opponentFieldEmpty = state.opponent.field.every(c => c === null);

        if (playerFieldEmpty) {
            addLog('あなたのフィールド上のカードがすべてなくなりました。あなたの負けです！');
            // Implement game over logic (e.g., disable further actions, show restart button)
            state.gameStarted = false; // Stop game
            placementOkButton.style.display = 'block'; // Show restart button (use placementOk for now)
            placementOkButton.textContent = 'ゲームを再開';
            placementOkButton.disabled = false;
        } else if (opponentFieldEmpty) {
            addLog('相手のフィールド上のカードがすべてなくなりました。あなたの勝ちです！');
            // Implement game over logic
            state.gameStarted = false; // Stop game
            placementOkButton.style.display = 'block';
            placementOkButton.textContent = 'ゲームを再開';
            placementOkButton.disabled = false;
        }
    }

    function rotateField(fieldArray) {
        if (fieldArray.length !== 6) return fieldArray; // Expecting a 6-slot field

        const newField = new Array(6).fill(null);
        newField[1] = fieldArray[0]; // 0 -> 1
        newField[2] = fieldArray[1]; // 1 -> 2
        newField[5] = fieldArray[2]; // 2 -> 5 (後衛右端)
        newField[4] = fieldArray[5]; // 5 -> 4
        newField[3] = fieldArray[4]; // 4 -> 3
        newField[0] = fieldArray[3]; // 3 -> 0 (前衛左端)

        return newField;
    }

    function setupInitialState() {
        addLog("メインフェーズに移行 (準備)");
        
        state.player.hand = [
            new Card('earth', '9'),
            new Card('fire', '6'),
            new Card('fire', '4'),
            new Card('earth', '3'),
            new Card('water', 'Q'),
            new Card('wind', 'K'),
            new Card('water', 'A'),
            new Card('earth', '8'),
        ];
        
        updateTurnDisplay(); // Set initial '配置準備中' text
        render();
    }

    const placementOkButton = document.getElementById('placement-ok-button');
    const endTurnButton = document.getElementById('end-turn-button');

    placementOkButton.disabled = true; // Initially disabled

    placementOkButton.addEventListener('click', () => {
        if (state.gameStarted) return;
        if (state.player.field.every(slot => slot === null)) { // Check if any card is placed
            addLog('フィールドに最低1枚のカードを配置してください。');
            return;
        }

        placementOkButton.style.display = 'none';

        // Opponent places 3 monsters
        const opponentDeck = createDeck();
        for (let i = 0; i < 3; i++) {
            const randomCard = opponentDeck[Math.floor(Math.random() * opponentDeck.length)];
            let randomSlot;
            do {
                randomSlot = Math.floor(Math.random() * 6);
            } while (state.opponent.field[randomSlot] !== null);
            state.opponent.field[randomSlot] = randomCard;
            opponentDeck.splice(opponentDeck.indexOf(randomCard), 1);
        }
        addLog("相手が3体のモンスターを配置");
        addLog("プレイヤーの配置完了");
        
        addLog("先行決定ルーレット...");
        setTimeout(() => {
            const startingPlayer = Math.random() < 0.5 ? 'player' : 'opponent';
            state.gameStarted = true;
            addLog(`${startingPlayer === 'player' ? 'あなたが先行' : '相手が先行'}です！`);
            startTurn(startingPlayer); // Start the first turn
        }, 2000); // 2 second delay for roulette anticipation
    });
    
    endTurnButton.addEventListener('click', () => {
        if (state.gameStarted && state.turn === 'player') {
            endTurnButton.style.display = 'none'; // Hide button immediately
            endTurn();
        }
    });

    // Attack Action Panel Event Listeners
    const attackButton = document.getElementById('attack-button');
    const specialAttackButton = document.getElementById('special-attack-button');
    const cancelAttackButton = document.getElementById('cancel-attack-button');
    const actionPanel = document.getElementById('action-panel');

    attackButton.addEventListener('click', () => {
        // Attack logic will be triggered by clicking opponent's card after selecting attacker
        addLog('攻撃対象の相手カードを選択してください。');
    });

    // Special Attack Button is disabled in HTML, no need for listener.
    // specialAttackButton.addEventListener('click', () => {
    //     addLog('このカードは特別技が選択できません。');
    // });

    cancelAttackButton.addEventListener('click', () => {
        // Deselect attacking card
        const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
        if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
        state.attackingCardId = null;
        actionPanel.style.display = 'none';
        addLog('攻撃をキャンセルしました。');
    });

    setupInitialState();
});
</script>

</body>
</html>
