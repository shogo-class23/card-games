<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roen Card Game</title>
    <style>
        :root {
            --fire-color: #FF7B7B;
            --water-color: #7B8CFF;
            --wind-color: #7BFFB8;
            --earth-color: #C19A6B;
            --border-color: #555;
            --field-bg: rgba(0, 0, 0, 0.2);
            --hand-bg: rgba(0, 0, 0, 0.3);
            --card-width: 90px;
            --card-height: 130px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #3D3D3D;
            color: #F0F0F0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            border: 2px solid var(--border-color);
            background: #4A4A4A;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Top and Bottom Areas */
        .opponent-area, .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .player-area {
            flex-direction: column-reverse;
        }

        /* Info Bars */
        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 20px;
            background: rgba(0, 0, 0, 0.2);
        }
        .deck-info, .graveyard-info, .hand-info {
            display: flex;
            align-items: center;
        }
        .deck-info .deck, .graveyard-info .graveyard, .hand-info .hand {
            width: calc(var(--card-width) * 0.7);
            height: calc(var(--card-height) * 0.7);
            border: 2px solid #888;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            background: #666;
            margin: 0 10px;
        }
        .deck-info span, .graveyard-info span, .hand-info span, .power-info span {
            font-size: 14px;
        }

        .power-info {
            display: flex;
            align-items: center;
            margin-left: 20px; /* Adjust spacing as needed */
            color: #FFD700; /* Gold color for power */
            font-weight: bold;
        }



        /* Fields */
        .field {
            display: grid;
            grid-template-columns: repeat(3, var(--card-width));
            justify-content: center; /* Center the grid of cards */
            gap: 0px;
            padding: 0px;
            background: var(--field-bg);
            flex-grow: 1;
            /* Remove align-items and justify-items to make cards fill grid cell */
        }

        /* Center Area */
        .center-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 40px;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        .score {
            font-size: 48px;
            font-weight: bold;
        }
        .center-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #action-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.6);
            border-radius: 8px;
            margin-top: 10px;
        }
        #action-panel h4 {
            margin: 0;
            color: white;
            font-size: 16px;
        }
        .game-button {
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
        }
        .game-button:hover {
            background-color: #45a049;
        }
        .turn-display {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700; /* Gold */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .card-message {
            font-size: 18px;
            color: #ADD8E6; /* Light Blue */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            margin-top: 5px;
            display: none; /* Hidden by default */
        }

        /* Player Hand */
        .player-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px 10px; /* Adjusted padding to move hand up */
            min-height: calc(var(--card-height) + 20px);
            background: var(--hand-bg);
        }
        .player-hand .card {
            margin: 0; /* No overlap for full visibility */
            transition: transform 0.2s ease, margin 0.2s ease;
        }
        .player-hand .card:hover {
            transform: translateY(-20px) scale(1.1);
            margin: 0 10px;
            z-index: 100;
        }

        /* Card Styling */
        .card-slot {
            width: var(--card-width);
            height: var(--card-height);
            border: none;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            display: flex; /* Make it a flex container to center content */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }
        .slot-number {
            font-size: 24px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.3); /* Semi-transparent white */
            pointer-events: none; /* Do not interfere with slot click */
        }
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border: none; /* No border for complete adjacency */
            border-radius: 8px;
            background-color: #ddd;
            color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            position: relative;
            user-select: none;
        }
        .card.fire { border-color: var(--fire-color); }
        .card.water { border-color: var(--water-color); }
        .card.wind { border-color: var(--wind-color); }
        .card.earth { border-color: var(--earth-color); }

        .card-header, .card-footer {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            font-size: 18px;
        }
        .card-body {
            text-align: center;
            font-size: 14px;
        }
        .card-body .attribute {
             font-size: 12px;
             padding: 2px 4px;
             border-radius: 4px;
             color: white;
        }
        .fire .attribute { background-color: var(--fire-color); }
        .water .attribute { background-color: var(--water-color); }
        .wind .attribute { background-color: var(--wind-color); }
        .earth .attribute { background-color: var(--earth-color); }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 15px;
            background-color: #555;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background-color: #32CD32; /* Green */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        
        .card.selected {
            transform: scale(1.1);
            border-color: yellow;
            box-shadow: 0 0 15px yellow;
        }
        .hp-display {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            z-index: 10;
        }

        /* Power Cost Display */
        .power-cost-display {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 10px;
            font-weight: bold;
            color: #fff; /* White text for visibility */
            background-color: rgba(0, 0, 0, 0.6);
            padding: 2px 4px;
            border-radius: 3px;
        }



        /* Log Area */
        .log-area {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 5px;
            padding: 10px;
            font-size: 12px;
            overflow-y: auto;
        }
        .log-area h3 {
            margin: 0 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #888;
        }
        .log-area p {
            margin: 0 0 5px 0;
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Log Area -->
    <div id="log-area" class="log-area">
        <h3>ゲームログ</h3>
    </div>

    <!-- Opponent's Area -->
    <div class="opponent-area">
        <div id="opponent-field" class="field"></div>
        <div class="info-bar">
            <div id="opponent-hand" class="hand-info">
                <span class="hand-label">手札: 0</span>
                <div class="hand"></div>
            </div>
            <div id="opponent-graveyard" class="graveyard-info">
                <span class="graveyard-label">墓地: 0</span>
                <div class="graveyard"></div>
            </div>
            <div id="opponent-deck" class="deck-info">
                <div class="deck"></div>
                <span class="deck-label">山札: 18/30</span>
            </div>
            <div id="opponent-power" class="power-info">
                <span class="power-label">パワー: 0</span>
            </div>
        </div>
    </div>

    <!-- Center Area -->
    <div class="center-area">
        <div id="opponent-score" class="score">0</div>
                                                <div class="center-controls">
                                                    <button id="placement-ok-button" class="game-button">配置OK</button>
                                                    <button id="attach-power-central-button" class="game-button" style="display:none;">パワー注入</button>
                                                    <button id="end-turn-button" class="game-button" style="display:none;">ターン終了</button>
                                                    <div id="current-turn-display" class="turn-display"></div>
                                                    <div id="card-use-message" class="card-message"></div>
                                                </div>        <div id="player-score" class="score">0</div>
    </div>

    <!-- Player's Area -->
    <div class="player-area">
        <div id="player-hand" class="player-hand"></div>
        <div id="player-field" class="field"></div>
        <div class="info-bar">
            <div id="player-deck" class="deck-info">
                 <span class="deck-label">山札: 17/30</span>
                <div class="deck"></div>
            </div>
            <div id="player-graveyard" class="graveyard-info">
                <div class="graveyard"></div>
                <span class="graveyard-label">墓地: 0</span>
            </div>
            <div id="player-hand" class="hand-info">
                <div class="hand"></div>
                <span class="hand-label">手札: 0</span>
            </div>
            <div id="player-power" class="power-info">
                <span class="power-label">パワー: 0</span>
            </div>
        </div>
    </div>
</div>

    <div id="action-panel" style="display:none;">
        <h4 id="action-card-info"></h4>
        <button id="attack-button" class="game-button" style="display:none;">攻撃</button>
        <button id="special-attack-button" class="game-button" style="display:none;" disabled>特別技 (選択不可)</button>
        <button id="cancel-action-button" class="game-button">キャンセル</button>
    </div>

    <script>
document.addEventListener('DOMContentLoaded', () => {    const SUITS = ['fire', 'water', 'wind', 'earth'];
    const RANKS = ['A', 'K', 'Q', 'J', '9', '8', '6', '4', '3'];
    const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '9': 9, '8': 8, '6': 6, '4': 4, '3': 3 };

    class Card {
        constructor(suit, rank, type = 'monster', effect = null) {
            this.id = `${suit}-${rank}-${Math.random()}`;
            this.suit = suit;
            this.rank = rank;
            this.value = RANK_VALUES[rank];
            this.hp = this.value;
            this.maxHp = this.value;
            this.type = type; // 'monster' or 'support'
            this.effect = effect; // For support cards, e.g., 'skip_turn', 'draw_2', 'heal_2'
            this.attachedPower = 0; // New: Power attached to this card
            this.requiredPower = this.calculateRequiredPower(rank); // New: Power needed to attack
        }

        calculateRequiredPower(rank) {
            switch (rank) {
                case '2':
                case '3': return 0;
                case '4':
                case '5':
                case '6': return 1;
                case '7':
                case '8':
                case '9':
                case '10': return 2;
                case 'J':
                case 'Q':
                case 'K':
                case 'A': return 3;
                default: return 0;
            }
        }
    }

    const state = {
        player: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 17,
            totalDeck: 30,
            attackedCardsThisTurn: [], // New property to track attacked cards
            currentPower: 0, // New: Available power for the player
        },
        opponent: {
            deck: [],
            hand: [],
            field: Array(6).fill(null),
            graveyard: [],
            deckCount: 18,
            totalDeck: 30,
            skipNextTurn: false,
            attackedCardsThisTurn: [], // New property for opponent too (though not implemented yet for opponent)
            currentPower: 0, // New: Available power for the opponent
        },
        selectedCard: null,
        gameStarted: false,
        turn: null, // Track current player: 'player' or 'opponent'
        turnCount: 0, // Track the number of turns
        attackingCardId: null, // ID of the card currently selected to attack
        attackCountThisTurn: 0, // Number of attacks made this turn
    };

    function createDeck() {
        const deck = [];
        const supportCards = [
            { suit: 'none', rank: 'Skip', type: 'support', effect: 'skip_turn' },
            { suit: 'none', rank: 'Draw2', type: 'support', effect: 'draw_2' },
            { suit: 'none', rank: 'Heal2', type: 'support', effect: 'heal_2' },
        ];

        for (let i = 0; i < 30; i++) {
            if (Math.random() < 0.15) { // Approximately 15% chance for a support card
                const supportCardData = supportCards[Math.floor(Math.random() * supportCards.length)];
                deck.push(new Card(supportCardData.suit, supportCardData.rank, supportCardData.type, supportCardData.effect));
            } else {
                const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
                const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
                deck.push(new Card(suit, rank));
            }
        }
        // Ensure there are at least some monster cards if random was too low
        while (deck.filter(c => c.type === 'monster').length < 20 && deck.length < 30) {
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            deck.push(new Card(suit, rank));
        }
        while (deck.length < 30) { // Fill up to 30 if needed
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            deck.push(new Card(suit, rank));
        }

        // Shuffle the deck (Fisher-Yates)
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        return deck;
    }

    function createCardElement(card, playerType = null, isFaceDown = false) {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${card.suit}`;
        cardEl.dataset.cardId = card.id;

        if (isFaceDown) {
            cardEl.innerHTML = `
                <div class="card-header"></div>
                <div class="card-body" style="font-size: 24px;">?</div>
                <div class="card-footer"></div>
            `;
            cardEl.style.backgroundColor = '#888';
            return cardEl;
        }

        if (card.type === 'support') {
            cardEl.innerHTML = `
                <div class="card-header">
                    <span>${card.rank}</span>
                    <span class="attribute">SUPPORT</span>
                </div>
                <div class="card-body">
                    <span class="attribute">${card.rank}</span>
                </div>
                <div class="card-footer">
                    <span>${card.rank}</span>
                </div>
            `;
            cardEl.style.backgroundColor = '#999'; // Gray background for support cards
        } else if (card.type === 'monster') {
            cardEl.innerHTML = `
                <div class="card-header">
                    <span>${card.rank}</span>
                    <span class="attribute">${card.suit.charAt(0).toUpperCase()}</span>
                </div>
                <div class="hp-display">${card.hp}/${card.maxHp}</div>
                <div class="card-body">
                    <span class="attribute">${card.suit}</span>
                </div>
                <div class="card-footer">
                    <span>ATK: ${card.value}</span>
                    <span class="power-cost-display">${card.attachedPower}/${card.requiredPower}</span>
                </div>
            `;

        }
        return cardEl;
    }

    function addLog(message) {
        const logArea = document.getElementById('log-area');
        const p = document.createElement('p');
        p.textContent = `> ${message}`;
        logArea.appendChild(p);
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function updateTurnDisplay() {
        const turnDisplay = document.getElementById('current-turn-display');
        const endTurnButton = document.getElementById('end-turn-button'); // Get button here
        if (state.gameStarted && state.turn) {
            turnDisplay.textContent = `${state.turn === 'player' ? 'あなたの番' : '相手の番'}`;
            if (state.turn === 'player') {
                endTurnButton.style.display = 'block';
            } else {
                endTurnButton.style.display = 'none';
            }
        } else {
            turnDisplay.textContent = '配置準備中';
            endTurnButton.style.display = 'none'; // Ensure button is hidden during setup
        }
    }
    
    function onPlayerHandCardClick(card, cardEl) {
        if (state.gameStarted && state.turn !== 'player') {
            addLog('相手の番です。');
            return;
        }

                    // --- Support Card Usage ---
                    if (card.type === 'support') {
                        displayCardUseMessage(`${card.rank} を使用しました！`); // Use new display function
                        addLog(`サポートカード ${card.rank} を使用しました！`); // Keep log too
                        // Remove card from hand
                        state.player.hand = state.player.hand.filter(c => c.id !== card.id);
                        state.player.graveyard.push(card); // Move used support card to graveyard
            switch (card.effect) {
                case 'skip_turn':
                    state.opponent.skipNextTurn = true;
                    addLog('相手の次のターンをスキップします。');
                    break;
                case 'draw_2':
                    for (let i = 0; i < 2; i++) {
                        if (state.player.deck.length > 0) {
                            const drawnCard = state.player.deck.shift();
                            state.player.hand.push(drawnCard);
                            state.player.deckCount--;
                            addLog(`山札から ${drawnCard.suit} ${drawnCard.rank} を引きました。`);
                        } else {
                            addLog('山札がありません。追加ドローできませんでした。');
                            break;
                        }
                    }
                    break;
                case 'heal_2':
                    const playerFieldCards = state.player.field.filter(c => c !== null);
                    if (playerFieldCards.length > 0) {
                        const cardToHeal = playerFieldCards[Math.floor(Math.random() * playerFieldCards.length)];
                        cardToHeal.hp = Math.min(cardToHeal.maxHp, cardToHeal.hp + 2);
                        addLog(`${cardToHeal.suit} ${cardToHeal.rank} のHPを2回復しました。現在HP: ${cardToHeal.hp}/${cardToHeal.maxHp}`);
                    } else {
                        addLog('回復するフィールドカードがありません。');
                    }
                    break;
            }
            state.selectedCard = null;
            render();
            return;
        }

        // --- Monster Card Placement ---
        if (card.type === 'monster') {
            if (state.selectedCard && state.selectedCard.id === card.id) {
                state.selectedCard = null;
                cardEl.classList.remove('selected');
            } else {
                const prevSelectedHandCard = document.querySelector('#player-hand .card.selected');
                if (prevSelectedHandCard) prevSelectedHandCard.classList.remove('selected');
                
                state.selectedCard = card;
                cardEl.classList.add('selected');
                addLog(`手札から ${card.suit} ${card.rank} を選択しました。配置する場所を選んでください。`);
            }
            return;
        }
    }

    function onPlayerFieldCardClick(card, cardEl) { // Handles clicks on player's field monster cards
        if (!state.gameStarted || state.turn !== 'player') {
            addLog('ゲームが開始していないか、相手の番です。');
            return;
        }
        if (card.type !== 'monster') {
            addLog('フィールドのモンスターカードのみ操作できます。');
            return;
        }

        // Always set selectedCard when a player's field card is clicked
        if (state.selectedCard && state.selectedCard.id === card.id) {
            cancelAction(); // Deselect if clicking the same card
            return;
        } else {
            // Deselect previously selected card if any
            if (state.selectedCard) {
                const prevSelectedCardEl = document.querySelector(`.card[data-card-id="${state.selectedCard.id}"]`);
                if (prevSelectedCardEl) prevSelectedCardEl.classList.remove('selected');
            }
            state.selectedCard = card;
            cardEl.classList.add('selected'); // Highlight current card
        }

        // Check if the card is in the front row (slots 0, 1, 2)
        const cardIndex = state.player.field.findIndex(c => c && c.id === card.id);
        const isInFrontRow = cardIndex !== -1 && cardIndex < 3;

        actionCardInfo.textContent = `選択中のカード: ${card.suit} ${card.rank} (攻撃力: ${card.value})`;
        actionPanel.style.display = 'flex'; // This shows the action panel

        if (isInFrontRow) {
            // This card can potentially attack, so show attack options in action panel
            attackButton.style.display = 'block';
            specialAttackButton.style.display = 'block';
            state.attackingCardId = card.id; // Set attackingCardId for attack flow
            addLog(`自分のカード ${card.suit} ${card.rank} を選択しました。攻撃対象を選んでください。`);
        } else {
            // Not in front row, no attack options from action panel
            attackButton.style.display = 'none';
            specialAttackButton.style.display = 'none';
            state.attackingCardId = null; // Clear attackingCardId if not attacking
            addLog(`自分のカード ${card.suit} ${card.rank} を選択しました。`);
        }

        // Always show the central power button if a player's monster on field is selected and it's player's turn
        if (state.gameStarted && state.turn === 'player' && state.selectedCard && state.selectedCard.type === 'monster' && state.player.field.includes(state.selectedCard)) {
            attachPowerCentralButton.style.display = 'block';
        } else {
            attachPowerCentralButton.style.display = 'none';
        }
    }

    function onOpponentFieldCardClick(card, cardEl) {
        if (!state.gameStarted || state.turn !== 'player') {
            addLog('ゲームが開始していないか、相手の番です。');
            return;
        }

        // If no attacking card is selected, treat clicking an opponent card as canceling current action
        if (!state.attackingCardId) {
            cancelAction();
            return;
        }

        if (state.attackCountThisTurn >= 3) {
            addLog('今ターンはこれ以上攻撃できません。');
            cancelAction(); // Clear selection and hide panel
            return;
        }
        // Check if the target card is in the front row (slots 0, 1, 2)
        const targetIndex = state.opponent.field.findIndex(c => c && c.id === card.id);

        const opponentFrontRowOccupied = state.opponent.field[3] !== null || state.opponent.field[4] !== null || state.opponent.field[5] !== null;
        const isTargetInOpponentFrontRow = targetIndex >= 3; // Front row for opponent (from player's perspective) are indices 3,4,5
        if (!isTargetInOpponentFrontRow && opponentFrontRowOccupied) {
            addLog('相手の前衛にモンスターがいるため、後衛を攻撃できません。');
            return;
        }
        // At this point, if we are here, target is either in front row, or in back row with empty front row.
        // This is the correct logic for selection.

        const attackingCard = state.player.field.flat().find(c => c && c.id === state.attackingCardId);
        if (!attackingCard) {
            addLog('選択中の攻撃カードが見つかりません。');
            return;
        }

        // Check if attacking card has enough attached power
        if (attackingCard.attachedPower < attackingCard.requiredPower) {
            addLog(`${attackingCard.suit} ${attackingCard.rank} は攻撃に必要なパワーが不足しています (必要: ${attackingCard.requiredPower}, 現在: ${attackingCard.attachedPower})。`);
            // Deselect attacking card and hide action panel
            const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
            if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
            state.attackingCardId = null;
            actionPanel.style.display = 'none';
            render(); // Re-render to clear any highlights
            return;
        }

        if (state.player.attackedCardsThisTurn.includes(attackingCard.id)) {
            addLog(`${attackingCard.suit} ${attackingCard.rank} はこのターン既に攻撃済みです。`);
            return;
        }

        // Only front row cards can attack/be attacked (simplified for now as all field cards can attack/be attacked)
        // More sophisticated logic would check card position in field[0-2] for front row

        addLog(`${attackingCard.suit} ${attackingCard.rank} が ${card.suit} ${card.rank} を攻撃！`);
        const totalAttackPower = attackingCard.value + attackingCard.attachedPower; // Include attached power
        addLog(`${card.suit} ${card.rank} のHPが ${totalAttackPower} 減少！`);

        card.hp -= totalAttackPower;
        // Consume attached power
        attackingCard.attachedPower -= attackingCard.requiredPower;
        addLog(`${attackingCard.suit} ${attackingCard.rank} はパワーを ${attackingCard.requiredPower} 消費しました。`);

        state.attackCountThisTurn++;
        state.player.attackedCardsThisTurn.push(attackingCard.id); // Mark card as attacked
        
        // Check if opponent card is destroyed
        if (card.hp <= 0) {
            addLog(`${card.suit} ${card.rank} は破壊され、墓地へ送られました。`);
            state.opponent.graveyard.push(card);
            // Remove card from field
            const indexInField = state.opponent.field.findIndex(c => c && c.id === card.id);
            if (indexInField !== -1) {
                state.opponent.field[indexInField] = null;
            }
        } else {
            addLog(`${card.suit} ${card.rank} の残りHP: ${card.hp}/${card.maxHp}`);
        }

        // Deselect attacking card and hide action panel
        const prevAttackingCardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
        if (prevAttackingCardEl) prevAttackingCardEl.classList.remove('selected-attack');
        state.attackingCardId = null;
        document.getElementById('action-panel').style.display = 'none';

        render(); // Re-render to reflect changes
    }

    function displayCardUseMessage(message) {
        const cardUseMessageEl = document.getElementById('card-use-message');
        cardUseMessageEl.textContent = message;
        cardUseMessageEl.style.display = 'block';
        setTimeout(() => {
            cardUseMessageEl.style.display = 'none';
            cardUseMessageEl.textContent = '';
        }, 2000); // Message disappears after 2 seconds
    }

    function displayGameEndMessage(message) {
        const cardUseMessageEl = document.getElementById('card-use-message');
        cardUseMessageEl.textContent = message;
        cardUseMessageEl.style.display = 'block'; // Make it visible and keep it visible
        // No setTimeout to hide it, it will persist until game restarts
    }

    function onAttachPowerButtonClick(targetCard) {
        const player = state.player;

        if (!state.gameStarted || state.turn !== 'player') {
            addLog('パワーをアタッチできません。ゲームが開始されていないか、相手の番です。');
            return;
        }

        if (player.currentPower <= 0) {
            addLog('利用可能なパワーがありません。');
            return;
        }

        if (targetCard.attachedPower >= targetCard.requiredPower) {
            addLog(`${targetCard.suit} ${targetCard.rank} はこれ以上パワーをアタッチできません。`);
            return;
        }

        player.currentPower--;
        targetCard.attachedPower++;
        addLog(`${targetCard.suit} ${targetCard.rank} にパワーを1アタッチしました。残りのパワー: ${player.currentPower}`);
        render();
    }

    function render() {
        // Render Player Hand
        const playerHandEl = document.getElementById('player-hand');
        playerHandEl.innerHTML = '';
        state.player.hand.forEach(card => {
            const cardEl = createCardElement(card);
            cardEl.addEventListener('click', () => onPlayerHandCardClick(card, cardEl)); // Use specific hand click handler
            playerHandEl.appendChild(cardEl);
        });

        // Render Fields
        renderField('player-field', state.player.field, 'player');
        renderField('opponent-field', state.opponent.field, 'opponent');

        // Update Info Panels
        document.querySelector('#player-deck .deck-label').textContent = `山札: ${state.player.deckCount}/${state.player.totalDeck}`;
        document.querySelector('#player-graveyard .graveyard-label').textContent = `墓地: ${state.player.graveyard.length}`;
        document.querySelector('#player-hand .hand-label').textContent = `手札: ${state.player.hand.length}`; // New: Player hand count
        document.querySelector('#player-power .power-label').textContent = `パワー: ${state.player.currentPower}`;

        document.querySelector('#opponent-deck .deck-label').textContent = `山札: ${state.opponent.deckCount}/${state.opponent.totalDeck}`;
        document.querySelector('#opponent-graveyard .graveyard-label').textContent = `墓地: ${state.opponent.graveyard.length}`;
        document.querySelector('#opponent-hand .hand-label').textContent = `手札: ${state.opponent.hand.length}`; // New: Opponent hand count
        document.querySelector('#opponent-power .power-label').textContent = `パワー: ${state.opponent.currentPower}`;
        
        updateTurnDisplay(); // Update turn display on render
        checkWinCondition(); // Check win/loss conditions
    }

    function renderField(fieldId, fieldCards, playerType) { // Added playerType parameter
        const fieldEl = document.getElementById(fieldId);
        fieldEl.innerHTML = '';

        const slotOrderMap = {
            'player': [0, 1, 2, 3, 4, 5], // Internal array index to grid order (0=top-left, 5=bottom-right for the requested layout)
            'opponent': [0, 1, 2, 3, 4, 5] // Internal array index to grid order (0=top-left, 5=bottom-right for the requested layout)
        };
        const displayedSlotNumbers = {
            'player': [1, 2, 3, 6, 5, 4],
            'opponent': [1, 2, 3, 4, 5, 6] // Visual slot numbers for opponent's field: front row (1,2,3) closest to player
        };

        fieldCards.forEach((card, index) => {
            const currentSlotOrder = slotOrderMap[playerType][index];
            const currentDisplayedSlotNumber = displayedSlotNumbers[playerType][index];

            if (card) {
                const isOpponentCardFaceDown = (playerType === 'opponent' && !state.gameStarted);
                const cardEl = createCardElement(card, playerType, isOpponentCardFaceDown); // Pass playerType and isFaceDown
                cardEl.style.order = currentSlotOrder + ' !important'; // Apply order to card
                if (playerType === 'player') {
                    cardEl.addEventListener('click', () => onPlayerFieldCardClick(card, cardEl)); // Player's own field cards
                } else { // Opponent's field cards
                    cardEl.addEventListener('click', () => onOpponentFieldCardClick(card, cardEl));
                }
                fieldEl.appendChild(cardEl);
            } else {
                const slotEl = document.createElement('div');
                slotEl.className = 'card-slot';
                slotEl.dataset.slotIndex = index;
                slotEl.style.order = currentSlotOrder + ' !important'; // Apply order to empty slot
                slotEl.innerHTML = `<span class="slot-number">${currentDisplayedSlotNumber}</span>`; // Add slot number
                if (fieldId === 'player-field') {
                    slotEl.addEventListener('click', () => onSlotClick(index));
                }
                fieldEl.appendChild(slotEl);
            }
        });
    }

    function onSlotClick(index) {
        // Allow placement during setup phase OR during player's turn if game started
        if (state.gameStarted && state.turn !== 'player') {
            addLog('相手の番には配置できません。');
            return;
        }
        // If game started, it must be player's turn. If not started, it's placement phase.

        if (state.selectedCard.type === 'support') { // Support cards cannot be placed on field
            addLog('サポートカードはフィールドに配置できません。');
            return;
        }
        if (state.player.field[index]) {
            addLog('その場所には既にカードが配置されています。');
            return;
        }

        const cardToPlace = state.selectedCard;
        state.player.hand = state.player.hand.filter(c => c.id !== cardToPlace.id);
        state.player.field[index] = cardToPlace;
        
        state.selectedCard = null;

        addLog(`「${cardToPlace.suit} ${cardToPlace.rank}」をフィールドに配置しました。`);
        // Placement OK button is only relevant during setup phase
        if (!state.gameStarted) {
            placementOkButton.disabled = false;
        }
        render();
    }

    function opponentTurnLogic() {
        addLog("相手のターンです...");
        let opponentAttacksLeft = Math.floor(Math.random() * 3) + 1; // Opponent attacks 1 to 3 times
        
        const performOpponentAttack = () => {
            if (opponentAttacksLeft <= 0 || state.player.field.every(c => c === null)) {
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }

            // Find an opponent card to attack with from the front row
            const availableOpponentCards = state.opponent.field.slice(0, 3).filter(c => c !== null); // Front row only
            if (availableOpponentCards.length === 0) {
                addLog("相手のフィールド前衛に攻撃可能なカードがありません。");
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }
            const attackingOpponentCard = availableOpponentCards[Math.floor(Math.random() * availableOpponentCards.length)];

            // Check if opponent card has enough attached power
            if (attackingOpponentCard.attachedPower < attackingOpponentCard.requiredPower) {
                addLog(`${attackingOpponentCard.suit} ${attackingOpponentCard.rank} は攻撃に必要なパワーが不足しています。`);
                // Try next attack or end turn if no other attacks are possible
                opponentAttacksLeft--;
                setTimeout(performOpponentAttack, 1500);
                return;
            }

            // Find a player card to attack from the front row
            const availablePlayerCards = state.player.field.slice(0, 3).filter(c => c !== null); // Front row only
            if (availablePlayerCards.length === 0) {
                addLog("プレイヤーのフィールド前衛にカードがありません。");
                addLog("相手がターンを終了しました。");
                endTurn();
                return;
            }
            const targetPlayerCard = availablePlayerCards[Math.floor(Math.random() * availablePlayerCards.length)];

            addLog(`相手の ${attackingOpponentCard.suit} ${attackingOpponentCard.rank} があなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} を攻撃！`);
            const totalAttackPower = attackingOpponentCard.value + attackingOpponentCard.attachedPower; // Include attached power
            addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} のHPが ${totalAttackPower} 減少！`);

            targetPlayerCard.hp -= totalAttackPower;
            // Consume attached power for opponent
            attackingOpponentCard.attachedPower -= attackingOpponentCard.requiredPower;
            addLog(`相手の ${attackingOpponentCard.suit} ${attackingOpponentCard.rank} はパワーを ${attackingOpponentCard.requiredPower} 消費しました。`);
            
            if (targetPlayerCard.hp <= 0) {
                addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} は破壊され、墓地へ送られました。`);
                state.player.graveyard.push(targetPlayerCard);
                const indexInField = state.player.field.findIndex(c => c && c.id === targetPlayerCard.id);
                if (indexInField !== -1) {
                    state.player.field[indexInField] = null;
                }
            } else {
                addLog(`あなたの ${targetPlayerCard.suit} ${targetPlayerCard.rank} の残りHP: ${targetPlayerCard.hp}/${targetPlayerCard.maxHp}`);
            }

            opponentAttacksLeft--;
            render(); // Re-render after each attack
            setTimeout(performOpponentAttack, 1500); // Delay before next attack
        };

        // Initial delay before first opponent action
        setTimeout(performOpponentAttack, 1500);
    }

    function startTurn(player) {
        state.turn = player;
        state.turnCount++;
        addLog(`ターン ${state.turnCount}: ${player === 'player' ? 'あなたの番' : '相手の番'}`);
        
        // Grant 1 power to the current player
        state[player].currentPower++;
        addLog(`${state[player].name}がパワーを1獲得！(合計: ${state[player].currentPower})`);

        if (player === 'player') {
            drawCard('player'); // Automate draw for player
            attachPowerCentralButton.style.display = 'block'; // Show for player
        } else {
            drawCard('opponent'); // Automate draw for opponent
            attachPowerCentralButton.style.display = 'none'; // Hide for opponent
        }

        // Check for Skip Turn effect
        if (player === 'opponent' && state.opponent.skipNextTurn) {
            addLog('相手のターンはスキップされます！');
            state.opponent.skipNextTurn = false; // Reset flag
            // Immediately end opponent's turn and start player's turn again
            endTurn(); // This will call startTurn('player')
            return;
        }

        updateTurnDisplay();
        render(); // Ensure UI reflects current turn
        if (player === 'opponent') {
            opponentTurnLogic();
        }
    }

    function endTurn() {
        state.attackCountThisTurn = 0; // Reset attack count for the new turn
        state.player.attackedCardsThisTurn = []; // Reset attacked cards for player
        state.opponent.attackedCardsThisTurn = []; // Reset attacked cards for opponent (even if not used yet)

        // Rotate cards on the field
        state.player.field = rotateField(state.player.field);
        state.opponent.field = rotateField(state.opponent.field);

        const nextPlayer = state.turn === 'player' ? 'opponent' : 'player';
        startTurn(nextPlayer);
    }

    function checkWinCondition() {
        if (!state.gameStarted) return; // Only check win/loss once the game has started

        const playerMonsters = state.player.field.filter(c => c !== null && c.type === 'monster').length;
        const opponentMonsters = state.opponent.field.filter(c => c !== null && c.type === 'monster').length;

        if (playerMonsters === 0) {
            addLog('あなたのフィールド上のモンスターがすべていなくなりました。');
            displayGameEndMessage('ゲームオーバー！あなたの負けです！'); // Display message on screen
            state.gameStarted = false; // Stop game
            placementOkButton.style.display = 'block';
            placementOkButton.textContent = 'ゲームを再開';
            placementOkButton.disabled = false;
            attachPowerCentralButton.style.display = 'none'; // Hide central power button on game over
        } else if (opponentMonsters === 0) {
            addLog('相手のフィールド上のモンスターがすべていなくなりました。');
            displayGameEndMessage('勝利！おめでとうございます！'); // Display message on screen
            state.gameStarted = false; // Stop game
            placementOkButton.style.display = 'block';
            placementOkButton.textContent = 'ゲームを再開';
            placementOkButton.disabled = false;
            attachPowerCentralButton.style.display = 'none'; // Hide central power button on game over
        }
    }

    function rotateField(fieldArray) {
        if (fieldArray.length !== 6) return fieldArray; // Expecting a 6-slot field

        const newField = new Array(6).fill(null);
        newField[1] = fieldArray[0]; // 0 -> 1
        newField[2] = fieldArray[1]; // 1 -> 2
        newField[5] = fieldArray[2]; // 2 -> 5 (後衛右端)
        newField[4] = fieldArray[5]; // 5 -> 4
        newField[3] = fieldArray[4]; // 4 -> 3
        newField[0] = fieldArray[3]; // 3 -> 0 (前衛左端)

        return newField;
    }

    const setupInitialState = () => {
        addLog("ゲーム準備中...");
        
        // Create and shuffle decks for both player and opponent
        state.player.deck = createDeck();
        state.opponent.deck = createDeck();
        state.player.deckCount = state.player.deck.length;
        state.opponent.deckCount = state.opponent.deck.length;

        // Draw initial hands (e.g., 5 cards each)
        for (let i = 0; i < 5; i++) {
            if (state.player.deck.length > 0) {
                state.player.hand.push(state.player.deck.shift());
            }
            if (state.opponent.deck.length > 0) {
                state.opponent.hand.push(state.opponent.deck.shift());
            }
        }
        state.player.deckCount = state.player.deck.length;
        state.opponent.deckCount = state.opponent.deck.length;
        
        updateTurnDisplay(); // Set initial '配置準備中' text
        render();
    };

    const placementOkButton = document.getElementById('placement-ok-button');
    const endTurnButton = document.getElementById('end-turn-button');

    placementOkButton.disabled = true; // Initially disabled

    placementOkButton.addEventListener('click', () => {
        if (!state.gameStarted && placementOkButton.textContent === 'ゲームを再開') {
            window.location.reload(); // Reload the page to restart the game
            return;
        }

        if (state.player.field.every(slot => slot === null)) { // Check if any card is placed
            addLog('フィールドに最低1枚のカードを配置してください。');
            return;
        }

        placementOkButton.style.display = 'none';

        // Opponent places 3 monsters
        const opponentMonstersToPlace = [];
        // First, try to pick 3 monster cards from hand, prioritizing them
        for (let i = 0; i < state.opponent.hand.length && opponentMonstersToPlace.length < 3; i++) {
            if (state.opponent.hand[i].type === 'monster') {
                opponentMonstersToPlace.push(state.opponent.hand[i]);
                state.opponent.hand.splice(i, 1); // Remove from hand
                i--; // Adjust index due to removal
            }
        }
        // If not enough monsters from hand, take from deck
        while (opponentMonstersToPlace.length < 3 && state.opponent.deck.length > 0) {
            const cardFromDeck = state.opponent.deck.shift();
            state.opponent.deckCount--;
            if (cardFromDeck.type === 'monster') {
                opponentMonstersToPlace.push(cardFromDeck);
            } else {
                state.opponent.graveyard.push(cardFromDeck); // Discard non-monster if needed for placement
                addLog('相手が山札からサポートカードを引きましたが、配置しないため墓地へ送られました。');
            }
        }

        let placedCount = 0;
        // Prioritize placing in front row (slots 3, 4, 5 for opponent's perspective of front)
        for (let slotIndex = 3; slotIndex < 6 && placedCount < 3; slotIndex++) {
            if (state.opponent.field[slotIndex] === null && opponentMonstersToPlace.length > 0) {
                state.opponent.field[slotIndex] = opponentMonstersToPlace.shift();
                placedCount++;
            }
        }
        // Fill remaining slots in back row (0, 1, 2) if any monsters left to place
        for (let slotIndex = 0; slotIndex < 3 && placedCount < 3; slotIndex++) {
            if (state.opponent.field[slotIndex] === null && opponentMonstersToPlace.length > 0) {
                state.opponent.field[slotIndex] = opponentMonstersToPlace.shift();
                placedCount++;
            }
        }
        addLog(`相手が${placedCount}体のモンスターを配置`);
        addLog("プレイヤーの配置完了");
        
        // Ensure both decks are shuffled right before the match starts
        shuffle(state.player.deck);
        shuffle(state.opponent.deck);

        addLog("先行決定ルーレット...");
        setTimeout(() => {
            const startingPlayer = Math.random() < 0.5 ? 'player' : 'opponent';
            state.gameStarted = true;
            addLog(`${startingPlayer === 'player' ? 'あなたが先行' : '相手が先行'}です！`);
            startTurn(startingPlayer); // Start the first turn
            // Show central power button if player is starting, hide otherwise
            if (startingPlayer === 'player') {
                attachPowerCentralButton.style.display = 'block';
            } else {
                attachPowerCentralButton.style.display = 'none';
            }
        }, 2000); // 2 second delay for roulette anticipation
    });
    
    endTurnButton.addEventListener('click', () => {
        if (state.gameStarted && state.turn === 'player') {
            endTurnButton.style.display = 'none'; // Hide button immediately
            attachPowerCentralButton.style.display = 'none'; // Hide central power button on turn end
            endTurn();
        }
    });

    // Attack Action Panel Event Listeners
    const attackButton = document.getElementById('attack-button');
    const specialAttackButton = document.getElementById('special-attack-button');
    // Removed attachPowerInPanelButton
    const cancelActionButton = document.getElementById('cancel-action-button');
    const actionPanel = document.getElementById('action-panel');
    const actionCardInfo = document.getElementById('action-card-info');

    const attachPowerCentralButton = document.getElementById('attach-power-central-button'); // New central power button

    function cancelAction() {
        if (state.selectedCard) {
            const cardEl = document.querySelector(`.card[data-card-id="${state.selectedCard.id}"]`);
            if (cardEl) cardEl.classList.remove('selected');
            state.selectedCard = null;
        }
        if (state.attackingCardId) { // Clear attacking card if set separately
            const cardEl = document.querySelector(`.card[data-card-id="${state.attackingCardId}"]`);
            if (cardEl) cardEl.classList.remove('selected-attack');
            state.attackingCardId = null;
        }
        actionPanel.style.display = 'none';
        attachPowerCentralButton.style.display = 'none'; // Hide central power button on cancel
        addLog('アクションをキャンセルしました。');
    }

    function onAttachPowerCentralClick() { // Renamed function
        const player = state.player;
        const targetCard = state.selectedCard;

        if (!state.gameStarted || state.turn !== 'player') {
            addLog('パワーをアタッチできません。ゲームが開始されていないか、相手の番です。');
            return;
        }
        if (!targetCard || targetCard.type !== 'monster' || !state.player.field.includes(targetCard)) {
            addLog('フィールド上のモンスターカードを選択してください。');
            return;
        }
        if (player.currentPower <= 0) {
            addLog('利用可能なパワーがありません。');
            return;
        }
        if (targetCard.attachedPower >= targetCard.requiredPower) {
            addLog(`${targetCard.suit} ${targetCard.rank} はこれ以上パワーをアタッチできません。`);
            return;
        }

        player.currentPower--;
        targetCard.attachedPower++;
        addLog(`${targetCard.suit} ${targetCard.rank} にパワーを1アタッチしました。残りのパワー: ${player.currentPower}`);
        cancelAction(); // Clear selection and hide panel after action
        render();
    }

    function drawCard(playerType) {
        const playerState = state[playerType];
        if (playerState.deck.length > 0) {
            const drawnCard = playerState.deck.shift();
            playerState.hand.push(drawnCard);
            playerState.deckCount = playerState.deck.length; // Update deckCount correctly
            addLog(`${playerType === 'player' ? 'あなた' : '相手'}は山札から ${drawnCard.suit} ${drawnCard.rank} を引きました。`);
        } else {
            addLog(`${playerType === 'player' ? 'あなたの' : '相手の'}山札がありません。カードを引けませんでした。`);
        }
    }


    attackButton.addEventListener('click', () => {
        addLog('攻撃対象の相手カードを選択してください。');
    });

    specialAttackButton.addEventListener('click', () => {
        addLog('特別技はまだ実装されていません。');
    });

    attachPowerCentralButton.addEventListener('click', onAttachPowerCentralClick); // Attach listener to new central button

    cancelActionButton.addEventListener('click', cancelAction);

    setupInitialState();
});
</script>

</body>
</html>
