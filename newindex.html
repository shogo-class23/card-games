<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Roen Card Game - Full Integrated Perfect</title>
    <style>
        :root {
            --fire-color: #FF7B7B; --water-color: #7B8CFF;
            --wind-color: #7BFFB8; --earth-color: #C19A6B;
            --card-width: 63px; --card-height: 91px;
            --accent: #FFCC00;
        }
        body { background-color: #3D3D3D; color: #F0F0F0; font-family: sans-serif; margin: 0; overflow: hidden; }
        
        .screen { display: none; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .menu-btn { width: 260px; padding: 15px; margin: 10px; background: #444; border: 2px solid #666; color: white; cursor: pointer; border-radius: 10px; font-weight: bold; text-align: center; font-size: 1.1em; }
        .menu-btn:hover { border-color: var(--accent); background: #555; transform: scale(1.02); }
        .game-button { padding: 8px 16px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; }
        .game-button:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }

        .game-container { width: 100%; max-width: 1000px; display: flex; flex-direction: column; height: 100vh; position: relative; }
        
        .field { 
            display: grid; 
            grid-template-areas: "slot0 slot1 slot2" "slot5 slot4 slot3"; 
            gap: 10px; padding: 15px; justify-content: center; background: rgba(0,0,0,0.2);
        }
        .field.opponent-field-layout {
            grid-template-areas: "slot3 slot4 slot5" "slot2 slot1 slot0";
        }

        .card-slot { width: var(--card-width); height: var(--card-height); background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; position: relative; border: 1px dashed rgba(255,255,255,0.2); }
        .card { width: var(--card-width); height: var(--card-height); border-radius: 8px; color: #333; cursor: pointer; position: relative; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; padding: 5px; font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-size: 0.7em; }
        .card.fire { background-color: var(--fire-color); }
        .card.water { background-color: var(--water-color); }
        .card.wind { background-color: var(--wind-color); }
        .card.earth { background-color: var(--earth-color); }
        .card.back { background-color: #666; border: 2px solid #444; }
        .card.selected { outline: 3px solid yellow; z-index: 10; }
        .card.attacked { filter: grayscale(0.9) brightness(0.7); cursor: default; }
        .hp-badge { position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.6); color: white; padding: 1px 3px; border-radius: 3px; font-size: 0.7em; }
        .player-hand, .opponent-hand-area { height: 110px; display: flex; justify-content: center; align-items: center; gap: 5px; background: rgba(0,0,0,0.4); }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 15px; background: #222; font-size: 0.85em; border-top: 1px solid #444; border-bottom: 1px solid #444; }
        .card-pile-slot { width: 50px; height: 70px; background: #666; border: 2px solid #444; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 0.8em; color: white; }
        .control-lane { display: flex; justify-content: space-around; align-items: center; background: #222; padding: 10px; }
        .center-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .score-display { font-size: 4em; font-weight: bold; min-width: 120px; text-align: center; }
        .score-display.opponent-score { color: #FF7B7B; }
        .score-display.player-score { color: #7B8CFF; }
        .log-area { position: absolute; left: 10px; top: 10px; width: 220px; height: 150px; background: rgba(0,0,0,0.85); font-size: 11px; overflow-y: auto; padding: 10px; z-index: 100; border: 1px solid #555; line-height: 1.4; color: #EEE; }
        
        #roulette-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 2000; font-size: 3em; color: #FFF; font-weight: bold; }

        .grid-container { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; max-height: 70vh; overflow-y: auto; padding: 20px; background: rgba(0,0,0,0.5); border-radius: 15px; width: 80%; }
        
        /* エディタ用の追加スタイル */
        .slot { background: #444; border: 2px solid #666; padding: 10px; border-radius: 8px; cursor: pointer; text-align: center; }
        .slot:hover { border-color: var(--accent); }
        .editor-layout { display: flex; gap: 20px; width: 95%; height: 75vh; }
        .scroll-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 10px; overflow-y: auto; flex-grow: 1; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="roulette-overlay">先攻を決定します</div>

<div id="title-screen" class="screen active">
    <h1 style="font-size: 3em; color:var(--accent); text-shadow: 2px 2px 10px rgba(0,0,0,0.5);">Roen Card Game</h1>
    <div class="menu-btn" onclick="showScreen('mode-screen')">ADVENTURE / BATTLE</div>
    <div class="menu-btn" onclick="openDeckList()">DECK EDITOR (100 Slots)</div>
    <div class="menu-btn" onclick="showScreen('collection-screen')">CARD COLLECTION</div>
    <div class="menu-btn" onclick="showScreen('settings-screen')">GAME SETTINGS</div>
</div>

<div id="editor-screen" class="screen">
    <h2 id="editor-title">DECK EDITOR</h2>
    <div class="editor-layout">
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3>CARD POOL</h3>
            <div id="pool-grid" class="scroll-grid"></div>
        </div>
        <div style="flex:1; display:flex; flex-direction:column;">
            <h3>DECK (<span id="deck-count">0</span>/40)</h3>
            <div id="current-deck-grid" class="scroll-grid"></div>
        </div>
    </div>
    <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="game-button" onclick="saveDeck()">SAVE & EXIT</button>
        <button class="game-button" style="background:#666" onclick="openDeckList()">CANCEL</button>
    </div>
</div>

<div id="mode-screen" class="screen">
    <h2>SELECT YOUR CHALLENGE</h2>
    <div class="menu-btn" style="background:#4CAF50" onclick="initBattle()">VS RANDOM AI</div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK TO TITLE</div>
</div>

<div id="settings-screen" class="screen">
    <h2>SETTINGS</h2>
    <div class="menu-btn" onclick="alert('Language: Japanese')">LANGUAGE: 日本語</div>
    <div class="menu-btn" onclick="alert('Sound Settings')">BGM / SE</div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="collection-screen" class="screen">
    <h2>COLLECTION</h2>
    <div id="coll-grid" class="grid-container" style="grid-template-columns: repeat(7, 1fr);"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="deck-list-screen" class="screen">
    <h2>CHOOSE DECK SLOT</h2>
    <div id="deck-grid" class="grid-container"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="game-screen" class="screen">
    <div class="game-container">
        <div id="log-area" class="log-area"><strong>【ゲームログ】</strong></div>
        <div id="opponent-hand" class="opponent-hand-area"></div>
        <div class="opponent-area"><div id="opponent-field" class="field opponent-field-layout"></div></div>
        <div class="info-row">
            <div class="info-item">手札: <span id="opp-hand-count">0</span></div>
            <div class="info-item">墓地: <div id="opp-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">山札: <div id="opp-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item" style="color:gold">パワー: <span id="opp-power-display">5</span></div>
        </div>
        <div class="control-lane">
            <div class="score-display opponent-score" id="opp-hp">20</div>
            <div class="center-controls">
                <div id="status-text" style="color:yellow; font-weight:bold; font-size:0.9em;">...</div>
                <button id="ok-btn" class="game-button" style="display:none;" onclick="confirmPlacement()">配置を完了する</button>
                <div id="battle-controls" style="display:none; flex-direction: column; gap: 10px; align-items: center;">
                    <button id="power-btn" class="game-button" style="background:#ccac00" onclick="handlePowerInject()">パワーを注入</button>
                    <button id="end-turn-btn" class="game-button" onclick="handleEndTurn()">ターン終了</button>
                </div>
            </div>
            <div class="score-display player-score" id="ply-hp">20</div>
        </div>
        <div class="info-row">
            <div class="info-item" style="color:gold">パワー: <span id="ply-power-display">5</span></div>
            <div class="info-item">山札: <div id="ply-deck" class="card-pile-slot">22/30</div></div>
            <div class="info-item">墓地: <div id="ply-graveyard" class="card-pile-slot">0</div></div>
            <div class="info-item">手札: <span id="ply-hand-count">0</span></div>
        </div>
        <div class="player-area"><div id="player-field" class="field"></div></div>
        <div id="player-hand" class="player-hand"></div>
    </div>
</div>

<script>
const SUITS = ['fire', 'water', 'wind', 'earth'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
const SUPPORTS = ['2DRAW','HEAL','SKIP'];

const RANK_VALUES = { 
    'A': 14, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,
    '2DRAW': 0, 'HEAL': 0, 'SKIP': 0 
};

class Card {
    constructor(suit, rank, type = 'unit') {
        this.id = Math.random().toString(36).substr(2, 9);
        this.suit = suit; this.rank = rank; this.type = type;
        this.value = RANK_VALUES[rank] || 0;
        this.hp = this.value; this.maxHp = this.value;
        this.attachedPower = 0;
        this.isSupport = (type === 'support' || SUPPORTS.includes(rank));
        this.requiredPower = this.isSupport ? 0 : (this.value >= 13 ? 3 : this.value >= 9 ? 2 : 1);
    }
}

let state = getInitialState(); // Initialize state when script loads

// Function to get the initial game state
function getInitialState() {
    return {
        editIdx: 1, 
        editCards: [], 
        player: { hand: [], field: Array(6).fill(null), deck: [], grave: 0, power: 5, hp: 20, attackedIds: [], powerInjected: false },
        opponent: { handCount: 5, field: Array(6).fill(null), deck: [], grave: 0, power: 5, hp: 20 },
        selectedCard: null, 
        turn: 'player', 
        statusText: '準備OK',
        canPlaceCard: false, 
        gameOver: false
    };
}


// --- 指示されたデッキエディタの魔法 ---

function openDeckList() {
    const grid = document.getElementById('deck-grid'); grid.innerHTML = '';
    for(let i=1; i<=100; i++) {
        const name = localStorage.getItem(`deck_name_${i}`) || `DECK ${i}`;
        const slot = document.createElement('div'); slot.className = 'slot'; slot.style.width="150px";
        slot.innerHTML = `<div>${name}</div><small>Slot ${i}</small>`;
        slot.onclick = () => { state.editIdx = i; enterEditor(); };
        grid.appendChild(slot);
    }
    showScreen('deck-list-screen');
}

function enterEditor() {
    const saved = localStorage.getItem(`deck_cards_${state.editIdx}`);
    state.editCards = saved ? JSON.parse(saved).map(d => Object.assign(new Card(), d)) : [];
    const pool = document.getElementById('pool-grid'); pool.innerHTML = '';
    SUITS.forEach(s => {
        RANKS.forEach(r => pool.appendChild(createCardUI(new Card(s, r), true)));
        SUPPORTS.forEach(a => pool.appendChild(createCardUI(new Card(s, a, 'support'), true)));
    });
    renderEditor(); showScreen('editor-screen');
}

function createCardUI(c, isPool) {
    const div = createCardEl(c); // ベースのカード表示を利用
    div.onclick = () => {
        if(isPool) { 
            if(state.editCards.length < 40) state.editCards.push(new Card(c.suit, c.rank, c.type)); 
        } else { 
            state.editCards.splice(state.editCards.indexOf(c), 1); 
        }
        renderEditor();
    };
    return div;
}

function renderEditor() {
    const grid = document.getElementById('current-deck-grid'); grid.innerHTML = '';
    state.editCards.forEach(c => grid.appendChild(createCardUI(c, false)));
    document.getElementById('deck-count').textContent = state.editCards.length;
}

function saveDeck() {
    localStorage.setItem(`deck_cards_${state.editIdx}`, JSON.stringify(state.editCards));
    const name = prompt("Name:", localStorage.getItem(`deck_name_${state.editIdx}`) || `DECK ${state.editIdx}`);
    if(name) localStorage.setItem(`deck_name_${state.editIdx}`, name);
    openDeckList();
}

// --- 聖域：元のロジックをすべて保持 ---

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    if (id === 'collection-screen') renderCollection();
}

function renderCollection() {
    const grid = document.getElementById('coll-grid'); grid.innerHTML = ''; 
    SUITS.forEach(s => {
        RANKS.forEach(r => grid.appendChild(createCardEl(new Card(s, r))));
        SUPPORTS.forEach(a => grid.appendChild(createCardEl(new Card(s, a, 'support'))));
    });
}

function addLog(msg) {
    const log = document.getElementById('log-area');
    const div = document.createElement('div'); div.textContent = `> ${msg}`;
    log.appendChild(div); log.scrollTop = log.scrollHeight;
}

function createCardEl(card) {
    const div = document.createElement('div'); div.className = `card ${card.suit}`;
    if(card.isSupport) {
        div.innerHTML = `<div class="hp-badge">SP</div><div style="font-size:0.9em">${card.rank}</div><div style="font-size:0.8em">${card.suit}</div>`;
    } else {
        div.innerHTML = `<div class="hp-badge">${card.hp}/${card.maxHp}</div><div style="font-size:1.2em">${card.rank}</div><div style="font-size:0.8em">${card.suit}</div><div style="font-size:0.9em">P:${card.attachedPower}/${card.requiredPower}<br>A:${card.value + card.attachedPower}</div>`;
    }
    return div;
}

function render() {
    renderField('player-field', state.player.field, false);
    renderField('opponent-field', state.opponent.field, true);
    const handEl = document.getElementById('player-hand'); handEl.innerHTML = '';
    state.player.hand.forEach(card => {
        const el = createCardEl(card);
        el.onclick = () => { if(!state.gameOver) { state.selectedCard = card; render(); } };
        if (state.selectedCard === card) el.classList.add('selected');
        handEl.appendChild(el);
    });
    const oppHandEl = document.getElementById('opponent-hand'); oppHandEl.innerHTML = '';
    for(let i=0; i<state.opponent.handCount; i++) {
        const back = document.createElement('div'); back.className = 'card back';
        oppHandEl.appendChild(back);
    }
    document.getElementById('opp-hp').textContent = state.opponent.hp;
    document.getElementById('ply-hp').textContent = state.player.hp;
    document.getElementById('opp-power-display').textContent = state.opponent.power;
    document.getElementById('ply-power-display').textContent = state.player.power;
    document.getElementById('opp-hand-count').textContent = state.opponent.handCount;
    document.getElementById('ply-hand-count').textContent = state.player.hand.length;
    document.getElementById('opp-deck').textContent = `${state.opponent.deck.length}/30`;
    document.getElementById('ply-deck').textContent = `${state.player.deck.length}/30`;
    document.getElementById('opp-graveyard').textContent = state.opponent.grave;
    document.getElementById('ply-graveyard').textContent = state.player.grave;
    document.getElementById('ok-btn').style.display = state.canPlaceCard ? 'block' : 'none';
    document.getElementById('battle-controls').style.display = state.canPlaceCard ? 'none' : 'flex';
    document.getElementById('power-btn').disabled = state.player.powerInjected || state.turn !== 'player';
}

function renderField(id, field, isOpponent) {
    const el = document.getElementById(id); el.innerHTML = '';
    field.forEach((card, i) => {
        const slot = document.createElement('div'); slot.className = 'card-slot'; slot.style.gridArea = `slot${i}`;
        if (card) {
            const cardEl = createCardEl(card);
            if (!isOpponent && state.player.attackedIds.includes(card.id)) cardEl.classList.add('attacked');
            if (state.selectedCard === card) cardEl.classList.add('selected');
            cardEl.onclick = (e) => {
                e.stopPropagation();
                if (state.gameOver) return;
                if (isOpponent) handleAttack(card);
                else handleFieldClick(card, i);
            };
            slot.appendChild(cardEl);
        } else if (state.canPlaceCard && !isOpponent) {
            // Only allow placing if no card is selected OR if selected card is not a support card
            if (!state.selectedCard || !state.selectedCard.isSupport) {
                slot.onclick = () => placeCard(i);
            } else {
                slot.onclick = null; // Disable click for support cards
            }
        }
        el.appendChild(slot);
    });
}

function placeCard(i) {
    if (!state.selectedCard) return;
    if (state.selectedCard.isSupport) { addLog("サポートカードは場に出せません。"); return; }
    state.player.field[i] = state.selectedCard;
    state.player.hand = state.player.hand.filter(c => c !== state.selectedCard);
    addLog(`${state.selectedCard.rank}を配置しました。`);
    state.selectedCard = null; render();
}

function handleFieldClick(card, i) {
    if (state.canPlaceCard) { 
        state.player.hand.push(card); state.player.field[i] = null; 
        addLog(`${card.rank}を手札に戻しました。`);
    } else { state.selectedCard = card; }
    render();
}

function handlePowerInject() {
    const c = state.selectedCard;
    if (c && state.player.field.includes(c) && c.attachedPower < c.requiredPower) {
        c.attachedPower++; state.player.powerInjected = true;
        addLog(`${c.rank}にパワーを注入。`); render();
    }
}

function handleAttack(targetCard) {
    if (state.canPlaceCard || !state.selectedCard) return;
    
    const attacker = state.selectedCard;

    // Check if the targetCard is in the opponent's front row (slots 3, 4, 5)
    const targetCardIndex = state.opponent.field.indexOf(targetCard);
    // Opponent field layout is reversed, so "front" to player is opponent's slots 3,4,5
    // which correspond to visual positions 1,2,3 for the opponent.
    if (targetCardIndex === -1 || targetCardIndex < 3) { // If not found or in opponent's visual back row (slots 0,1,2)
        addLog(`【${targetCard.rank}】は攻撃できない位置だぴょん！`);
        return;
    }
    
    // 攻撃前のログ
    addLog(`【${attacker.rank}】の攻撃を開始！`);

    if (attacker.attachedPower < attacker.requiredPower) {
        addLog(`……パワー不足で攻撃が不発に終わったぴょん。`);
        return;
    }

    if (state.player.attackedIds.includes(attacker.id)) {
        addLog(`【${attacker.rank}】はもうお疲れだぴょん（攻撃済み）。`);
        return;
    }
    
    const totalAtk = attacker.value;
    targetCard.hp -= totalAtk;
    state.player.attackedIds.push(attacker.id);
    
    // ダメージのログ（ここが大事！）
    addLog(`相手の【${targetCard.rank}】に ${totalAtk} ダメージ与えたぴょん！`);

    if (targetCard.hp <= 0) {
        const idx = state.opponent.field.indexOf(targetCard);
        if (idx !== -1) {
            state.opponent.field[idx] = null;
            state.opponent.graveyard.push(targetCard);
        }
        addLog(`★凄まじい音魔法で【${targetCard.rank}】を粉砕したぴょん！`);
    }
    
    state.selectedCard = null;
    render();
}

function confirmPlacement() { state.canPlaceCard = false; document.getElementById('status-text').textContent = "自ターン"; render(); }

function handleEndTurn() {
    state.player.powerInjected = false; state.player.attackedIds = [];
    state.turn = 'opponent'; document.getElementById('status-text').textContent = "相手ターン";
    addLog("ターン終了。"); render(); setTimeout(opponentAI, 1000);
}

function opponentAI() {
    addLog("相手の行動を開始したぴょん！");
    const cardsOnOpponentField = state.opponent.field.filter(c => c !== null);

    // Opponent tries to play a card from hand
    const playableCardInHand = state.opponent.hand.find(card =>
        state.opponent.field.includes(null) && card.requiredPower <= state.opponent.power
    );
    if (playableCardInHand) {
        const emptySlotIndex = state.opponent.field.indexOf(null);
        if (emptySlotIndex !== -1) {
            state.opponent.field[emptySlotIndex] = playableCardInHand;
            state.opponent.hand = state.opponent.hand.filter(c => c !== playableCardInHand); // Remove from hand
            state.opponent.handCount = state.opponent.hand.length;
            state.opponent.power -= playableCardInHand.requiredPower;
            addLog(`相手は【${playableCardInHand.rank}】を配置したぴょん！`);
        }
    } else {
        addLog(`相手はカードを配置しなかったぴょん。`);
    }

    // Opponent tries to power up a card
    const cardToPowerUp = cardsOnOpponentField.find(c => c.attachedPower < c.requiredPower && state.opponent.power > 0);
    if (cardToPowerUp) {
        cardToPowerUp.attachedPower++;
        state.opponent.power--;
        addLog(`相手は【${cardToPowerUp.rank}】にパワーを注入したぴょん！ (現在: ${cardToPowerUp.attachedPower}/${cardToPowerUp.requiredPower})`);
    } else if (cardsOnOpponentField.length > 0) {
        addLog(`相手はカードにパワーを注入しなかったぴょん。`);
    }

    // Opponent attacks
    cardsOnOpponentField.forEach(oppCard => {
            if (oppCard && oppCard.attachedPower >= oppCard.requiredPower) { // Check power requirement
                const totalOppAtk = oppCard.value; // Now only uses card's value for attack
                const playerFrontRowCards = [state.player.field[0], state.player.field[1], state.player.field[2]].filter(p => p !== null);

                if (playerFrontRowCards.length > 0) {
                    // Attack player's first available front row card
                    const targetCard = playerFrontRowCards[0];
                    targetCard.hp -= totalOppAtk;
                    addLog(`相手の【${oppCard.rank}】があなたの【${targetCard.rank}】に ${totalOppAtk} ダメージ与えたぴょん！`);
                    if (targetCard.hp <= 0) {
                        const idx = state.player.field.indexOf(targetCard);
                        if (idx !== -1) {
                            state.player.field[idx] = null;
                            state.player.grave++;
                            addLog(`あなたの【${targetCard.rank}】は撃破されたぴょん！`);
                        }
                    }
                } else {
                    // If no player front row cards, direct attack player
                    state.player.hp -= totalOppAtk;
                    addLog(`相手の【${oppCard.rank}】があなたに直接 ${totalOppAtk} ダメージ与えたぴょん！`);
                }
            } else if (oppCard) {
                addLog(`相手の【${oppCard.rank}】はパワーが足りないので攻撃できなかったぴょん。`);
            }
    });

    // End opponent's turn and pass back to player
    state.opponent.power = 5; // Restore opponent's power
    state.player.powerInjectedThisTurn = false; // Reset player's power injection flag
    state.turn = 'player';
    state.statusText = "あなたのターンです。";
    addLog("相手のターン終了。あなたのターン開始。");
    render();
    checkWin(); // Check for game over after opponent's turn
}

function checkWin() {
    const playerHasCards = state.player.hand.length > 0 || state.player.field.some(c => c !== null) || state.player.deck.length > 0;
    const opponentHasCards = state.opponent.handCount > 0 || state.opponent.field.some(c => c !== null) || state.opponent.deck.length > 0;

    if (state.gameOver) return; // Already game over

    if (state.opponent.hp <= 0 || !opponentHasCards) {
        state.gameOver = true;
        addLog("プレイヤーの勝利！おめでとうぴょん！");
        document.getElementById('status-text').textContent = "プレイヤーの勝利！"; // Update status text
        alert("YOU WIN! おめでとうぴょん！");
        showScreen('title-screen');
        return;
    }

    if (state.player.hp <= 0 || !playerHasCards) {
        state.gameOver = true;
        addLog("プレイヤーの敗北...残念だったぴょん。");
        document.getElementById('status-text').textContent = "プレイヤーの敗北..."; // Update status text
        alert("YOU LOSE... 残念だったぴょん。");
        showScreen('title-screen');
        return;
    }
}

function initBattle() {
    state = getInitialState(); // Reset all state variables
    // Init decks and hands
    const suits = ['fire', 'water', 'wind', 'earth'];
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']; 
    const totalDeckSize = 30; 

    let fullDeck = [];
    suits.forEach(suit => {
        ranks.forEach(rank => {
            fullDeck.push(new Card(suit, rank));
        });
        SUPPORTS.forEach(a => fullDeck.push(new Card(suit, a, 'support'))); // Add support cards to fullDeck
    });

    fullDeck = fullDeck.slice(0, totalDeckSize);

    for (let i = fullDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [fullDeck[i], fullDeck[j]] = [fullDeck[j], fullDeck[i]];
    }

    state.player.hand = fullDeck.splice(0, 5); 
    state.opponent.hand = fullDeck.splice(0, 2); 
    state.opponent.handCount = state.opponent.hand.length; 

    state.player.deck = fullDeck.splice(0, Math.floor(fullDeck.length / 2));
    state.opponent.deck = fullDeck; 
    
    // Place some initial cards for opponent on field for testing purposes
    for(let i=0; i<3; i++) {
        if (state.opponent.deck.length > 0) {
            const oppCard = state.opponent.deck.shift();
            state.opponent.field[i] = oppCard;
        }
    }
    
    showScreen('game-screen'); 
    startRoulette(); 
}

function startRoulette() {
    const overlay = document.getElementById('roulette-overlay'); overlay.style.display = 'flex';
    let count = 0;
    const interval = setInterval(() => {
        overlay.textContent = count % 2 === 0 ? "プレイヤー先攻？" : "相手先攻？";
        if (++count > 10) {
            clearInterval(interval);
            const isPlayer = Math.random() > 0.5;
            state.turn = isPlayer ? 'player' : 'opponent';
            overlay.textContent = isPlayer ? "プレイヤー先攻" : "相手先攻";
            setTimeout(() => { 
                overlay.style.display = 'none'; 
                if (state.turn === 'player') {
                    state.canPlaceCard = true; // Player can place cards
                    state.statusText = "カードを配置してください。";
                    render(); // Render after setting state
                } else {
                    state.canPlaceCard = false; // Opponent's turn, player cannot place
                    state.statusText = "相手のターンです...";
                    render(); // Render after setting state
                    setTimeout(opponentAI, 1000); // Start opponent's turn after a delay
                }
            }, 1000);
        }
    }, 100);
}
</script>
</body>
</html>