<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Roen Card Game - Full Integrated Perfect</title>
    <style>
        :root {
            --fire-color: #FF7B7B; --water-color: #7B8CFF;
            --wind-color: #7BFFB8; --earth-color: #C19A6B;
            --card-width: 63px; --card-height: 91px;
            --accent: #FFCC00;
        }
        body { background-color: #3D3D3D; color: #F0F0F0; font-family: sans-serif; margin: 0; overflow: hidden; }
        
        .screen { display: none; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
        .screen.active { display: flex; flex-direction: column; align-items: center; justify-content: center; }

        .menu-btn { width: 260px; padding: 15px; margin: 10px; background: #444; border: 2px solid #666; color: white; cursor: pointer; border-radius: 10px; font-weight: bold; text-align: center; font-size: 1.1em; }
        .menu-btn:hover { border-color: var(--accent); background: #555; transform: scale(1.02); }
        .game-button { padding: 8px 16px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-weight: bold; }
        .game-button:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }

        /* --- ゲーム画面（Restored Version）のスタイル --- */
        .game-container { width: 100%; max-width: 1000px; display: flex; flex-direction: column; height: 100vh; position: relative; }
        .field { 
            display: grid; 
            grid-template-areas: "slot0 slot1 slot2" "slot5 slot4 slot3"; 
            gap: 10px; padding: 15px; justify-content: center; background: rgba(0,0,0,0.2);
        }
        .field.opponent-field-layout {
            grid-template-areas: "slot3 slot4 slot5" "slot2 slot1 slot0";
        }
        .card-slot { width: var(--card-width); height: var(--card-height); background: rgba(255,255,255,0.05); border-radius: 8px; display: flex; justify-content: center; align-items: center; position: relative; border: 1px dashed rgba(255,255,255,0.2); }
        
        .card { 
            width: 100%; height: 100%; border-radius: 8px; color: #333; cursor: pointer; 
            position: relative; box-sizing: border-box; display: flex; flex-direction: column;
            justify-content: space-between; padding: 5px; font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .card.fire { background-color: var(--fire-color); }
        .card.water { background-color: var(--water-color); }
        .card.wind { background-color: var(--wind-color); }
        .card.earth { background-color: var(--earth-color); }
        .card.back { background-color: #666; border: 2px solid #444; }
        .card.selected { outline: 4px solid yellow; z-index: 10; }
        .card.attacked { filter: grayscale(0.9) brightness(0.7); cursor: default; }

        .rank-top { font-size: 1.2em; text-align: left; }
        .suit-center { background: rgba(255,255,255,0.4); padding: 2px 8px; border-radius: 4px; align-self: center; font-size: 0.8em; }
        .stats-bottom { font-size: 0.8em; display: flex; flex-direction: column; align-items: flex-start; }
        .hp-badge { position: absolute; top: 5px; right: 5px; background: rgba(0,0,0,0.6); color: white; padding: 1px 4px; border-radius: 4px; font-size: 0.7em; }

        .player-hand, .opponent-hand-area { height: calc(var(--card-height) + 20px); display: flex; justify-content: center; align-items: center; gap: 8px; background: rgba(0,0,0,0.4); }
        .player-hand .card { width: var(--card-width); height: var(--card-height); }
        .opponent-hand-area .card { width: var(--card-width); height: var(--card-height); }
        
        .card-pile-slot { 
            width: var(--card-width); height: var(--card-height); 
            background: rgba(255,255,255,0.08); border-radius: 8px; 
            border: 1px dashed rgba(255,255,255,0.2); display: flex; 
            justify-content: center; align-items: center; position: relative; 
            font-size: 0.9em; font-weight: bold; color: #F0F0F0; overflow: hidden; 
        }
        .card-pile-slot.empty::before { content: "0"; color: rgba(255,255,255,0.4); }
        .card-pile-slot.has-cards::before { content: attr(data-count); color: #F0F0F0; position: absolute; z-index: 2; }
        .card-pile-slot.deck-back { background-color: #666; border: 2px solid #444; }

        .log-area { position: absolute; left: 10px; top: 10px; width: 200px; height: 150px; background: rgba(0,0,0,0.8); font-size: 10px; overflow-y: auto; padding: 10px; border-radius: 5px; border: 1px solid #555; z-index: 100; }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 15px; background: #222; color: #F0F0F0; font-size: 0.9em; border-top: 1px solid #444; border-bottom: 1px solid #444; }
        .info-row.opponent-info-row { flex-direction: row-reverse; }
        .control-lane { display: flex; justify-content: space-around; align-items: center; background: #222; padding: 10px; }
        .score-display { font-size: 4em; font-weight: bold; color: #F0F0F0; min-width: 80px; text-align: center; }
        .score-display.opponent-score { color: #FF7B7B; }
        .score-display.player-score { color: #7B8CFF; }

        /* エディタ用の追加スタイル */
        .slot { background: #444; border: 2px solid #666; padding: 10px; border-radius: 8px; cursor: pointer; text-align: center; }
        .editor-layout { display: flex; gap: 20px; width: 95%; height: 75vh; }
        .scroll-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 10px; overflow-y: auto; flex-grow: 1; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="title-screen" class="screen active">
    <h1 style="font-size: 3em; color:var(--accent); text-shadow: 2px 2px 10px rgba(0,0,0,0.5);">Roen Card Game</h1>
    <div class="menu-btn" onclick="showScreen('mode-screen')">ADVENTURE / BATTLE</div>
    <div class="menu-btn" onclick="openDeckList()">DECK EDITOR (100 Slots)</div>
    <div class="menu-btn" onclick="showScreen('collection-screen')">CARD COLLECTION</div>
    <div class="menu-btn" onclick="showScreen('settings-screen')">GAME SETTINGS</div>
</div>

<div id="game-screen" class="screen">
    <div class="game-container">
        <div id="log-area" class="log-area"><strong>ゲームログ</strong></div>
        <div id="opponent-hand" class="opponent-hand-area"></div>
        <div class="opponent-area"><div id="opponent-field" class="field opponent-field-layout"></div></div>
        <div id="opponent-info-row" class="info-row opponent-info-row">
            <div class="info-item">手札: <span id="opp-hand-count">5</span></div>
            <div class="info-item">墓地: <div id="opp-graveyard" class="card-pile-slot"></div></div>
            <div class="info-item">山札: <div id="opp-deck" class="card-pile-slot"></div></div>
            <div class="info-item" style="color:#FFD700">パワー: <span id="opp-power-display">0</span></div>
        </div>
        <div class="control-lane">
            <div class="score-display opponent-score" id="opp-hp-display">HP: <span id="opp-hp-value">0</span></div>
            <div class="center-controls">
                <div id="status-text" style="color:yellow; font-weight:bold;">準備OK</div>
                <button id="ok-btn" class="game-button" onclick="confirmPlacement()">配置OK</button>
                <div id="battle-controls" style="display:none; flex-direction: column; gap: 10px; align-items: center;">
                    <button id="power-btn" class="game-button" style="background:#ccac00" onclick="handlePowerInject()">パワー</button>
                    <button id="end-turn-btn" class="game-button" onclick="handleEndTurn()">ターン終了</button>
                    <button id="restart-btn" class="game-button" style="background:#888; display:none;" onclick="resetGame()">リスタート</button>
                </div>
            </div>
            <div class="score-display player-score" id="ply-hp-display">HP: <span id="ply-hp-value">0</span></div>
        </div>
        <div id="player-info-row" class="info-row">
            <div class="info-item" style="color:#FFD700">パワー: <span id="ply-power-display">5</span></div>
            <div class="info-item">山札: <div id="ply-deck" class="card-pile-slot"></div></div>
            <div class="info-item">墓地: <div id="ply-graveyard" class="card-pile-slot"></div></div>
            <div class="info-item">手札: <span id="ply-hand-count">0</span></div>
        </div>
        <div class="player-area"><div id="player-field" class="field"></div></div>
        <div id="player-hand" class="player-hand"></div>
    </div>
</div>

<div id="editor-screen" class="screen">
    <h2>DECK EDITOR</h2>
    <div class="editor-layout">
        <div style="flex:1; display:flex; flex-direction:column;"><h3>POOL</h3><div id="pool-grid" class="scroll-grid"></div></div>
        <div style="flex:1; display:flex; flex-direction:column;"><h3>DECK (<span id="deck-count">0</span>/40)</h3><div id="current-deck-grid" class="scroll-grid"></div></div>
    </div>
    <button class="game-button" onclick="saveDeck()">SAVE & EXIT</button>
</div>

<div id="mode-screen" class="screen">
    <h2>SELECT MODE</h2>
    <div class="menu-btn" style="background:#4CAF50" onclick="initBattle()">VS RANDOM AI</div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="collection-screen" class="screen">
    <h2>COLLECTION</h2>
    <div id="coll-grid" class="scroll-grid" style="width:90%"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="deck-list-screen" class="screen">
    <h2>CHOOSE DECK SLOT</h2>
    <div id="deck-grid" style="display:grid; grid-template-columns: repeat(5,1fr); gap:10px;"></div>
    <div class="menu-btn" onclick="showScreen('title-screen')">BACK</div>
</div>

<script>
const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2 };
const SUITS = ['fire', 'water', 'wind', 'earth'];

class Card {
    constructor(suit, rank) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.suit = suit; this.rank = rank;
        this.value = RANK_VALUES[rank] || 0;
        this.hp = this.value; this.maxHp = this.value;
        this.attachedPower = 0;
        this.requiredPower = this.value >= 13 ? 3 : this.value >= 9 ? 2 : 1;
    }
}

let state = {
    player: { hand: [], field: Array(6).fill(null), attackedIds: [], power: 5, hp: 20, deck: [], graveyard: [], powerInjectedThisTurn: false },
    opponent: { hand: [], handCount: 0, field: Array(6).fill(null), power: 5, hp: 20, deck: [], graveyard: [] },
    selectedCard: null, turn: 'player', canPlaceCard: true, gameEnd: false, editIdx: 1, editCards: []
};

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    if(id === 'collection-screen') renderCollection();
}

function addLog(msg) {
    const log = document.getElementById('log-area');
    log.innerHTML += `<div>> ${msg}</div>`;
    log.scrollTop = log.scrollHeight;
}

function createCardEl(card) {
    const div = document.createElement('div');
    div.className = `card ${card.suit}`;
    div.innerHTML = `<div class="hp-badge">${card.hp}/${card.maxHp}</div><div class="rank-top">${card.rank}</div><div class="suit-center">${card.suit}</div><div class="stats-bottom"><div>Power: ${card.attachedPower}/${card.requiredPower}</div><div>ATK: ${card.value + card.attachedPower}</div></div>`;
    return div;
}

function render() {
    renderField('player-field', state.player.field, false);
    renderField('opponent-field', state.opponent.field, true);
    const handEl = document.getElementById('player-hand'); handEl.innerHTML = '';
    state.player.hand.forEach(card => {
        const el = createCardEl(card);
        el.onclick = () => { if(!state.gameEnd) { state.selectedCard = card; render(); } };
        if (state.selectedCard === card) el.classList.add('selected');
        handEl.appendChild(el);
    });
    const oppHandEl = document.getElementById('opponent-hand'); oppHandEl.innerHTML = '';
    for(let i=0; i<state.opponent.handCount; i++) {
        const back = document.createElement('div'); back.className = 'card back'; oppHandEl.appendChild(back);
    }

    // UI更新
    document.getElementById('opp-hand-count').textContent = state.opponent.handCount;
    updatePile('opp-graveyard', state.opponent.graveyard.length);
    updatePile('opp-deck', `${state.opponent.deck.length}/30`, true);
    document.getElementById('opp-power-display').textContent = state.opponent.power;
    document.getElementById('ply-hand-count').textContent = state.player.hand.length;
    updatePile('ply-graveyard', state.player.graveyard.length);
    updatePile('ply-deck', `${state.player.deck.length}/30`, true);
    document.getElementById('ply-power-display').textContent = state.player.power;
    document.getElementById('opp-hp-value').textContent = state.opponent.hp;
    document.getElementById('ply-hp-value').textContent = state.player.hp;
    document.getElementById('status-text').textContent = state.statusText;

    if (state.player.hp <= 0 || state.opponent.hp <= 0) {
        state.gameEnd = true;
        state.statusText = state.player.hp <= 0 ? "LOSE..." : "WIN!";
        document.getElementById('restart-btn').style.display = 'block';
    }
    document.getElementById('ok-btn').style.display = (state.canPlaceCard && !state.gameEnd) ? 'block' : 'none';
    document.getElementById('battle-controls').style.display = (!state.canPlaceCard || state.gameEnd) ? 'flex' : 'none';
}

function updatePile(id, count, isDeck) {
    const el = document.getElementById(id);
    el.dataset.count = count;
    el.className = `card-pile-slot ${parseInt(count) > 0 ? 'has-cards' : 'empty'} ${isDeck ? 'deck-back' : ''}`;
}

function renderField(id, field, isOpponent) {
    const el = document.getElementById(id); el.innerHTML = '';
    field.forEach((card, i) => {
        const slot = document.createElement('div'); slot.className = 'card-slot'; slot.style.gridArea = `slot${i}`;
        if (card) {
            const cardEl = createCardEl(card);
            if (!isOpponent && state.player.attackedIds.includes(card.id)) cardEl.classList.add('attacked');
            if (state.selectedCard === card) cardEl.classList.add('selected');
            cardEl.onclick = (e) => { e.stopPropagation(); if(isOpponent) handleAttack(card); else handleFieldClick(card, i); };
            slot.appendChild(cardEl);
        } else if (state.canPlaceCard && !isOpponent) {
            slot.onclick = () => placeCard(i);
        }
        el.appendChild(slot);
    });
}

function placeCard(i) {
    if (!state.selectedCard) return;
    state.player.field[i] = state.selectedCard;
    state.player.hand = state.player.hand.filter(c => c !== state.selectedCard);
    state.selectedCard = null; render();
}

function handleFieldClick(card, i) {
    if (state.canPlaceCard) { state.player.hand.push(card); state.player.field[i] = null; }
    else { state.selectedCard = card; }
    render();
}

function handlePowerInject() {
    if (state.player.powerInjectedThisTurn || !state.selectedCard || !state.player.field.includes(state.selectedCard)) return;
    const c = state.selectedCard;
    if (c.attachedPower < c.requiredPower && state.player.power > 0) {
        c.attachedPower++; state.player.power--; state.player.powerInjectedThisTurn = true;
        addLog(`${c.rank}にパワー注入`); render();
    }
}

function handleAttack(target) {
    if (state.canPlaceCard || !state.selectedCard || state.player.attackedIds.includes(state.selectedCard.id)) return;
    const atk = state.selectedCard;
    if (atk.attachedPower < atk.requiredPower) { addLog("パワー不足！"); return; }
    target.hp -= (atk.value + atk.attachedPower);
    state.player.attackedIds.push(atk.id);
    if (target.hp <= 0) {
        state.opponent.field[state.opponent.field.indexOf(target)] = null;
        state.opponent.graveyard.push(target);
    }
    state.selectedCard = null; render();
}

function confirmPlacement() { state.canPlaceCard = false; state.statusText = "バトル開始！"; render(); }

function handleEndTurn() {
    state.player.attackedIds = []; state.player.power = 5; state.player.powerInjectedThisTurn = false;
    state.statusText = "相手のターン..."; render(); setTimeout(opponentTurn, 1000);
}

function opponentTurn() {
    addLog("相手の行動");
    // 簡易AI
    const empty = state.opponent.field.indexOf(null);
    if (empty !== -1 && state.opponent.deck.length > 0) {
        state.opponent.field[empty] = state.opponent.deck.shift();
    }
    const atkCard = state.opponent.field.find(c => c !== null);
    if (atkCard) {
        const target = state.player.field.find(c => c !== null);
        if (target) { target.hp -= atkCard.value; if(target.hp <= 0) { state.player.field[state.player.field.indexOf(target)] = null; state.player.hp--; } }
        else { state.player.hp -= atkCard.value; }
    }
    state.statusText = "あなたのターン"; render();
}

function initBattle() {
    state.player = { hand: [], field: Array(6).fill(null), attackedIds: [], power: 5, hp: 20, deck: [], graveyard: [], powerInjectedThisTurn: false };
    state.opponent = { hand: [], handCount: 5, field: Array(6).fill(null), power: 5, hp: 20, deck: [], graveyard: [] };
    state.gameEnd = false; state.canPlaceCard = true;
    for(let i=0; i<30; i++) {
        state.player.deck.push(new Card(SUITS[i%4], Object.keys(RANK_VALUES)[Math.floor(Math.random()*13)]));
        state.opponent.deck.push(new Card(SUITS[i%4], Object.keys(RANK_VALUES)[Math.floor(Math.random()*13)]));
    }
    state.player.hand = state.player.deck.splice(0,5);
    for(let i=0; i<3; i++) state.opponent.field[i] = state.opponent.deck.shift();
    showScreen('game-screen'); render();
}

function resetGame() { initBattle(); }

// デッキエディタ・コレクション（以前の機能を維持）
function openDeckList() {
    const grid = document.getElementById('deck-grid'); grid.innerHTML = '';
    for(let i=1; i<=100; i++) {
        const slot = document.createElement('div'); slot.className = 'slot';
        slot.innerHTML = `Slot ${i}`; slot.onclick = () => { state.editIdx = i; showScreen('editor-screen'); };
        grid.appendChild(slot);
    }
    showScreen('deck-list-screen');
}
function saveDeck() { showScreen('title-screen'); }
function renderCollection() {
    const grid = document.getElementById('coll-grid'); grid.innerHTML = '';
    SUITS.forEach(s => Object.keys(RANK_VALUES).forEach(r => grid.appendChild(createCardEl(new Card(s, r)))));
}
</script>
</body>
</html>