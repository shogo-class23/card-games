<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Mark Inscribed Monster - Complete Support Edition</title>
    <style>
        :root {
            --fire: #FF7B7B; --water: #7B8CFF; --wind: #7BFFB8; --earth: #C19A6B;
            --accent: #FFCC00; --card-w: 65px; --card-h: 95px;
        }
        body { background: #2C2C2C; color: #F0F0F0; font-family: sans-serif; margin: 0; overflow: hidden; }
        .screen { display: none; width: 100vw; height: 100vh; flex-direction: column; align-items: center; justify-content: center; position: absolute; }
        .screen.active { display: flex; }

        .menu-btn { width: 240px; padding: 12px; margin: 8px; background: #444; border: 2px solid #666; color: white; cursor: pointer; border-radius: 8px; font-weight: bold; text-align: center; }
        .menu-btn:hover { border-color: var(--accent); background: #555; }
        .start-btn { background: #4CAF50; border-color: #81C784; }

        /* Card Styles */
        .card { width: var(--card-w); height: var(--card-h); border-radius: 6px; cursor: pointer; position: relative; display: flex; flex-direction: column; justify-content: space-between; padding: 4px; box-sizing: border-box; font-size: 0.7em; color: #333; font-weight: bold; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); border: 1px solid rgba(0,0,0,0.2); }
        .card.fire { background: var(--fire); } .card.water { background: var(--water); }
        .card.wind { background: var(--wind); } .card.earth { background: var(--earth); }
        .card.support { border: 2px solid white; background: #F8F8F8; }
        .card.selected { outline: 3px solid var(--accent); transform: translateY(-5px); z-index: 10; }
        .hp-badge { position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.7); color: white; padding: 1px 3px; border-radius: 3px; font-size: 0.8em; }

        /* Battle / Grids */
        .field { display: grid; grid-template-areas: "s0 s1 s2" "s5 s4 s3"; gap: 8px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; }
        .opp-field { grid-template-areas: "s3 s4 s5" "s2 s1 s0"; }
        .slot { width: var(--card-w); height: var(--card-h); background: rgba(255,255,255,0.05); border: 1px dashed #666; border-radius: 6px; display: flex; justify-content: center; align-items: center; position: relative; }
        .grid-list { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-height: 60vh; overflow-y: auto; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; width: 90%; }
        .scroll-box { flex: 1; background: rgba(0,0,0,0.4); padding: 10px; border-radius: 10px; overflow-y: auto; height: 100%; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(65px, 1fr)); gap: 8px; }
    </style>
</head>
<body>

<div id="title-screen" class="screen active">
    <h1 id="t-title" style="color: var(--accent); font-size: 2.5em;">Mark Inscribed Monster</h1>
    <div class="menu-btn start-btn" id="btn-start" onclick="showScreen('mode-screen')">START</div>
    <div class="menu-btn" id="btn-settings" onclick="showScreen('settings-screen')">SETTINGS</div>
    <div class="menu-btn" id="btn-rules" onclick="showScreen('rule-screen')">RULES</div>
    <div class="menu-btn" id="btn-coll" onclick="openCollection()">COLLECTION</div>
</div>

<div id="mode-screen" class="screen">
    <h2 id="t-mode">SELECT MODE</h2>
    <div class="menu-btn start-btn" id="btn-random" onclick="startBattle()">AI RANDOM MATCH</div>
    <div class="menu-btn" id="btn-deck" onclick="openDeckList()" style="background:#5C6BC0">DECK BUILD (100)</div>
    <div class="menu-btn btn-back" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="settings-screen" class="screen">
    <h2 id="t-settings">SETTINGS</h2>
    <div class="menu-btn" onclick="setLang('jp')">日本語</div>
    <div class="menu-btn" onclick="setLang('en')">English</div>
    <div class="menu-btn btn-back" onclick="showScreen('title-screen')">BACK</div>
</div>

<div id="rule-screen" class="screen">
    <div style="background:rgba(0,0,0,0.8); padding:20px; border-radius:10px; width:70%;">
        <h3 id="t-rule-head">RULES</h3>
        <p id="t-rule-desc"></p>
        <button class="menu-btn btn-back" onclick="showScreen('title-screen')">CLOSE</button>
    </div>
</div>

<div id="collection-screen" class="screen">
    <h2 id="t-coll">COLLECTION</h2>
    <div id="coll-grid" class="grid-list" style="grid-template-columns: repeat(7, 1fr);"></div>
    <button class="menu-btn btn-back" onclick="showScreen('title-screen')">BACK</button>
</div>

<div id="deck-list-screen" class="screen">
    <h2 id="t-deck-list">DECK LIST</h2>
    <div id="deck-grid" class="grid-list"></div>
    <button class="menu-btn btn-back" onclick="showScreen('mode-screen')">BACK</button>
</div>

<div id="editor-screen" class="screen">
    <h3 id="editor-title">Editor</h3>
    <div style="display: flex; width: 95%; height: 70vh; gap: 15px; margin-bottom: 10px;">
        <div class="scroll-box"><h4>POOL</h4><div id="pool-grid" class="card-grid"></div></div>
        <div class="scroll-box"><h4>DECK (<span id="deck-cnt">0</span>/40)</h4><div id="edit-deck-grid" class="card-grid"></div></div>
    </div>
    <div style="display:flex; gap:10px;">
        <button class="menu-btn" style="background:#27ae60" onclick="saveDeck()">SAVE</button>
        <button class="menu-btn" style="background:#c0392b" onclick="showScreen('deck-list-screen')">CANCEL</button>
    </div>
</div>

<div id="game-screen" class="screen">
    <div id="opp-hp-disp" style="color:var(--fire); font-size:1.5em;">ENEMY HP: 20</div>
    <div class="field opp-field" id="opp-field"></div>
    <div style="margin: 10px; display:flex; gap:10px; align-items:center;">
        <span id="phase-txt" style="color:yellow; font-weight:bold;">Phase: Setup</span>
        <button id="ok-btn" class="menu-btn" style="width:80px; padding:5px;" onclick="finishSetup()">OK</button>
        <button id="pwr-btn" class="menu-btn" style="width:80px; padding:5px; display:none; background:var(--accent); color:black;" onclick="addPower()">POWER</button>
        <button id="end-btn" class="menu-btn" style="width:80px; padding:5px; display:none;" onclick="endTurn()">END</button>
    </div>
    <div class="field" id="ply-field"></div>
    <div id="ply-hp-disp" style="color:var(--water); font-size:1.5em;">PLAYER HP: 20</div>
    <div id="ply-hand" style="height:105px; display:flex; gap:5px; padding:10px;"></div>
</div>

<script>
const SUITS = ['fire', 'water', 'wind', 'earth'];
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const SUPPORTS = ['2DRAW','SKIP','HEAL'];
const RANK_VALS = {'A':14,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13};
const LANG_DATA = {
    jp: {
        "btn-start": "スタート", "btn-settings": "設定", "btn-rules": "ルール", "btn-coll": "コレクション",
        "t-mode": "モード選択", "btn-random": "AIランダムマッチ", "btn-deck": "デッキ作成 (100)",
        "t-settings": "設定", "t-rule-head": "ルール", "t-rule-desc": "配置して「OK」！Pを貯めて攻撃！<br>相手のHPを0にすれば勝ちだぴょん！",
        "t-coll": "カード図鑑", "t-deck-list": "デッキリスト", "btn-back": "戻る",
        "phase-setup": "フェーズ: セットアップ", "phase-battle": "フェーズ: バトル"
    },
    en: {
        "btn-start": "START", "btn-settings": "SETTINGS", "btn-rules": "RULES", "btn-coll": "COLLECTION",
        "t-mode": "SELECT MODE", "btn-random": "AI RANDOM MATCH", "btn-deck": "DECK BUILD (100)",
        "t-settings": "SETTINGS", "t-rule-head": "RULES", "t-rule-desc": "Place and 'OK'! Charge P to attack.<br>Reduce Enemy HP to 0 to win!",
        "t-coll": "COLLECTION", "t-deck-list": "DECK LIST", "btn-back": "BACK",
        "phase-setup": "Phase: Setup", "phase-battle": "Phase: Battle"
    }
};

let currentLang = localStorage.getItem('lang') || 'jp';
let state = {
    player: { hp: 20, hand: [], field: Array(6).fill(null), attacked: [], pwrUsed: false },
    opponent: { hp: 20, field: Array(6).fill(null) },
    canPlace: true, selected: null, editIdx: -1, editCards: []
};

class Card {
    constructor(suit, rank, type = 'monster') {
        this.id = Math.random().toString(36).substr(2,9);
        this.suit = suit; this.rank = rank; this.type = type;
        this.val = RANK_VALS[rank] || 0;
        this.hp = this.val; this.p = 0; this.req = this.val >= 11 ? 2 : 1;
        if(type === 'support') this.ability = rank;
    }
}

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

function setLang(lang) { currentLang = lang; localStorage.setItem('lang', lang); applyLang(); }

function applyLang() {
    const data = LANG_DATA[currentLang];
    for (let id in data) { if (document.getElementById(id)) document.getElementById(id).innerHTML = data[id]; }
    document.querySelectorAll('.btn-back').forEach(btn => btn.innerText = data["btn-back"]);
}

function createCardUI(c, isEditor = false, isPool = false) {
    const div = document.createElement('div');
    div.className = `card ${c.type === 'support' ? 'support' : c.suit}`;
    if(state.selected && state.selected.id === c.id) div.classList.add('selected');
    if(c.type === 'support') {
        div.innerHTML = `<div style="color:blue">SUP</div><div style="font-size:1em">${c.ability}</div><div style="font-size:0.7em">${c.suit.toUpperCase()}</div>`;
    } else {
        div.innerHTML = `<div class="hp-badge">${c.hp}</div><div style="font-size:1.4em">${c.rank}</div><div>${c.suit.toUpperCase()}</div><div style="font-size:0.7em">P:${c.p}/${c.req}</div>`;
    }
    div.onclick = (e) => {
        e.stopPropagation();
        if(isEditor) {
            if(isPool) { if(state.editCards.length < 40) state.editCards.push(new Card(c.suit, c.rank, c.type)); }
            else { state.editCards.splice(state.editCards.indexOf(c), 1); }
            renderEditor();
        } else { state.selected = c; renderGame(); }
    };
    return div;
}

// --- Deck Management ---
function openDeckList() {
    const grid = document.getElementById('deck-grid'); grid.innerHTML = '';
    for(let i=1; i<=100; i++) {
        const name = localStorage.getItem(`deck_name_${i}`) || `DECK ${i}`;
        const slot = document.createElement('div'); slot.className = 'slot'; slot.style.width="150px";
        slot.innerHTML = `<div>${name}</div><small>Slot ${i}</small>`;
        slot.onclick = () => { state.editIdx = i; enterEditor(); };
        grid.appendChild(slot);
    }
    showScreen('deck-list-screen');
}

function enterEditor() {
    const saved = localStorage.getItem(`deck_cards_${state.editIdx}`);
    state.editCards = saved ? JSON.parse(saved).map(d => Object.assign(new Card(), d)) : [];
    const pool = document.getElementById('pool-grid'); pool.innerHTML = '';
    SUITS.forEach(s => {
        RANKS.forEach(r => pool.appendChild(createCardUI(new Card(s, r), true, true)));
        SUPPORTS.forEach(a => pool.appendChild(createCardUI(new Card(s, a, 'support'), true, true)));
    });
    renderEditor(); showScreen('editor-screen');
}

function renderEditor() {
    const grid = document.getElementById('edit-deck-grid'); grid.innerHTML = '';
    state.editCards.forEach(c => grid.appendChild(createCardUI(c, true, false)));
    document.getElementById('deck-cnt').textContent = state.editCards.length;
}

function saveDeck() {
    localStorage.setItem(`deck_cards_${state.editIdx}`, JSON.stringify(state.editCards));
    const name = prompt("Name:", localStorage.getItem(`deck_name_${state.editIdx}`) || `DECK ${state.editIdx}`);
    if(name) localStorage.setItem(`deck_name_${state.editIdx}`, name);
    openDeckList();
}

// --- Battle Logic ---
function startBattle() {
    state.player.hp = 20; state.opponent.hp = 20;
    state.player.field = Array(6).fill(null); state.opponent.field = Array(6).fill(null);
    state.player.hand = [new Card('fire','A'), new Card('water','5'), new Card('earth','HEAL','support'), new Card('wind','2DRAW','support')];
    state.opponent.field[0] = new Card('fire','10');
    state.canPlace = true; state.player.attacked = [];
    document.getElementById('ok-btn').style.display = 'inline-block';
    document.getElementById('pwr-btn').style.display = 'none';
    document.getElementById('end-btn').style.display = 'none';
    renderGame(); showScreen('game-screen'); applyLang();
}

function renderGame() {
    const h = document.getElementById('ply-hand'); h.innerHTML = '';
    state.player.hand.forEach(c => h.appendChild(createCardUI(c)));
    drawField('ply-field', state.player.field, false);
    drawField('opp-field', state.opponent.field, true);
    document.getElementById('ply-hp-disp').textContent = "PLAYER HP: " + state.player.hp;
    document.getElementById('opp-hp-disp').textContent = "ENEMY HP: " + state.opponent.hp;
}

function drawField(id, field, isOpp) {
    const container = document.getElementById(id); container.innerHTML = '';
    field.forEach((c, i) => {
        const slot = document.createElement('div'); slot.className = 'slot';
        slot.style.gridArea = `s${i}`;
        if(c) {
            const ui = createCardUI(c);
            if(!isOpp && state.player.attacked.includes(c.id)) ui.style.filter = 'brightness(0.5)';
            ui.onclick = () => isOpp ? resolveAttack(c) : selectFromField(c, i);
            slot.appendChild(ui);
        } else if(!isOpp && state.canPlace) {
            slot.onclick = () => {
                if(state.selected && state.player.hand.includes(state.selected) && state.selected.type === 'monster') {
                    state.player.field[i] = state.selected;
                    state.player.hand.splice(state.player.hand.indexOf(state.selected), 1);
                    state.selected = null; renderGame();
                }
            };
        }
        container.appendChild(slot);
    });
}

function selectFromField(c, i) {
    if(state.canPlace) { state.player.hand.push(c); state.player.field[i] = null; }
    else { state.selected = c; }
    renderGame();
}

function finishSetup() {
    state.canPlace = false;
    document.getElementById('ok-btn').style.display = 'none';
    document.getElementById('pwr-btn').style.display = 'inline-block';
    document.getElementById('end-btn').style.display = 'inline-block';
    applyLang(); renderGame();
}

function addPower() {
    if(!state.pwrUsed && state.selected && state.player.field.includes(state.selected)) {
        state.selected.p++; state.pwrUsed = true; renderGame();
    }
}

function resolveAttack(target) {
    if(state.canPlace || !state.selected || state.player.attacked.includes(state.selected.id)) return;
    if(!state.player.field.includes(state.selected)) return;
    if(state.selected.p < state.selected.req) { alert("Power Lack!"); return; }
    target.hp -= (state.selected.val + state.selected.p);
    state.player.attacked.push(state.selected.id);
    if(target.hp <= 0) state.opponent.field[state.opponent.field.indexOf(target)] = null;
    checkWin(); renderGame();
}

function endTurn() {
    state.player.attacked = []; state.pwrUsed = false;
    const enemy = state.opponent.field.find(c => c !== null);
    if(enemy) {
        const target = state.player.field.find(c => c !== null);
        if(target) target.hp -= enemy.val; else state.player.hp -= 2;
    }
    checkWin(); renderGame();
}

function checkWin() {
    if(state.opponent.hp <= 0) { alert("WIN!"); showScreen('title-screen'); }
    else if(state.player.hp <= 0) { alert("LOSE..."); showScreen('title-screen'); }
}

function openCollection() {
    const grid = document.getElementById('coll-grid'); grid.innerHTML = '';
    SUITS.forEach(s => {
        RANKS.forEach(r => grid.appendChild(createCardUI(new Card(s, r))));
        SUPPORTS.forEach(a => grid.appendChild(createCardUI(new Card(s, a, 'support'))));
    });
    showScreen('collection-screen');
}

applyLang();
</script>
</body>
</html>